{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/cake.jpg","path":"img/cake.jpg","modified":0,"renderable":0},{"_id":"source/img/icecream.jpg","path":"img/icecream.jpg","modified":0,"renderable":0},{"_id":"source/img/image-20230924004300712.png","path":"img/image-20230924004300712.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924004452513.png","path":"img/image-20230924004452513.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924004606568.png","path":"img/image-20230924004606568.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924004941048.png","path":"img/image-20230924004941048.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924004955141.png","path":"img/image-20230924004955141.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924005037622.png","path":"img/image-20230924005037622.png","modified":0,"renderable":0},{"_id":"source/img/image-20230924203236506.png","path":"img/image-20230924203236506.png","modified":0,"renderable":0},{"_id":"source/img/image-20230926224301341.png","path":"img/image-20230926224301341.png","modified":0,"renderable":0},{"_id":"source/img/image-20230927033247981.png","path":"img/image-20230927033247981.png","modified":0,"renderable":0},{"_id":"source/img/image-20230927033542151.png","path":"img/image-20230927033542151.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928082013863.png","path":"img/image-20230928082013863.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928082103488.png","path":"img/image-20230928082103488.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928082117273.png","path":"img/image-20230928082117273.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928213734939.png","path":"img/image-20230928213734939.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928213416192.png","path":"img/image-20230928213416192.png","modified":0,"renderable":0},{"_id":"source/img/image-20230928213811991.png","path":"img/image-20230928213811991.png","modified":0,"renderable":0},{"_id":"source/img/rice.jpg","path":"img/rice.jpg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","path":"icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","path":"icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/886a749e.css","path":"static/886a749e.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/3e25f349.css","path":"static/css/3e25f349.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/882f9706.css","path":"static/css/882f9706.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/8e0e69c4.css","path":"static/css/8e0e69c4.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/6b275704.css","path":"static/css/6b275704.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/css/9a0271b0.css","path":"static/css/9a0271b0.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/img/dccf965f.jpg","path":"static/img/dccf965f.jpg","modified":0,"renderable":1},{"_id":"source/img/image-20231005073508368.png","path":"img/image-20231005073508368.png","modified":0,"renderable":0},{"_id":"source/img/image-20231005092540398.png","path":"img/image-20231005092540398.png","modified":0,"renderable":0},{"_id":"source/img/image-20231005092611718.png","path":"img/image-20231005092611718.png","modified":0,"renderable":0},{"_id":"source/img/image-20231005092614348.png","path":"img/image-20231005092614348.png","modified":0,"renderable":0},{"_id":"source/img/image-20231005093309025.png","path":"img/image-20231005093309025.png","modified":0,"renderable":0},{"_id":"source/img/image-20231008225001226.png","path":"img/image-20231008225001226.png","modified":0,"renderable":0},{"_id":"source/img/image-20231008234542259.png","path":"img/image-20231008234542259.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009001757777.png","path":"img/image-20231009001757777.png","modified":0,"renderable":0},{"_id":"source/img/image-20231005121023638.png","path":"img/image-20231005121023638.png","modified":0,"renderable":0},{"_id":"source/doc/Test Learning/test-principle-all-in-one.xlsx","path":"doc/Test Learning/test-principle-all-in-one.xlsx","modified":0,"renderable":0},{"_id":"source/img/image-20231009143738559.png","path":"img/image-20231009143738559.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009213653825.png","path":"img/image-20231009213653825.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009213724620.png","path":"img/image-20231009213724620.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009213702116.png","path":"img/image-20231009213702116.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009225919124.png","path":"img/image-20231009225919124.png","modified":0,"renderable":0},{"_id":"source/img/image-20231009232548604.png","path":"img/image-20231009232548604.png","modified":0,"renderable":0},{"_id":"source/img/image-20231010000535617.png","path":"img/image-20231010000535617.png","modified":0,"renderable":0},{"_id":"source/img/image-20231010000541057.png","path":"img/image-20231010000541057.png","modified":0,"renderable":0},{"_id":"source/img/image-20231010001511880.png","path":"img/image-20231010001511880.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012015303012.png","path":"img/image-20231012015303012.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012013204347.png","path":"img/image-20231012013204347.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012020112675.png","path":"img/image-20231012020112675.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012150414097.png","path":"img/image-20231012150414097.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012152241414.png","path":"img/image-20231012152241414.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012152302176.png","path":"img/image-20231012152302176.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012152314404.png","path":"img/image-20231012152314404.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012175222772.png","path":"img/image-20231012175222772.png","modified":0,"renderable":0},{"_id":"source/img/image-20231012175230820.png","path":"img/image-20231012175230820.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013020910459.png","path":"img/image-20231013020910459.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013020924815.png","path":"img/image-20231013020924815.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013021007971.png","path":"img/image-20231013021007971.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013021122908.png","path":"img/image-20231013021122908.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013224528836.png","path":"img/image-20231013224528836.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013224552169.png","path":"img/image-20231013224552169.png","modified":0,"renderable":0},{"_id":"source/img/image-20231013230802520.png","path":"img/image-20231013230802520.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014014917998.png","path":"img/image-20231014014917998.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020144155.png","path":"img/image-20231014020144155.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020042107.png","path":"img/image-20231014020042107.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020854920.png","path":"img/image-20231014020854920.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020213977.png","path":"img/image-20231014020213977.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020902573.png","path":"img/image-20231014020902573.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014020900669.png","path":"img/image-20231014020900669.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014022802984.png","path":"img/image-20231014022802984.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014034455018.png","path":"img/image-20231014034455018.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014034148547.png","path":"img/image-20231014034148547.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014040059430.png","path":"img/image-20231014040059430.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014040254573.png","path":"img/image-20231014040254573.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014054509641.png","path":"img/image-20231014054509641.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014054102698.png","path":"img/image-20231014054102698.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014054531765.png","path":"img/image-20231014054531765.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014034510599.png","path":"img/image-20231014034510599.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014054559197.png","path":"img/image-20231014054559197.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014054644739.png","path":"img/image-20231014054644739.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014055926821.png","path":"img/image-20231014055926821.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014060539030.png","path":"img/image-20231014060539030.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014061221536.png","path":"img/image-20231014061221536.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014061610452.png","path":"img/image-20231014061610452.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014061837332.png","path":"img/image-20231014061837332.png","modified":0,"renderable":0},{"_id":"source/img/image-20231014061840143.png","path":"img/image-20231014061840143.png","modified":0,"renderable":0},{"_id":"source/code/Java/Lambda-learning/LambdaIntro.java","path":"code/Java/Lambda-learning/LambdaIntro.java","modified":0,"renderable":0},{"_id":"source/img/10e3ae0e119a2f9a0d1c11eb11a2e70.png","path":"img/10e3ae0e119a2f9a0d1c11eb11a2e70.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027162231482.png","path":"img/image-20231027162231482.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027162237249.png","path":"img/image-20231027162237249.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027162620326.png","path":"img/image-20231027162620326.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027163827325.png","path":"img/image-20231027163827325.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027163940779.png","path":"img/image-20231027163940779.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027163951597.png","path":"img/image-20231027163951597.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027164057157.png","path":"img/image-20231027164057157.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027164235285.png","path":"img/image-20231027164235285.png","modified":0,"renderable":0},{"_id":"source/img/image-20231027164242503.png","path":"img/image-20231027164242503.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028170811382.png","path":"img/image-20231028170811382.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028170857441.png","path":"img/image-20231028170857441.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028171351460.png","path":"img/image-20231028171351460.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028171533933.png","path":"img/image-20231028171533933.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028171737778.png","path":"img/image-20231028171737778.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028171839887.png","path":"img/image-20231028171839887.png","modified":0,"renderable":0},{"_id":"source/img/image-20231028171906760.png","path":"img/image-20231028171906760.png","modified":0,"renderable":0},{"_id":"source/svg/leetcode-svgrepo-com.svg","path":"svg/leetcode-svgrepo-com.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-aurora/source/static/css/d5346b99.css","path":"static/css/d5346b99.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/14c27e7f.js","path":"static/js/14c27e7f.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/3173cc68.js","path":"static/js/3173cc68.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/36e11c4e.js","path":"static/js/36e11c4e.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6192457a.js","path":"static/js/6192457a.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/66095462.js","path":"static/js/66095462.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6882e76f.js","path":"static/js/6882e76f.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6b5ea7c3.js","path":"static/js/6b5ea7c3.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/8a24213b.js","path":"static/js/8a24213b.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a4735ecc.js","path":"static/js/a4735ecc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a565698a.js","path":"static/js/a565698a.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/ac07fd23.js","path":"static/js/ac07fd23.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/d7132a0e.js","path":"static/js/d7132a0e.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/f22da37a.js","path":"static/js/f22da37a.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fce95c39.js","path":"static/js/fce95c39.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fe2d0558.js","path":"static/js/fe2d0558.js","modified":0,"renderable":1},{"_id":"source/img/app/image-20231109180024669.png","path":"img/app/image-20231109180024669.png","modified":0,"renderable":0},{"_id":"source/img/app/image-20231109180051771.png","path":"img/app/image-20231109180051771.png","modified":0,"renderable":0},{"_id":"source/img/app/image-20231109180125705.png","path":"img/app/image-20231109180125705.png","modified":0,"renderable":0},{"_id":"source/img/Jira/image-20231110013822136.png","path":"img/Jira/image-20231110013822136.png","modified":0,"renderable":0},{"_id":"source/img/Jira/image-20231110162340705.png","path":"img/Jira/image-20231110162340705.png","modified":0,"renderable":0},{"_id":"source/img/Jira/image-20231110162600768.png","path":"img/Jira/image-20231110162600768.png","modified":0,"renderable":0},{"_id":"source/img/2023-07-11-探索LCU/image-20231110232752929.png","path":"img/2023-07-11-探索LCU/image-20231110232752929.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"fba6132645e09819b02d5bb700700ebe3a3504c0","modified":1694680449058},{"_id":"source/_posts/Selenium学习.md","hash":"eeb50063b69ac8e651156996b629ef6147822611","modified":1699485086282},{"_id":"source/_posts/TestNG学习.md","hash":"2c31541701375d563d769da9f724328ceb1c3a69","modified":1699485086282},{"_id":"source/_posts/标签.md","hash":"bcde00fb16ea442bbc0e8b3343e3700882141e41","modified":1699485086285},{"_id":"source/_posts/Spring笔记.md","hash":"59a3beba9f36e2fdc2573c59fa1942f352d6eda8","modified":1699485086282},{"_id":"source/_posts/多线程.md","hash":"62a5387293ac8fbd2dbdab7b5d7f552cc611879c","modified":1699485086282},{"_id":"source/_posts/连接阿里云数据库问题.md","hash":"4ed64c0cac373346e3ce43a5f0bcdad4cbc96bc2","modified":1699485086285},{"_id":"source/img/image-20230924004300712.png","hash":"425903924a446cd06c415d88457637a7c09e65bb","modified":1695530580722},{"_id":"source/img/image-20230924004941048.png","hash":"5a1867345b8c546bc527012d9d23deff0eeccddc","modified":1695530981049},{"_id":"source/img/image-20230924004955141.png","hash":"cbaadbd947ab9c20f98a3c0e6f914c98a709e447","modified":1695530995146},{"_id":"source/cret/googleec7ecf6065ae0891.html","hash":"e8bdc0d6a7c8e54565f1de763946bc317861545b","modified":1694670646202},{"_id":"source/img/image-20230924004606568.png","hash":"8c06bef8aea368b94c744ba5f0e3d5082837407d","modified":1695530766578},{"_id":"source/img/image-20230924005037622.png","hash":"9dd51c77db7f8d4a9d7fdc16f7bc5e5707226c58","modified":1695531037629},{"_id":"source/img/image-20230926224301341.png","hash":"d7a1f3b4d35229ccd089aab61db6310876d01b70","modified":1695782581357},{"_id":"source/img/image-20230927033247981.png","hash":"902550baa9d440b3cc6f167f2f2c84259f8fe02d","modified":1695799967989},{"_id":"source/img/image-20230928082013863.png","hash":"5292c71f34a4ce1070bc12c94738bfd10431bbb9","modified":1695903613867},{"_id":"source/img/image-20230928082117273.png","hash":"f6bfae2b169a0e837f4c02fae3b3b045d787d91b","modified":1695903677280},{"_id":"source/img/image-20230928082103488.png","hash":"1cb02bb714c03b1aec59beb66bf74cdbe86ff45b","modified":1695903663500},{"_id":"source/img/image-20230924004452513.png","hash":"f9e447252ab63f7a1c17435f1f3e423d4a3c87ab","modified":1695530692538},{"_id":"source/img/image-20230928213734939.png","hash":"89597958cd9852e6d5ac9b9c76b96e865e2da51a","modified":1695951454969},{"_id":"source/img/image-20230928213416192.png","hash":"1f13cce4a3ebdff766043d5d39afca6143b67d3f","modified":1695951256215},{"_id":"source/img/image-20230924203236506.png","hash":"cd469e818ecd4a04e96e96e3c64d8a40836eeb5f","modified":1695601956531},{"_id":"source/img/image-20230928213811991.png","hash":"6c333fca1f3b8ec6981d9c7c3895bdc382a55641","modified":1695951492023},{"_id":"source/img/image-20230927033542151.png","hash":"b15e170bf14fda385da84788c1133b3c1d7b7949","modified":1695800142171},{"_id":"node_modules/hexo-theme-aurora/package.json","hash":"c35a0038f242e76de4928275fa908336a37343f5","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/layout/index.ejs","hash":"2d65963b01de55c922399bb0029838bebd79a212","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1694676690156},{"_id":"node_modules/hexo-theme-aurora/LICENSE","hash":"21cf269018b0cf04e1126b6b9b1a5e6af7c5e61f","modified":1694676689936},{"_id":"node_modules/hexo-theme-aurora/public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1694676690138},{"_id":"node_modules/hexo-theme-aurora/README.md","hash":"8b5aea1bd91a6428040ec154ef313d20129fd1ce","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1694676690345},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1694676690351},{"_id":"node_modules/hexo-theme-aurora/public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1694676690353},{"_id":"node_modules/hexo-theme-aurora/source/static/css/882f9706.css","hash":"156eb90b06b5f6f6f0bf24973874ecd85906f8fd","modified":1694676690011},{"_id":"node_modules/hexo-theme-aurora/source/static/886a749e.css","hash":"46ef385b52d11142f603d0916042be66e4e04b46","modified":1694676690046},{"_id":"node_modules/hexo-theme-aurora/source/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1694676690355},{"_id":"node_modules/hexo-theme-aurora/source/static/css/8e0e69c4.css","hash":"5e2ac4baf9923ea59d1dbddccb44a0e4ffbdc87f","modified":1694676690061},{"_id":"node_modules/hexo-theme-aurora/source/static/css/9a0271b0.css","hash":"140052b8339ae6633bfdb6544050ba97c72ee630","modified":1694676690073},{"_id":"node_modules/hexo-theme-aurora/source/static/js/01562d77.js","hash":"62cafc7c6b6554443af6ef79f7d4d74e20a4aac7","modified":1694676690198},{"_id":"node_modules/hexo-theme-aurora/source/static/js/026832e2.js","hash":"eab17f05bb7d39b400dfa6a06837436d754e6619","modified":1694676690207},{"_id":"node_modules/hexo-theme-aurora/source/static/js/08fc4ca4.js","hash":"0437cf9b72f6e33d78235ef91c4f80f714815f30","modified":1694676690216},{"_id":"node_modules/hexo-theme-aurora/source/static/css/3e25f349.css","hash":"2859941dbaabcdf25bfb6379a0efaf6b02b45971","modified":1694676689966},{"_id":"node_modules/hexo-theme-aurora/source/static/js/2484385a.js","hash":"402e1c73610624d3d55cc6663ed57d4377bd4cf1","modified":1694676690236},{"_id":"node_modules/hexo-theme-aurora/source/static/css/6b275704.css","hash":"b04a2cd1a356e16cded5392bad271ce2f5b1c455","modified":1694676689987},{"_id":"node_modules/hexo-theme-aurora/source/static/js/44394174.js","hash":"9f51af855aea558db2dc741369b409df95123c48","modified":1694676690247},{"_id":"node_modules/hexo-theme-aurora/source/static/js/52b918da.js","hash":"fef49d1ca395ae8984ce07e5dca4ca6e0de837d4","modified":1694676690260},{"_id":"node_modules/hexo-theme-aurora/source/static/js/83d74a77.js","hash":"61880d8d2b83b4ac82ada76ed60d4a6324ca8811","modified":1694676690270},{"_id":"node_modules/hexo-theme-aurora/source/static/js/cdb02a0f.js","hash":"d8682dc2c5731ef692981167b3ae5e03f29c5021","modified":1694676690276},{"_id":"node_modules/hexo-theme-aurora/source/static/js/1c4198c2.js","hash":"c15ee1019e32d66c9eb193168cc93435e7c1b57f","modified":1694676690227},{"_id":"node_modules/hexo-theme-aurora/source/static/js/e2365b4a.js","hash":"b643c41978f901ac356521d28bf0d82074524f93","modified":1694676690324},{"_id":"node_modules/hexo-theme-aurora/source/static/js/ee3f65cf.js","hash":"cd12091624784098aa086bf1b79dc7b19cb0ee09","modified":1694676690335},{"_id":"node_modules/hexo-theme-aurora/source/static/js/e8b5ee4e.js","hash":"1f9f5c0085529456c3716cf6eff47f8d2c4879ae","modified":1694676690330},{"_id":"node_modules/hexo-theme-aurora/source/static/js/5dfcca50.js","hash":"4276707ec208160877d9015cb5ede7d384d36315","modified":1694676690266},{"_id":"node_modules/hexo-theme-aurora/source/static/css/d87308df.css","hash":"e0297f3749ffdd7ec98fb1d8040c835400c0ef91","modified":1694676690104},{"_id":"node_modules/hexo-theme-aurora/source/static/js/47f349ce.js","hash":"74cd4f580f10daf38f2bd78a6c6c2f979d6b6f94","modified":1694676690254},{"_id":"node_modules/hexo-theme-aurora/source/static/img/dccf965f.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1694676690179},{"_id":"source/img/icecream.jpg","hash":"76b0bf5dec62c2d38337ed8967bee30bf6a07c43","modified":1694683568604},{"_id":"source/img/rice.jpg","hash":"c3045f00d475ff1f4471724e2d0ef665699c7291","modified":1694683599422},{"_id":"source/img/cake.jpg","hash":"b52063ee0bbd81167558dba2cc0697ad9bf9e188","modified":1694683395330},{"_id":"node_modules/hexo-theme-aurora/source/static/js/dbf14a13.js","hash":"82a47b602524c1ff568af066cde4f130830f9a09","modified":1694676690320},{"_id":"public/api/posts/1.json","hash":"e75a3fc0e0da14e2367aa83d6b84761ed150859e","modified":1699916800951},{"_id":"public/api/archives/1.json","hash":"e75a3fc0e0da14e2367aa83d6b84761ed150859e","modified":1699916800951},{"_id":"public/api/articles/TestNG学习.json","hash":"ce033d4b288d427c762936005339ca4a66701c94","modified":1699485358636},{"_id":"public/api/articles/Selenium学习.json","hash":"5f475d8126c002756ecf022e9b4f8240d29fc9c7","modified":1699509988256},{"_id":"public/api/articles/连接阿里云数据库问题.json","hash":"0dd782cd22f0f23e597b39446f5dbb790eff4c5d","modified":1699916800951},{"_id":"public/api/articles/多线程.json","hash":"6adacd4783c56b059c8c893b49576ebc2bf0fbbd","modified":1699916800951},{"_id":"public/api/articles/Spring笔记.json","hash":"3b973f4460d8da26da5542bb9aa6a0a68dc9bdd3","modified":1699485358636},{"_id":"public/api/articles/标签.json","hash":"1a39ac2e763dcb5eb95642f2f7a64f3706ebb20c","modified":1699487338619},{"_id":"public/api/features.json","hash":"b00bedb6ae68ce8f4eab6de3220495735b0c3105","modified":1699916800951},{"_id":"public/api/authors/blog-author.json","hash":"43d1b855ae3e8a84f2a33fa61ce16b5761c0cacb","modified":1699916800951},{"_id":"public/api/categories.json","hash":"f127b4c0f221083cf16f9bce5c9043cc610500fa","modified":1699485358636},{"_id":"public/api/categories/软件测试.json","hash":"8cf0f4e8c6fa1fdf3217c7c90461142b61932d6c","modified":1699509988256},{"_id":"public/api/categories/Java基础.json","hash":"9d28d510da0eac28ce044cc7a98a0a9d9904eea5","modified":1699595933706},{"_id":"public/api/categories/后端开发.json","hash":"44a8eb96d9bf0493a6a93a15773445c7fd69c57e","modified":1699485358636},{"_id":"public/api/categories/数据库.json","hash":"9e38aab96b22909962c752cad7b52cabe1313ba9","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础.json","hash":"486f84333eb307a83ed9c01bfbbf2dae14b3e58c","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发.json","hash":"f394e610fb7149df559f5e3e4f925eab2a757477","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发.json","hash":"a7dfac45ac1642aa84c64bc3db4b4d670e955fcb","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试.json","hash":"00b1627277df6178514b223409342a42ffb703ef","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS.json","hash":"9adefea75cb2dc1768aeb89ea1140c7590f55b45","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库.json","hash":"dabe1322e4286ea6881f9f68ede0909d6659a726","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库/中间件.json","hash":"7f921a941e0d33f1d960496b630e7f5d4bebf9f4","modified":1699485358636},{"_id":"public/api/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库/中间件/算法.json","hash":"524b3c8df8b875c593b488392aef1793e532b830","modified":1699485358636},{"_id":"public/api/tags.json","hash":"ace2b76c3e0014b9b80586c6af33c2881dab8d55","modified":1699485358636},{"_id":"public/api/tags/Selenium.json","hash":"58d9a7a98537aac67e138e5ea84850f73f3b56d5","modified":1699485358636},{"_id":"public/api/tags/Java多线程.json","hash":"58edaa6bc7286d2daaefd73a61e78e60953ae954","modified":1699485358636},{"_id":"public/api/tags/Spring.json","hash":"b4902b1ab6c3d73471c6b105457eaacfb417f7eb","modified":1699485358636},{"_id":"public/api/tags/TestNG.json","hash":"1bdb6532c70c25c7cf137c4e288542d10ca1f300","modified":1699485358636},{"_id":"public/api/tags/SpringBoot.json","hash":"5720be4775d2a575b8ed095f29cc6c1842f11b84","modified":1699485358636},{"_id":"public/api/tags/Mybatis-Plus.json","hash":"f63d13ecbdc973d19daf4de563ff20f8fd9740dc","modified":1699485358636},{"_id":"public/api/tags/Mysql.json","hash":"710ba7d7cc50a5aee3938867b447dbffbb13cf90","modified":1699485358636},{"_id":"public/api/tags/Redis.json","hash":"b91e71bc1eab881d9d163fe82244e6c1b6adca67","modified":1699485358636},{"_id":"public/api/tags/Rabbitmq.json","hash":"760819c0b72b0e87dc674257e2a7f554ad0eb995","modified":1699485358636},{"_id":"public/api/tags/Kafka.json","hash":"14195518faea90ae53a3402ef2b82bd571857906","modified":1699485358636},{"_id":"public/api/tags/Docker.json","hash":"c2d6e28a3d1f1d51779fe008e455ff2b0b2bcd50","modified":1699485358636},{"_id":"public/api/tags/K8s.json","hash":"bb32fbdbf704fd8c45c67670cd3af1100efdcecb","modified":1699485358636},{"_id":"public/api/tags/xxl-job.json","hash":"f66fedb9370473631c7512d64f02d3de27c3d712","modified":1699485358636},{"_id":"public/api/tags/Javascript基础.json","hash":"2c1d53c4569d57f57c883aef102bb954ba6230e5","modified":1699485358636},{"_id":"public/api/tags/Vue2.json","hash":"97af24a3221226a8052332ba5442908042e53b54","modified":1699485358636},{"_id":"public/api/tags/React-js.json","hash":"7e20b0d4e8a924936265d747ce837c0820d86214","modified":1699485358636},{"_id":"public/api/tags/Electron-js.json","hash":"21653cbf25306c0da5ff4cd59c33973bafb23241","modified":1699485358636},{"_id":"public/api/tags/Flutter.json","hash":"08a055c90da1a487c8f6902500e01f496b3118f7","modified":1699485358636},{"_id":"public/api/pages/cret/googleec7ecf6065ae0891.html","hash":"6a767458185df3ed3561020408390ff9001396e1","modified":1699485358636},{"_id":"public/api/statistic.json","hash":"3f696f623c1d21cc73ca2450bc7569aa606f1693","modified":1699916800951},{"_id":"public/api/search.json","hash":"c040acd63e5d544b2e1122f6380831d5798e74e0","modified":1699916800951},{"_id":"public/api/site.json","hash":"8d74bf3644881438cac93f75e0fc4a3884a7aa51","modified":1699651806575},{"_id":"public/post/Selenium学习.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/TestNG学习.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/连接阿里云数据库问题.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/多线程.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/Spring笔记.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/标签.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/tags/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/archives/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/page/cret/googleec7ecf6065ae0891.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/tags/search/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/img/image-20230924004300712.png","hash":"425903924a446cd06c415d88457637a7c09e65bb","modified":1695962961673},{"_id":"public/CNAME","hash":"fba6132645e09819b02d5bb700700ebe3a3504c0","modified":1695962961673},{"_id":"public/img/image-20230924005037622.png","hash":"9dd51c77db7f8d4a9d7fdc16f7bc5e5707226c58","modified":1695962961673},{"_id":"public/img/image-20230924004606568.png","hash":"8c06bef8aea368b94c744ba5f0e3d5082837407d","modified":1695962961673},{"_id":"public/img/image-20230924004941048.png","hash":"5a1867345b8c546bc527012d9d23deff0eeccddc","modified":1695962961673},{"_id":"public/img/image-20230927033247981.png","hash":"902550baa9d440b3cc6f167f2f2c84259f8fe02d","modified":1695962961673},{"_id":"public/img/image-20230924004955141.png","hash":"cbaadbd947ab9c20f98a3c0e6f914c98a709e447","modified":1695962961673},{"_id":"public/img/image-20230928082103488.png","hash":"1cb02bb714c03b1aec59beb66bf74cdbe86ff45b","modified":1695962961673},{"_id":"public/img/image-20230926224301341.png","hash":"d7a1f3b4d35229ccd089aab61db6310876d01b70","modified":1695962961673},{"_id":"public/img/image-20230928082013863.png","hash":"5292c71f34a4ce1070bc12c94738bfd10431bbb9","modified":1695962961673},{"_id":"public/img/image-20230928082117273.png","hash":"f6bfae2b169a0e837f4c02fae3b3b045d787d91b","modified":1695962961673},{"_id":"public/favicon.ico","hash":"c39d3ad80489cffed0d3df82c8cb05a049ab39a3","modified":1695962961673},{"_id":"public/icons/favicon-32x32.png","hash":"9dbabf6f4d825da99dcb2e91583755ae8d3b3ff4","modified":1695962961673},{"_id":"public/icons/favicon-16x16.png","hash":"849cad2a5ae49fa54c20372f7a21ae95192bafcf","modified":1695962961673},{"_id":"public/static/img/dccf965f.jpg","hash":"1934ace0c6f2397d15729f9b08cc4d42e45bf437","modified":1695962961673},{"_id":"public/img/image-20230924004452513.png","hash":"f9e447252ab63f7a1c17435f1f3e423d4a3c87ab","modified":1695962961673},{"_id":"public/img/image-20230927033542151.png","hash":"b15e170bf14fda385da84788c1133b3c1d7b7949","modified":1695962961673},{"_id":"public/img/image-20230924203236506.png","hash":"cd469e818ecd4a04e96e96e3c64d8a40836eeb5f","modified":1695962961673},{"_id":"public/img/image-20230928213734939.png","hash":"89597958cd9852e6d5ac9b9c76b96e865e2da51a","modified":1695962961673},{"_id":"public/img/image-20230928213811991.png","hash":"6c333fca1f3b8ec6981d9c7c3895bdc382a55641","modified":1695962961673},{"_id":"public/img/image-20230928213416192.png","hash":"1f13cce4a3ebdff766043d5d39afca6143b67d3f","modified":1695962961673},{"_id":"public/static/css/882f9706.css","hash":"156eb90b06b5f6f6f0bf24973874ecd85906f8fd","modified":1695962961673},{"_id":"public/static/css/8e0e69c4.css","hash":"5e2ac4baf9923ea59d1dbddccb44a0e4ffbdc87f","modified":1695962961673},{"_id":"public/static/css/3e25f349.css","hash":"2859941dbaabcdf25bfb6379a0efaf6b02b45971","modified":1695962961673},{"_id":"public/static/css/6b275704.css","hash":"b04a2cd1a356e16cded5392bad271ce2f5b1c455","modified":1695962961673},{"_id":"public/static/886a749e.css","hash":"46ef385b52d11142f603d0916042be66e4e04b46","modified":1695962961673},{"_id":"public/static/css/9a0271b0.css","hash":"140052b8339ae6633bfdb6544050ba97c72ee630","modified":1695962961673},{"_id":"public/static/js/01562d77.js","hash":"62cafc7c6b6554443af6ef79f7d4d74e20a4aac7","modified":1695962961673},{"_id":"public/static/js/026832e2.js","hash":"eab17f05bb7d39b400dfa6a06837436d754e6619","modified":1695962961673},{"_id":"public/static/js/08fc4ca4.js","hash":"0437cf9b72f6e33d78235ef91c4f80f714815f30","modified":1695962961673},{"_id":"public/static/js/1c4198c2.js","hash":"c15ee1019e32d66c9eb193168cc93435e7c1b57f","modified":1695962961673},{"_id":"public/static/js/2484385a.js","hash":"402e1c73610624d3d55cc6663ed57d4377bd4cf1","modified":1695962961673},{"_id":"public/static/js/44394174.js","hash":"9f51af855aea558db2dc741369b409df95123c48","modified":1695962961673},{"_id":"public/static/js/52b918da.js","hash":"fef49d1ca395ae8984ce07e5dca4ca6e0de837d4","modified":1695962961673},{"_id":"public/static/js/47f349ce.js","hash":"74cd4f580f10daf38f2bd78a6c6c2f979d6b6f94","modified":1695962961673},{"_id":"public/static/js/5dfcca50.js","hash":"4276707ec208160877d9015cb5ede7d384d36315","modified":1695962961673},{"_id":"public/static/js/83d74a77.js","hash":"61880d8d2b83b4ac82ada76ed60d4a6324ca8811","modified":1695962961673},{"_id":"public/static/js/cdb02a0f.js","hash":"d8682dc2c5731ef692981167b3ae5e03f29c5021","modified":1695962961673},{"_id":"public/static/js/e2365b4a.js","hash":"b643c41978f901ac356521d28bf0d82074524f93","modified":1695962961673},{"_id":"public/static/js/e8b5ee4e.js","hash":"1f9f5c0085529456c3716cf6eff47f8d2c4879ae","modified":1695962961673},{"_id":"public/static/js/ee3f65cf.js","hash":"cd12091624784098aa086bf1b79dc7b19cb0ee09","modified":1695962961673},{"_id":"public/static/css/d87308df.css","hash":"e0297f3749ffdd7ec98fb1d8040c835400c0ef91","modified":1695962961673},{"_id":"public/static/js/dbf14a13.js","hash":"82a47b602524c1ff568af066cde4f130830f9a09","modified":1695962961673},{"_id":"public/img/icecream.jpg","hash":"76b0bf5dec62c2d38337ed8967bee30bf6a07c43","modified":1695962961673},{"_id":"public/img/rice.jpg","hash":"c3045f00d475ff1f4471724e2d0ef665699c7291","modified":1695962961673},{"_id":"public/img/cake.jpg","hash":"b52063ee0bbd81167558dba2cc0697ad9bf9e188","modified":1695962961673},{"_id":"public/categories/软件测试/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/后端开发/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/数据库/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库/中间件/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/categories/Java基础/Javascript基础/后端开发/前端开发/软件测试/OS/数据库/中间件/算法/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/live2dw/assets/mtn/00_idle.mtn","hash":"3686b7bfdb43f85f4fe1d94ed59379d2c4bee41d","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/01_happy.mtn","hash":"2020573671b39c81fbd784a8b873ebee019ca501","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/02_angry.mtn","hash":"f75e1f580c64695fbbf8ba3c5f49eafc7208411d","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/03_fear.mtn","hash":"b6cdb8fa48960b2a6e66d78ea992221e8108437b","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/04_surprise.mtn","hash":"4b911af06de9bc6f386aecd623851e5799edaa96","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/07_bye.mtn","hash":"6a3e90e8efb64cd5b187196625a3d8915efb21c8","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/05_fun.mtn","hash":"4b956c9c028dce753fafa1859404a136975786d4","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/06_love.mtn","hash":"c9f90cc2e2be55ac9c19cf6a962330dad3833fc1","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/08_sad.mtn","hash":"63647d9320bf3928d658e1275adbfaeba88748b7","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/10_yeah.mtn","hash":"58c4bda1339f41fa8a7e554509a7a871bad392b8","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/11_muscle.mtn","hash":"7d0e3466a996f8704e86913c723ac4b82f14ff47","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/09_yawn.mtn","hash":"e0e29a712b01be59ae8bba2e1a0d850e06260d20","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/14_%20sigh.mtn","hash":"80c4e4f539253d86a7aa5faae2c5e5a3a7b1adcc","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/15_joy.mtn","hash":"b76a24efc57e4c2cc4abf70c293b2e800029a20d","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/13_cry.mtn","hash":"27709b59d2e6cba73d69a67cadb8bf50413206a9","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/12_stagger.mtn","hash":"3f1a0b25cb1b9fb150f7a9ef37e8c9ba8d4e6ba1","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/19_walk.mtn","hash":"035516e8cdaa5b3c6e7524daca72294284a81126","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/16_menace.mtn","hash":"6edb6b114d53d7f93cff164992db475b0b6f09c3","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/18_no.mtn","hash":"9a18a2537bf6634da2bafd3a57d236de30c73b4e","modified":1695964955769},{"_id":"public/live2dw/assets/mtn/17_yes.mtn","hash":"a023cc93e55b3940f1a8690dcfa7ad1cfa534fad","modified":1695964955769},{"_id":"public/live2dw/assets/nico.pose.json","hash":"a8c949d20eebf1e716a495bf806b2eccff62a925","modified":1695964801224},{"_id":"public/live2dw/assets/nico.model.json","hash":"9f007936f4748e80a1da60ca078daed595acffee","modified":1695964801224},{"_id":"public/live2dw/assets/nico.physics.json","hash":"1db72a0413771e14d74de955af728224318e91d1","modified":1695964801224},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1695965099112},{"_id":"public/live2dw/assets/moc/nico.2048/texture_02.png","hash":"8e4a632c61506e3cc07d8ba704aa4ec2567fe11b","modified":1695964801224},{"_id":"public/live2dw/assets/moc/nico.2048/texture_00.png","hash":"413695bc00193e587b85c944df11d721192dd9a0","modified":1695964801224},{"_id":"public/live2dw/assets/moc/nico.2048/texture_01.png","hash":"9a19b242b9309624de1e43703b240c1c72bf2205","modified":1695964801224},{"_id":"public/live2dw/assets/mtn/20_sleep.mtn","hash":"914e4670825467e5e8d2f6983bd21c7190e57310","modified":1695964955769},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1695965099112},{"_id":"public/live2dw/assets/moc/nico.moc","hash":"371b0d972aca62a2b67d32398be091d792f0b3cb","modified":1695964801224},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1695965099112},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1695965099112},{"_id":"public/tags/Selenium/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Java多线程/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Spring/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/SpringBoot/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Mybatis-Plus/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Mysql/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Redis/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Rabbitmq/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Kafka/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/TestNG/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Docker/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/K8s/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/xxl-job/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Javascript基础/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Vue2/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/React-js/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Electron-js/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Flutter/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/live2dw/assets/exp/f04.exp.json","hash":"19fdb5558be54a9ec6d882e2d1780a369bc66b62","modified":1695964992545},{"_id":"public/live2dw/assets/exp/f03.exp.json","hash":"b8f958f736acd4eb7433043fbae946487e872f5b","modified":1695964992545},{"_id":"public/live2dw/assets/exp/f02.exp.json","hash":"a5f786a8ebce6d2b14efcd4476179ed324c8def6","modified":1695964992545},{"_id":"public/live2dw/assets/exp/f05.exp.json","hash":"8fdbc6eabb1890bc5953f170f95e4404bd3d62b4","modified":1695964992545},{"_id":"public/live2dw/assets/izumi.model.json","hash":"3ba8caa98a3af7b09d7a79419a691f543a1e3ea4","modified":1695964891320},{"_id":"public/live2dw/assets/exp/f06.exp.json","hash":"b8ee09beda85aff415e6598ecd6573a238e15d18","modified":1695964992545},{"_id":"public/live2dw/assets/exp/f07.exp.json","hash":"bb8dc60fc59444fee419265e68216bdcc0282b0b","modified":1695964891320},{"_id":"public/live2dw/assets/exp/f01.exp.json","hash":"84073a497ddb6e56c6cfc244a0fb217ba473abf9","modified":1695964992545},{"_id":"public/live2dw/assets/izumi.physics.json","hash":"cee4a6e1c8ec3e1c2bfc8028ff49dc9c34c06258","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/idle_02.mtn","hash":"d130dd1d194f05b3eb5391289b0339999e37c3a6","modified":1695965032979},{"_id":"public/live2dw/assets/mtn/idle_04.mtn","hash":"80d4e53606b3268623b03d12a28570efdb5739ad","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/idle_03.mtn","hash":"c85916f8699673b0511fd00cd1953896879e0cc5","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/idle_01.mtn","hash":"3fac7f98ab71858018cbbf21b5a3ad99166d275b","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/izumi_02.mtn","hash":"90add71910fd83c1c66bfb73db6d6d4766c98dac","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_01.mtn","hash":"36286812dc692e00a0b69e71d7fe3c8a2b672281","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_03.mtn","hash":"fc7f8e01f8e7744cbd13a8fea44dda8270f21aeb","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_04.mtn","hash":"551b95d80d31ed4f06d19d99ccc4f795a8392ea3","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_07.mtn","hash":"e2f9e8cb428fa83251a45166d8f9acad570a47d9","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_06.mtn","hash":"c1a63e659fcc6d5b1b0eac7eaff60faf43e2cb28","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_10.mtn","hash":"244ae631fb963ed7619e5d63f189d947a2497eb2","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_09.mtn","hash":"97199471755394bed243a29b4cb8397518487296","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_05.mtn","hash":"dbfea56881f31a79bffb6d107e7b1fa867e2da0e","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_01.mp3","hash":"11dd394ab4d11d3a3c6d6a1a305ff3a1d1fed21d","modified":1695964891320},{"_id":"public/live2dw/assets/mtn/izumi_08.mtn","hash":"19fc90977a0ca30c18f4afae90d4c3ea27a9b094","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_02.mp3","hash":"d35189bae63cc6ef18d3a949c4a46dd5ed74c6b3","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_03.mp3","hash":"b3d6e98bc30eaf8ac0cf7ffe2f297742a819b380","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_04.mp3","hash":"7647fb1e8823bb48ee5f82dbeac35e3f61b74bef","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_05.mp3","hash":"05e44723c24b387a0eab37a0ab4120ef19ae317e","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_06.mp3","hash":"f39ee4b85ed9877100c028bf938a9a8fd0d2cb6b","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_07.mp3","hash":"0c13c0096d02ceb37b3bcce085206b5d6d8ae834","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_08.mp3","hash":"0b73b4f9216ee6b944a91b599c942d567a39fe0f","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_10.mp3","hash":"53013c1cc56296a3843d4c8e3f01fd67747b169b","modified":1695964891320},{"_id":"public/live2dw/assets/snd/izumi_09.mp3","hash":"f7bce48ee99bdad6fa187c484872eafce0b0e351","modified":1695964891320},{"_id":"public/live2dw/assets/moc/izumi_illust.moc","hash":"819e029e0d81ed64c59d47fc747026d4bbe637d6","modified":1695964891320},{"_id":"public/live2dw/assets/moc/izumi_illust.1024/texture_01.png","hash":"274627b4750bac66b29a9c19a939aca1655b1d27","modified":1695964891320},{"_id":"public/live2dw/assets/moc/izumi_illust.1024/texture_02.png","hash":"4b45fb19ee5b662678692132feae93119ff56d08","modified":1695964891320},{"_id":"public/live2dw/assets/moc/izumi_illust.1024/texture_03.png","hash":"84005d6e75ed9db0f531b6e5e0d6d541da796b04","modified":1695964891320},{"_id":"public/live2dw/assets/moc/izumi_illust.1024/texture_00.png","hash":"bfcecfa399b328ac15eba45f2b6b3b18d50f2daf","modified":1695964891320},{"_id":"public/live2dw/assets/nipsilon.model.json","hash":"271e40dfe9c04c8b5f5e4c6a9aa4f7ee6c65cff9","modified":1695964955769},{"_id":"public/live2dw/assets/nipsilon.physics.json","hash":"5e83e055f99be8c8752fdcad30f9ed043111b83b","modified":1695964955769},{"_id":"public/live2dw/assets/moc/nipsilon.2048/texture_01.png","hash":"413695bc00193e587b85c944df11d721192dd9a0","modified":1695964955769},{"_id":"public/live2dw/assets/moc/nipsilon.2048/texture_00.png","hash":"8ea2e684b826d4a8548b237ab86b3bb701ca8d5b","modified":1695964955769},{"_id":"public/live2dw/assets/nipsilon.pose.json","hash":"a8c949d20eebf1e716a495bf806b2eccff62a925","modified":1695964955769},{"_id":"public/live2dw/assets/moc/nipsilon.moc","hash":"77ea4fba30cd6f056d1175654a8c950523cdf37e","modified":1695964955769},{"_id":"public/live2dw/assets/moc/nipsilon.2048/texture_02.png","hash":"8052842f4b880ce16a01703a128d8881f63f8543","modified":1695964955769},{"_id":"public/live2dw/assets/hibiki.model.json","hash":"73bbc0004fc21039452f80dc6dc3c287723aedc4","modified":1695964992545},{"_id":"public/live2dw/assets/hibiki.physics.json","hash":"ba100c7a8c3fc777d05f41e3371d18c457febfa7","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/hibiki_02.mtn","hash":"985154bee77e2934afe74a45071f51e0aa1ac84d","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/hibiki_01.mtn","hash":"cd220b89c26e1267fd7ab8f7cfc714fcd4c3b5a3","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/hibiki_03.mtn","hash":"0b2e7cb2a32b70a629d9d21205863bb163d06d47","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/hibiki_04.mtn","hash":"6a753859998d7afa17f119f37c5765f0c10b7bca","modified":1695964992545},{"_id":"public/live2dw/assets/mtn/hibiki_05.mtn","hash":"67dc8d35f050e36d08010d55ddbfd06544fb7ad5","modified":1695964992545},{"_id":"public/live2dw/assets/snd/hibiki_01.mp3","hash":"2880911aa4a85958fe02e54b912fbf7e6a1896c6","modified":1695964992545},{"_id":"public/live2dw/assets/snd/hibiki_03.mp3","hash":"df05cb8288b17e1ad00ed66a731f1558db28cf9b","modified":1695964992545},{"_id":"public/live2dw/assets/snd/hibiki_02.mp3","hash":"75358d4c7ec03c4b1dc02ef60c716d94f031fe2f","modified":1695964992545},{"_id":"public/live2dw/assets/snd/hibiki_04.mp3","hash":"57d76906838b186bee2d47f768e54ac18e44d472","modified":1695964992545},{"_id":"public/live2dw/assets/moc/hibiki.moc","hash":"deff9b550df1e2dc47a57f1099e46de6737a0ec6","modified":1695964992545},{"_id":"public/live2dw/assets/snd/hibiki_05.mp3","hash":"e8788bb9e92467e21933ac2140114a21b9ad215a","modified":1695964992545},{"_id":"public/live2dw/assets/moc/hibiki.2048/texture_00.png","hash":"91349297cc411865cf5605a998b68a97fe67eec5","modified":1695964992545},{"_id":"public/live2dw/assets/haruto.model.json","hash":"76f915f7edbd9c47df0ca041dddb151c0c93a2bf","modified":1695965032979},{"_id":"public/live2dw/assets/haruto.physics.json","hash":"2fbf886979212357ba293bd35884f2cb5b26b6a6","modified":1695965032979},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"61d7d590d9feb71b32fd6bd142b59410d75bc1fa","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"a72b697a92a7cff40d15774b143b465b34cee5e6","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"efc99efdff39c93372cff0f6d62c4e748e1a5593","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"32c888667455a3ff6f1b04f910c1a5cc4de30af0","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"637e00442da4042cd4b0ed2cc62ffb1559881814","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"df10cc1d333c96da1296a4853c1ddbd44d8a11f3","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"d8c9410135c81604eba665b59808089808e0851a","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"9b95ef8548b979d1fca557c74f8d66fb15b34578","modified":1695965171679},{"_id":"public/live2dw/assets/moc/haruto.moc","hash":"57bec0b245b49ea941d61ba3dee671f20441afae","modified":1695965032979},{"_id":"public/live2dw/assets/moc/haruto.2048/texture_00.png","hash":"62b970aa1480a1c18bdc4e74e297f2a1b34ca9fa","modified":1695965032979},{"_id":"public/live2dw/assets/mtn/09.mtn","hash":"ecf1283b72e1c4b7e3a97343cd97726813f18790","modified":1695965171679},{"_id":"public/live2dw/assets/koharu.model.json","hash":"ceccdefd776b7c9475a29cff0842796e4f58b7e9","modified":1695965171679},{"_id":"public/live2dw/assets/koharu.physics.json","hash":"2fbf886979212357ba293bd35884f2cb5b26b6a6","modified":1695965171679},{"_id":"public/live2dw/assets/moc/koharu.moc","hash":"5eec3fba21444dd6f774b913510b5955e2c0605b","modified":1695965171679},{"_id":"public/live2dw/assets/mtn/idle.mtn","hash":"058d4628ab04bf42c279501ba4fa37116d384e41","modified":1695965171679},{"_id":"public/live2dw/assets/moc/koharu.2048/texture_00.png","hash":"0879b61b745084781722636bba9f278f31ce5fc1","modified":1695965171679},{"_id":"public/live2dw/assets/Gantzert_Felixander.model.json","hash":"d5caeb1c758088ff03bc190cd8dcee98e6e02392","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_00_idle.mtn","hash":"d383fc08986b4d1f746d71abbea6f7b5f54dcc95","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_01.mtn","hash":"91d2def2e00393fcedaaca36cd80340fa95a2d1b","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_02.mtn","hash":"9283c809509daf3f580dcb92bab14960b5a89283","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_05.mtn","hash":"40ad1e684108035c6478b76c9e4e1953104725da","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_04.mtn","hash":"50360a6572518b447af3315236659a576aa1b248","modified":1695965499667},{"_id":"public/live2dw/assets/mtn/A_03.mtn","hash":"afec07ed22acdf28a5c49b78c560e29c3c2cfaa0","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_04.png","hash":"2c63a9622a875fea1abcdb9ef437b64556090d22","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_03.png","hash":"80f11d03197912296cd27ce7f59f490336396309","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_06.png","hash":"e04b38575cb49bf538d98d0bcc642be4eaf89f73","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_05.png","hash":"e6b2987797dbcf113879024df919aa716ded9d4e","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_02.png","hash":"1c2cf2502769b3a359c121823f9ecdb114063288","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_00.png","hash":"ff5b30d94adfcca1e5b77a3b7d3d75d750707d83","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.2048/texture_01.png","hash":"da2a0785207727ba87a30ed6853dafd9978eb7b4","modified":1695965499667},{"_id":"public/live2dw/assets/moc/Gantzert_Felixander.moc","hash":"67d418af2db593b0b6f318e95f49d4370515c8f0","modified":1695965499667},{"_id":"source/_posts/测试理论.md","hash":"076b4f82330b3f78f54e8d13c51bdfd907f8f2e4","modified":1699485086285},{"_id":"source/img/image-20231005073508368.png","hash":"49b397a7cab10a77c372274c79aaf6ae72c452bd","modified":1696505708382},{"_id":"source/img/image-20231005092614348.png","hash":"a16bd2ca2e369c84ea38db1d744ca8eaf292af22","modified":1696512374370},{"_id":"source/img/image-20231005093309025.png","hash":"d8a9eb08183b3802e04d94f79be50d3d765fa9f8","modified":1696512789056},{"_id":"source/img/image-20231005121023638.png","hash":"1d31bb329c5fa072bb8e12cb9dbca1e3e3f0f0d9","modified":1696522223677},{"_id":"source/img/image-20231005092611718.png","hash":"a16bd2ca2e369c84ea38db1d744ca8eaf292af22","modified":1696512371740},{"_id":"source/img/image-20231005092540398.png","hash":"4d33e543a65a7d555282a70f1705308921834fd6","modified":1696512340421},{"_id":"source/doc/Test Learning/test-principle-all-in-one.xlsx","hash":"1ee6cf8b4de4bdabb549a65ced7563530b995a82","modified":1696725203572},{"_id":"source/img/image-20231008225001226.png","hash":"0abc2fc2c0a1b522fb604f2be3a1c79f33628b79","modified":1696819801266},{"_id":"source/img/image-20231008234542259.png","hash":"d87fe2f268daf3e82d9d194b33d0e90d282ea661","modified":1696823142301},{"_id":"source/img/image-20231009001757777.png","hash":"046183f963996fc392507a7fb35fcdfe128e9e20","modified":1696825077818},{"_id":"public/api/articles/测试理论.json","hash":"7ac059c1581a6c10263015b6ae4c79e0156d9f49","modified":1699595933706},{"_id":"public/api/tags/软件测试.json","hash":"2b74ce8288fb7d9f5b799880992149f500c0e897","modified":1699509988256},{"_id":"public/post/测试理论.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/img/image-20231005073508368.png","hash":"49b397a7cab10a77c372274c79aaf6ae72c452bd","modified":1696826599298},{"_id":"public/img/image-20231005092540398.png","hash":"4d33e543a65a7d555282a70f1705308921834fd6","modified":1696826599298},{"_id":"public/img/image-20231005092611718.png","hash":"a16bd2ca2e369c84ea38db1d744ca8eaf292af22","modified":1696826599298},{"_id":"public/img/image-20231005092614348.png","hash":"a16bd2ca2e369c84ea38db1d744ca8eaf292af22","modified":1696826599298},{"_id":"public/img/image-20231005121023638.png","hash":"1d31bb329c5fa072bb8e12cb9dbca1e3e3f0f0d9","modified":1696826599298},{"_id":"public/doc/Test Learning/test-principle-all-in-one.xlsx","hash":"1ee6cf8b4de4bdabb549a65ced7563530b995a82","modified":1696826599298},{"_id":"public/img/image-20231005093309025.png","hash":"d8a9eb08183b3802e04d94f79be50d3d765fa9f8","modified":1696826599298},{"_id":"public/img/image-20231008234542259.png","hash":"d87fe2f268daf3e82d9d194b33d0e90d282ea661","modified":1696826599298},{"_id":"public/img/image-20231008225001226.png","hash":"0abc2fc2c0a1b522fb604f2be3a1c79f33628b79","modified":1696826599298},{"_id":"public/img/image-20231009001757777.png","hash":"046183f963996fc392507a7fb35fcdfe128e9e20","modified":1696826599298},{"_id":"source/img/image-20231009225919124.png","hash":"caff83753cc669591d41c88d8786c94250d1cd5f","modified":1696906759143},{"_id":"source/img/image-20231009213702116.png","hash":"de7c2566a1fe927cc5008b0317a41f860745a169","modified":1696901822142},{"_id":"source/img/image-20231009213653825.png","hash":"61c527e8b7ec9d979852eaeab80210d889344c99","modified":1696901813856},{"_id":"source/img/image-20231009232548604.png","hash":"90ac8570d3f655c6fcf7bc428c69d10d74db54cb","modified":1696908348630},{"_id":"source/img/image-20231009143738559.png","hash":"d0dc7a2b9656153c09a31c3cd727873a654dbc24","modified":1696876658629},{"_id":"source/img/image-20231009213724620.png","hash":"77b6e403b5b44886c948ab5ccd026828dd22aa6d","modified":1696901844666},{"_id":"public/img/image-20231009225919124.png","hash":"caff83753cc669591d41c88d8786c94250d1cd5f","modified":1696910111448},{"_id":"public/img/image-20231009213653825.png","hash":"61c527e8b7ec9d979852eaeab80210d889344c99","modified":1696910111448},{"_id":"public/img/image-20231009213702116.png","hash":"de7c2566a1fe927cc5008b0317a41f860745a169","modified":1696910111448},{"_id":"public/img/image-20231009232548604.png","hash":"90ac8570d3f655c6fcf7bc428c69d10d74db54cb","modified":1696910111448},{"_id":"public/img/image-20231009143738559.png","hash":"d0dc7a2b9656153c09a31c3cd727873a654dbc24","modified":1696910111448},{"_id":"public/img/image-20231009213724620.png","hash":"77b6e403b5b44886c948ab5ccd026828dd22aa6d","modified":1696910111448},{"_id":"source/img/image-20231010000535617.png","hash":"b431de0c7904d9bbccba06d0b349694aab9edd64","modified":1696910735643},{"_id":"source/img/image-20231010000541057.png","hash":"2c44f6d16d0f10e97b6532c16ec5c384f0bf5233","modified":1696910741074},{"_id":"source/img/image-20231010001511880.png","hash":"ebdc7bafe7cf27455b36bf360ea1607d6d8fc4c0","modified":1696911311897},{"_id":"public/img/image-20231010001511880.png","hash":"ebdc7bafe7cf27455b36bf360ea1607d6d8fc4c0","modified":1696912840709},{"_id":"public/img/image-20231010000541057.png","hash":"2c44f6d16d0f10e97b6532c16ec5c384f0bf5233","modified":1696912840709},{"_id":"public/img/image-20231010000535617.png","hash":"b431de0c7904d9bbccba06d0b349694aab9edd64","modified":1696912840709},{"_id":"source/_posts/Lambda表达式.md","hash":"be36c2802c19df9fe1cb97d9cdaa66af7e3820e4","modified":1699485086282},{"_id":"source/_posts/接口自动化.md","hash":"294a79fbaf13341fe057b139cf847e9c022a35ab","modified":1699485086282},{"_id":"source/img/image-20231012015303012.png","hash":"10830c04749f2aa58b498d660513934c18449809","modified":1697089983037},{"_id":"source/img/image-20231012013204347.png","hash":"0a31238aabaed67c79e99ce39772b4edf7e5f26b","modified":1697088724365},{"_id":"source/img/image-20231012020112675.png","hash":"bccf044e629f4ef6a3a8b1e929ae635c98d77bd8","modified":1697090472733},{"_id":"public/api/articles/接口自动化.json","hash":"08567312dd4dc34ed2181710188fb4563f6005c4","modified":1699485358636},{"_id":"public/api/articles/Lambda表达式.json","hash":"76c19c5feed98012acbe616f58760231de936703","modified":1699595933706},{"_id":"public/api/tags/Java基础.json","hash":"028e505662f9c281e58a768a358deabde591c5f8","modified":1699595933706},{"_id":"public/api/tags/Java.json","hash":"fa58a6e9367573ea6b737b0c93a8d4174de74554","modified":1699595933706},{"_id":"public/api/tags/Lambda表达式.json","hash":"f60af03fa81932b0ae9044329260e016eaf8d636","modified":1699595933706},{"_id":"public/post/接口自动化.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/Lambda表达式.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/img/image-20231012015303012.png","hash":"10830c04749f2aa58b498d660513934c18449809","modified":1697091799478},{"_id":"public/img/image-20231012013204347.png","hash":"0a31238aabaed67c79e99ce39772b4edf7e5f26b","modified":1697091799478},{"_id":"public/img/image-20231012020112675.png","hash":"bccf044e629f4ef6a3a8b1e929ae635c98d77bd8","modified":1697091799478},{"_id":"source/img/image-20231012150414097.png","hash":"3ce5b52332f4dff2367dc3b8331441e5c01fa51c","modified":1697137454135},{"_id":"source/img/image-20231014020144155.png","hash":"c294e0ea52dd045a13bab64930f08d0007fd6960","modified":1697263304166},{"_id":"source/img/image-20231014020042107.png","hash":"1b256a964a72e929a186ea3ade51379f1c456c27","modified":1697263242111},{"_id":"source/img/image-20231014020213977.png","hash":"05f43d5fe937c750f949cac6144bed4e8e0f6959","modified":1697263333990},{"_id":"source/img/image-20231014040254573.png","hash":"6a7ac40a42f680e45f30fbc30c05469695f24bca","modified":1697270574575},{"_id":"source/img/image-20231014034510599.png","hash":"aeb448b2315ddb70341073e6765b853d2de8fea1","modified":1697269510610},{"_id":"source/img/image-20231014061221536.png","hash":"417ee1ef831c7ebcd837a07636600bdc16777d8a","modified":1697278341549},{"_id":"source/img/image-20231014061840143.png","hash":"3f1994ad8b76948c0a9d45afedc51297fd3afddd","modified":1697278720154},{"_id":"source/img/image-20231014061837332.png","hash":"3f1994ad8b76948c0a9d45afedc51297fd3afddd","modified":1697278717343},{"_id":"source/_posts/image.png","hash":"230df0758e9dceb2c5d652ba9445846031654bb7","modified":1697137418616},{"_id":"source/code/Java/Lambda-learning/LambdaIntro.java","hash":"66dfcda382afe1c4ce3a5261f67e638fbad1b0f4","modified":1699485086285},{"_id":"source/img/image-20231013020910459.png","hash":"24570579994bd4f8af3818c98e542e239e6321be","modified":1697177350464},{"_id":"source/img/image-20231012152241414.png","hash":"746005fe0ade6836047c67ae64f4bfee7b01a4e3","modified":1697138561427},{"_id":"source/doc/Test Learning/api-test/登录/parameterization.json","hash":"b15741ddc4e656dc03bc318480f2e684374dd25d","modified":1699485086285},{"_id":"source/img/image-20231012175222772.png","hash":"e83217ef5989ed39a381632d5682073af22cd075","modified":1697147542812},{"_id":"source/img/image-20231013020924815.png","hash":"f01a9c810ca636411d46b523d796453173c70e26","modified":1697177364847},{"_id":"source/img/image-20231012175230820.png","hash":"382e740383ab238471d2d0e944aca77964064f43","modified":1697147550863},{"_id":"source/img/image-20231012152314404.png","hash":"68f969d319d011dc588ccab96f8c0fb4c060eadd","modified":1697138594447},{"_id":"source/img/image-20231013021007971.png","hash":"5dd34473d92641377d5b6a228803cedeffdbbdea","modified":1697177408012},{"_id":"source/img/image-20231013021122908.png","hash":"2b14e74b7ee2806f550eab5ff18e749994f474a0","modified":1697177482949},{"_id":"source/img/image-20231013224552169.png","hash":"782ec57441cb6de18048e80cf7f390819b8470e7","modified":1697251552199},{"_id":"source/img/image-20231013224528836.png","hash":"dd980dce65eeea63d5dc099b02aea842db30eedb","modified":1697251528859},{"_id":"source/img/image-20231013230802520.png","hash":"8f7a981ae3431a0fdf4ed37396d99ee11f1fb08a","modified":1697252882558},{"_id":"source/img/image-20231014054509641.png","hash":"32f4a8345f9c17a46804abb057a12f5d2d22a426","modified":1697276709661},{"_id":"source/img/image-20231012152302176.png","hash":"c0f03e6b5463e14061b1ad7e17c796825d3135f3","modified":1697138582219},{"_id":"source/img/image-20231014020854920.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697263734960},{"_id":"source/img/image-20231014020900669.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697263740708},{"_id":"source/img/image-20231014020902573.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697263742613},{"_id":"source/img/image-20231014022802984.png","hash":"6ce95691a6c1212e51377f7ca09fda2bc5854fce","modified":1697264883026},{"_id":"source/img/image-20231014034148547.png","hash":"3e29380330440a24facfe3d0ce1a00436e34599c","modified":1697269308625},{"_id":"source/img/image-20231014055926821.png","hash":"6f6d08bcf691280adab9141a50b72bede5cc89b1","modified":1697277566850},{"_id":"source/img/image-20231014014917998.png","hash":"461a3a5cfe6ec222577853c565cd79d49b3ee423","modified":1697262558029},{"_id":"source/img/image-20231014034455018.png","hash":"4a136b4bec980fef49b7c750fac08cb7d1fa8280","modified":1697269495101},{"_id":"source/img/image-20231014054559197.png","hash":"cee2057ec0170ec33cb5e032154504e52ac99b8f","modified":1697276759237},{"_id":"source/img/image-20231014061610452.png","hash":"79bf48d2e18bbc038b1a9bbcb65bd5f900e96fef","modified":1697278570506},{"_id":"source/img/image-20231014040059430.png","hash":"af861d38e2bde180aa5d9491beb038a220f834da","modified":1697270459498},{"_id":"source/img/image-20231014054531765.png","hash":"8c045ec19bb6c2bb465245dd1e244b58252f4e1f","modified":1697276731817},{"_id":"source/img/image-20231014054102698.png","hash":"4a83e9713c15306a612d70931cae30bd48e0ec9d","modified":1697276462775},{"_id":"source/img/image-20231014060539030.png","hash":"c384fbcc02967e330b627c2a4496715bb963a78e","modified":1697277939093},{"_id":"source/img/image-20231014054644739.png","hash":"dacdca7a3fa4db9bfb1de1f30c13706c22f57aef","modified":1697276804833},{"_id":"public/api/pages/doc/Test Learning/api-test/登录/parameterization.json","hash":"8df3301169e40d3ff2660670da4a2ab7f54c41b0","modified":1699485358636},{"_id":"public/page/doc/Test Learning/api-test/登录/parameterization.json","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/img/image-20231012150414097.png","hash":"3ce5b52332f4dff2367dc3b8331441e5c01fa51c","modified":1697279033400},{"_id":"public/img/image-20231012152241414.png","hash":"746005fe0ade6836047c67ae64f4bfee7b01a4e3","modified":1697279033400},{"_id":"public/img/image-20231013020910459.png","hash":"24570579994bd4f8af3818c98e542e239e6321be","modified":1697279033400},{"_id":"public/img/image-20231014020144155.png","hash":"c294e0ea52dd045a13bab64930f08d0007fd6960","modified":1697279033400},{"_id":"public/img/image-20231014020042107.png","hash":"1b256a964a72e929a186ea3ade51379f1c456c27","modified":1697279033400},{"_id":"public/img/image-20231014020213977.png","hash":"05f43d5fe937c750f949cac6144bed4e8e0f6959","modified":1697279033400},{"_id":"public/img/image-20231014040254573.png","hash":"6a7ac40a42f680e45f30fbc30c05469695f24bca","modified":1697279033400},{"_id":"public/img/image-20231014034510599.png","hash":"aeb448b2315ddb70341073e6765b853d2de8fea1","modified":1697279033400},{"_id":"public/img/image-20231014061221536.png","hash":"417ee1ef831c7ebcd837a07636600bdc16777d8a","modified":1697279033400},{"_id":"public/img/image-20231014061837332.png","hash":"3f1994ad8b76948c0a9d45afedc51297fd3afddd","modified":1697279033400},{"_id":"public/img/image-20231014061840143.png","hash":"3f1994ad8b76948c0a9d45afedc51297fd3afddd","modified":1697279033400},{"_id":"public/code/Java/Lambda-learning/LambdaIntro.java","hash":"66dfcda382afe1c4ce3a5261f67e638fbad1b0f4","modified":1699485207008},{"_id":"public/img/image-20231012152314404.png","hash":"68f969d319d011dc588ccab96f8c0fb4c060eadd","modified":1697279033400},{"_id":"public/img/image-20231012175222772.png","hash":"e83217ef5989ed39a381632d5682073af22cd075","modified":1697279033400},{"_id":"public/img/image-20231012175230820.png","hash":"382e740383ab238471d2d0e944aca77964064f43","modified":1697279033400},{"_id":"public/img/image-20231013020924815.png","hash":"f01a9c810ca636411d46b523d796453173c70e26","modified":1697279033400},{"_id":"public/img/image-20231013021122908.png","hash":"2b14e74b7ee2806f550eab5ff18e749994f474a0","modified":1697279033400},{"_id":"public/img/image-20231013021007971.png","hash":"5dd34473d92641377d5b6a228803cedeffdbbdea","modified":1697279033400},{"_id":"public/img/image-20231013224528836.png","hash":"dd980dce65eeea63d5dc099b02aea842db30eedb","modified":1697279033400},{"_id":"public/img/image-20231013224552169.png","hash":"782ec57441cb6de18048e80cf7f390819b8470e7","modified":1697279033400},{"_id":"public/img/image-20231013230802520.png","hash":"8f7a981ae3431a0fdf4ed37396d99ee11f1fb08a","modified":1697279033400},{"_id":"public/img/image-20231014054509641.png","hash":"32f4a8345f9c17a46804abb057a12f5d2d22a426","modified":1697279033400},{"_id":"public/img/image-20231012152302176.png","hash":"c0f03e6b5463e14061b1ad7e17c796825d3135f3","modified":1697279033400},{"_id":"public/img/image-20231014020854920.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697279033400},{"_id":"public/img/image-20231014020902573.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697279033400},{"_id":"public/img/image-20231014020900669.png","hash":"940e3f27275b7537155d7dfd24f2bad4459b664d","modified":1697279033400},{"_id":"public/img/image-20231014034148547.png","hash":"3e29380330440a24facfe3d0ce1a00436e34599c","modified":1697279033400},{"_id":"public/img/image-20231014022802984.png","hash":"6ce95691a6c1212e51377f7ca09fda2bc5854fce","modified":1697279033400},{"_id":"public/img/image-20231014055926821.png","hash":"6f6d08bcf691280adab9141a50b72bede5cc89b1","modified":1697279033400},{"_id":"public/img/image-20231014014917998.png","hash":"461a3a5cfe6ec222577853c565cd79d49b3ee423","modified":1697279033400},{"_id":"public/img/image-20231014034455018.png","hash":"4a136b4bec980fef49b7c750fac08cb7d1fa8280","modified":1697279033400},{"_id":"public/img/image-20231014054559197.png","hash":"cee2057ec0170ec33cb5e032154504e52ac99b8f","modified":1697279033400},{"_id":"public/img/image-20231014061610452.png","hash":"79bf48d2e18bbc038b1a9bbcb65bd5f900e96fef","modified":1697279033400},{"_id":"public/img/image-20231014040059430.png","hash":"af861d38e2bde180aa5d9491beb038a220f834da","modified":1697279033400},{"_id":"public/img/image-20231014054531765.png","hash":"8c045ec19bb6c2bb465245dd1e244b58252f4e1f","modified":1697279033400},{"_id":"public/img/image-20231014054102698.png","hash":"4a83e9713c15306a612d70931cae30bd48e0ec9d","modified":1697279033400},{"_id":"public/img/image-20231014060539030.png","hash":"c384fbcc02967e330b627c2a4496715bb963a78e","modified":1697279033400},{"_id":"public/img/image-20231014054644739.png","hash":"dacdca7a3fa4db9bfb1de1f30c13706c22f57aef","modified":1697279033400},{"_id":"source/_posts/OSD.md","hash":"7eb432ac6c670d704a7c6e53b3a803c08fd4ab22","modified":1699485086282},{"_id":"source/img/10e3ae0e119a2f9a0d1c11eb11a2e70.png","hash":"40c6ba0ee22ce9c6880c250ea31475b9491d0c9f","modified":1698277903874},{"_id":"source/_posts/SQL 一些注意点.md","hash":"85983342e3ed02ed293069a69bcba34f8ef5ceed","modified":1699487052474},{"_id":"source/_posts/vscode一些小问题.md","hash":"e4e3e17f525eb1ecfc7865627da47f55056e5e3f","modified":1699487331831},{"_id":"source/img/image-20231027162231482.png","hash":"383b46b1211bc64c4596463ea62f948f13692ff3","modified":1698438151486},{"_id":"source/img/image-20231027162237249.png","hash":"62c7627fdb3f2d582ed4a6e1848dda9f04d65246","modified":1698438157250},{"_id":"source/img/image-20231027162620326.png","hash":"e0b972c47f743ec5d28cec8321b85b2aa7f10610","modified":1698438380337},{"_id":"source/img/image-20231027163940779.png","hash":"6d93afc5802991c361cae958e0a80c09ba0edbef","modified":1698439180782},{"_id":"source/img/image-20231027164057157.png","hash":"54ce6a196251ce6813ed65d3619c775f1a4f8dbc","modified":1698439257160},{"_id":"source/img/image-20231027164235285.png","hash":"4f6f192b614c905b948f7704a78d7c2b7b70c06a","modified":1698439355293},{"_id":"source/img/image-20231027163951597.png","hash":"71b4e2c2540f8111d01a6360d0dff6830899ca7d","modified":1698439191601},{"_id":"source/img/image-20231027164242503.png","hash":"4f6f192b614c905b948f7704a78d7c2b7b70c06a","modified":1698439362512},{"_id":"source/img/image-20231028170811382.png","hash":"912757978294fcaf459e7e66ec631983348b9adb","modified":1698527291387},{"_id":"source/img/image-20231028170857441.png","hash":"e2a353b473274ba834e4050cccc57c47d5190ab4","modified":1698527337446},{"_id":"source/img/image-20231028171533933.png","hash":"189079b310b542a7b80a36b0b842b448c04332d7","modified":1698527733954},{"_id":"source/svg/leetcode-svgrepo-com.svg","hash":"c5e9370ce6289550693eb03f05bdbe78844390f3","modified":1698645441679},{"_id":"source/img/image-20231028171737778.png","hash":"6272e91352b199676e9101b409e0662564fbebff","modified":1698527857785},{"_id":"source/img/image-20231028171839887.png","hash":"cce98637c635d78fe69cf7bfd390c792493a5b46","modified":1698527919899},{"_id":"source/img/image-20231028171906760.png","hash":"6e0ac752ee0c698ed2b37acf427c085bd12ccef4","modified":1698527946767},{"_id":"source/img/image-20231027163827325.png","hash":"c69655f2f152e4218825bc4cddcd5b94d29c7c12","modified":1698439107376},{"_id":"source/img/image-20231028171351460.png","hash":"de467add3158b7baa60a30592b9a8763e1abe8cf","modified":1698527631489},{"_id":"public/api/articles/OSD.json","hash":"4ed9aeb7d6f5f23d48941ed2f1322136e1703e05","modified":1699916800951},{"_id":"public/api/articles/SQL 一些注意点.json","hash":"a37379194bd9eb0b09db538a1883fd64f4465d07","modified":1699487338619},{"_id":"public/api/articles/vscode一些小问题.json","hash":"f1e47c71d5243b2a9fe6434924d94b1e0a092397","modified":1699487338619},{"_id":"public/post/OSD.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/SQL 一些注意点.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/post/vscode一些小问题.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/page/2/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699485358636},{"_id":"public/img/10e3ae0e119a2f9a0d1c11eb11a2e70.png","hash":"40c6ba0ee22ce9c6880c250ea31475b9491d0c9f","modified":1698645847816},{"_id":"public/img/image-20231027162231482.png","hash":"383b46b1211bc64c4596463ea62f948f13692ff3","modified":1698645847816},{"_id":"public/img/image-20231027163940779.png","hash":"6d93afc5802991c361cae958e0a80c09ba0edbef","modified":1698645847816},{"_id":"public/img/image-20231027162237249.png","hash":"62c7627fdb3f2d582ed4a6e1848dda9f04d65246","modified":1698645847816},{"_id":"public/img/image-20231027162620326.png","hash":"e0b972c47f743ec5d28cec8321b85b2aa7f10610","modified":1698645847816},{"_id":"public/img/image-20231027163951597.png","hash":"71b4e2c2540f8111d01a6360d0dff6830899ca7d","modified":1698645847816},{"_id":"public/img/image-20231027164242503.png","hash":"4f6f192b614c905b948f7704a78d7c2b7b70c06a","modified":1698645847816},{"_id":"public/img/image-20231027164235285.png","hash":"4f6f192b614c905b948f7704a78d7c2b7b70c06a","modified":1698645847816},{"_id":"public/img/image-20231028170811382.png","hash":"912757978294fcaf459e7e66ec631983348b9adb","modified":1698645847816},{"_id":"public/img/image-20231028170857441.png","hash":"e2a353b473274ba834e4050cccc57c47d5190ab4","modified":1698645847816},{"_id":"public/img/image-20231028171533933.png","hash":"189079b310b542a7b80a36b0b842b448c04332d7","modified":1698645847816},{"_id":"public/img/image-20231028171737778.png","hash":"6272e91352b199676e9101b409e0662564fbebff","modified":1698645847816},{"_id":"public/img/image-20231028171839887.png","hash":"cce98637c635d78fe69cf7bfd390c792493a5b46","modified":1698645847816},{"_id":"public/img/image-20231028171906760.png","hash":"6e0ac752ee0c698ed2b37acf427c085bd12ccef4","modified":1698645847816},{"_id":"public/svg/leetcode-svgrepo-com.svg","hash":"c5e9370ce6289550693eb03f05bdbe78844390f3","modified":1698645847816},{"_id":"public/img/image-20231027164057157.png","hash":"54ce6a196251ce6813ed65d3619c775f1a4f8dbc","modified":1698645847816},{"_id":"public/img/image-20231027163827325.png","hash":"c69655f2f152e4218825bc4cddcd5b94d29c7c12","modified":1698645847816},{"_id":"public/img/image-20231028171351460.png","hash":"de467add3158b7baa60a30592b9a8763e1abe8cf","modified":1698645847816},{"_id":"public/tags/软件测试/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Java基础/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Java/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"public/tags/Lambda表达式/index.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951},{"_id":"source/_posts/OSD.pdf","hash":"475a5cdaa315899efe0051b744006bfc359aee52","modified":1698813412521},{"_id":"source/_posts/broken.txt","hash":"585f7d6186622d9ed18c588e2e1c8447f8448420","modified":1699485086282},{"_id":"public/doc/Test Learning/api-test/登录/parameterization.json","hash":"bf6b76472a8ce8e1029cac30fb8e3ef7ab96ac7b","modified":1699485207008},{"_id":"public/cret/googleec7ecf6065ae0891.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/page/2/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2022/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2022/09/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/page/2/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/02/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/03/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/09/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/10/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"public/archives/2023/11/index.html","hash":"3960125adef4480731cd003a47bcb89ee0a6d6b4","modified":1699485207008},{"_id":"node_modules/hexo-theme-aurora/source/static/js/3173cc68.js","hash":"9e80f2913c310b35a5aa1e34c23fc8780ab07dc3","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/36e11c4e.js","hash":"a65a6cd48caf309d84b71afb4ec04908bcdf0982","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6192457a.js","hash":"b915bbe2f59e41da1ffeb360f7fa391603fd8a14","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/66095462.js","hash":"0681446c7e5a6acbafa0732c880ef810f61f6ed9","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6882e76f.js","hash":"15708f336370cd732047a9259308dd2fb0d4b922","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/6b5ea7c3.js","hash":"569d179746ac384f6ebb6d625d83c13f066975d9","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/8a24213b.js","hash":"18cfce45bfd072f18e5db8b04029a7dfb3a4146b","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a4735ecc.js","hash":"5fd548128217bc41586ef614124056a3e3b8122f","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/a565698a.js","hash":"3c76e1cc627b5ad242007e047e139053114e750f","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/ac07fd23.js","hash":"96ac046e59c97dd02094cdfb56686d7c9dd42529","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/d7132a0e.js","hash":"e7c9669a2ccfc796598f1744bfcdb68e8f562bac","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/f22da37a.js","hash":"a12fc8e5143db0a0bb648f49c95c06144f1c472b","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fce95c39.js","hash":"e0ea45559a960c44345017936959b70b4f3c52d4","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/fe2d0558.js","hash":"b5374ef4cbd5d8a6e441ba59eb14fd88501b61b4","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/css/d5346b99.css","hash":"214a606da4fe89755b07f70a07b9f46d9af8dc01","modified":1699485335467},{"_id":"node_modules/hexo-theme-aurora/source/static/js/14c27e7f.js","hash":"eef41805e3017ef0df4d0c72ef1731e10e534379","modified":1699485335467},{"_id":"public/static/js/3173cc68.js","hash":"9e80f2913c310b35a5aa1e34c23fc8780ab07dc3","modified":1699485358636},{"_id":"public/static/js/36e11c4e.js","hash":"a65a6cd48caf309d84b71afb4ec04908bcdf0982","modified":1699485358636},{"_id":"public/static/js/6192457a.js","hash":"b915bbe2f59e41da1ffeb360f7fa391603fd8a14","modified":1699485358636},{"_id":"public/static/js/66095462.js","hash":"0681446c7e5a6acbafa0732c880ef810f61f6ed9","modified":1699485358636},{"_id":"public/static/js/6882e76f.js","hash":"15708f336370cd732047a9259308dd2fb0d4b922","modified":1699485358636},{"_id":"public/static/js/6b5ea7c3.js","hash":"569d179746ac384f6ebb6d625d83c13f066975d9","modified":1699485358636},{"_id":"public/static/js/a4735ecc.js","hash":"5fd548128217bc41586ef614124056a3e3b8122f","modified":1699485358636},{"_id":"public/static/js/8a24213b.js","hash":"18cfce45bfd072f18e5db8b04029a7dfb3a4146b","modified":1699485358636},{"_id":"public/static/js/ac07fd23.js","hash":"96ac046e59c97dd02094cdfb56686d7c9dd42529","modified":1699485358636},{"_id":"public/static/js/d7132a0e.js","hash":"e7c9669a2ccfc796598f1744bfcdb68e8f562bac","modified":1699485358636},{"_id":"public/static/js/f22da37a.js","hash":"a12fc8e5143db0a0bb648f49c95c06144f1c472b","modified":1699485358636},{"_id":"public/static/js/a565698a.js","hash":"3c76e1cc627b5ad242007e047e139053114e750f","modified":1699485358636},{"_id":"public/static/js/fce95c39.js","hash":"e0ea45559a960c44345017936959b70b4f3c52d4","modified":1699485358636},{"_id":"public/static/js/fe2d0558.js","hash":"b5374ef4cbd5d8a6e441ba59eb14fd88501b61b4","modified":1699485358636},{"_id":"public/static/js/14c27e7f.js","hash":"eef41805e3017ef0df4d0c72ef1731e10e534379","modified":1699485358636},{"_id":"public/static/css/d5346b99.css","hash":"214a606da4fe89755b07f70a07b9f46d9af8dc01","modified":1699485358636},{"_id":"source/_posts/Linux日常问题.MD","hash":"4833f453dd3d27a2490b1cc0402c7b9e3a11f132","modified":1699497690706},{"_id":"source/_posts/SQL 查漏补缺.md","hash":"fa89246cf819ee9b7dbd3c8bdcbdaa5fc8958d1f","modified":1699510461122},{"_id":"public/api/articles/SQL 查漏补缺.json","hash":"e4ded4089df52dba47f7d306795ec423589743c1","modified":1699677454657},{"_id":"public/post/SQL 查漏补缺.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699509988256},{"_id":"source/_posts/Jira.md","hash":"5116d44975188fac14c6ac3e72c09121577623bb","modified":1699651794130},{"_id":"source/_posts/app.md","hash":"1fb88ccf23d2aadc0fce0f2ad144aa911bda5a1f","modified":1699596000381},{"_id":"source/img/app/image-20231109180024669.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699570824720},{"_id":"source/img/app/image-20231109180125705.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699570885752},{"_id":"source/img/app/image-20231109180051771.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699570851791},{"_id":"public/api/posts/2.json","hash":"bef36afaf67286ad41750975eb20484fce60a411","modified":1699916800951},{"_id":"public/api/archives/2.json","hash":"bef36afaf67286ad41750975eb20484fce60a411","modified":1699916800951},{"_id":"public/api/articles/app.json","hash":"8192b9710c8b531dc793cbc26ae24cd60b84c774","modified":1699916800951},{"_id":"public/api/articles/Jira.json","hash":"d2a8f73900bf6498e964e0381a1a7e76bb6611c8","modified":1699916800951},{"_id":"public/post/app.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699595933706},{"_id":"public/post/Jira.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699595933706},{"_id":"public/img/app/image-20231109180024669.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699595933706},{"_id":"public/img/app/image-20231109180051771.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699595933706},{"_id":"public/img/app/image-20231109180125705.png","hash":"18ad0c800b799db62e8e7c38b64f4f67f9ccb774","modified":1699595933706},{"_id":"source/img/Jira/image-20231110162340705.png","hash":"fb35886e401a7097ce67f2e5deebfa5422f23871","modified":1699651420723},{"_id":"source/img/Jira/image-20231110162600768.png","hash":"db72778fdbaedab5338ec8e16e44199eb456cfeb","modified":1699651560796},{"_id":"source/img/Jira/image-20231110013822136.png","hash":"688cc9953988360eb4bc849c92dbc3e5d51d63c5","modified":1699598302206},{"_id":"public/img/Jira/image-20231110162600768.png","hash":"db72778fdbaedab5338ec8e16e44199eb456cfeb","modified":1699651798349},{"_id":"public/img/Jira/image-20231110162340705.png","hash":"fb35886e401a7097ce67f2e5deebfa5422f23871","modified":1699651798349},{"_id":"public/img/Jira/image-20231110013822136.png","hash":"688cc9953988360eb4bc849c92dbc3e5d51d63c5","modified":1699651798349},{"_id":"source/_posts/2023-07-11-探索LCU.md","hash":"6d93db7b108d7a7a835905e92d2fa59566a24efc","modified":1699682495703},{"_id":"source/_posts/键盘上的符号对应的英文名称.md","hash":"9ec23890d61cdcbf323fc238efeb09e55349322b","modified":1699677426923},{"_id":"source/img/2023-07-11-探索LCU/image-20231110232752929.png","hash":"3e35a195a10b87c24a22f081f9b61d9bfe3291b4","modified":1699676872972},{"_id":"public/api/articles/键盘上的符号对应的英文名称.json","hash":"ac5efaedb90ef156c2a4a7344aa90dd2f287eac5","modified":1699916800951},{"_id":"public/api/articles/2023-07-11-探索LCU.json","hash":"d3d245dfb893be69e6df9f72cd83dca589292c80","modified":1699916800951},{"_id":"public/post/键盘上的符号对应的英文名称.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699677454657},{"_id":"public/post/2023-07-11-探索LCU.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699677454657},{"_id":"public/img/2023-07-11-探索LCU/image-20231110232752929.png","hash":"3e35a195a10b87c24a22f081f9b61d9bfe3291b4","modified":1699677454657},{"_id":"source/_posts/leetcode刷题日记.md","hash":"5885c90a2c407789a187abfdb9d48c1c98fbbc62","modified":1699916775634},{"_id":"public/api/articles/leetcode刷题日记.json","hash":"f3dee7bbedaa4fde9bbe57cebfb9e17fa2d9a8f5","modified":1699916800951},{"_id":"public/post/leetcode刷题日记.html","hash":"cb82279ac77180212e95157e6b0f1ebc566b8195","modified":1699916800951}],"Category":[{"name":"软件测试","_id":"cln44k4uj0003awhza2tj9a8s"},{"name":"Java基础","_id":"cln44k4up0008awhz4ycq8i2i"},{"name":"后端开发","_id":"cln44k4ut000dawhzbljg1vrr"},{"name":"数据库","_id":"cln44k4uw000lawhzej8a7t7v"},{"name":"Javascript基础","parent":"cln44k4up0008awhz4ycq8i2i","_id":"cln44k4ux000pawhz4bxc6w3c"},{"name":"后端开发","parent":"cln44k4ux000pawhz4bxc6w3c","_id":"cln44k4uy000tawhz66ha5aan"},{"name":"前端开发","parent":"cln44k4uy000tawhz66ha5aan","_id":"cln44k4uz000vawhz9kqefp0m"},{"name":"软件测试","parent":"cln44k4uz000vawhz9kqefp0m","_id":"cln44k4v0000yawhz2tq0bk3j"},{"name":"OS","parent":"cln44k4v0000yawhz2tq0bk3j","_id":"cln44k4v10010awhzgy0g9osq"},{"name":"数据库","parent":"cln44k4v10010awhzgy0g9osq","_id":"cln44k4v30013awhzfr8qdu5u"},{"name":"中间件","parent":"cln44k4v30013awhzfr8qdu5u","_id":"cln44k4v30015awhz3fl1f8y7"},{"name":"算法","parent":"cln44k4v30015awhz3fl1f8y7","_id":"cln44k4v40018awhz2fe35x60"}],"Data":[],"Page":[{"_content":"google-site-verification: googleec7ecf6065ae0891.html","source":"cret/googleec7ecf6065ae0891.html","raw":"google-site-verification: googleec7ecf6065ae0891.html","date":"2023-09-14T05:50:51.543Z","updated":"2023-09-14T05:50:46.202Z","path":"cret/googleec7ecf6065ae0891.html","title":"","comments":1,"layout":"page","_id":"cln44k4ug0001awhze44of9ec","content":"google-site-verification: googleec7ecf6065ae0891.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: googleec7ecf6065ae0891.html"},{"_content":"[\n    {\"username\":\"admin\", \"password\":\"HM_2023_test\", \"status\":\"200\", \"contain_message\":\"作成功\", \"msg\": \"操作成功\"},\n    {\"username\":\"\", \"password\":\"HM_2023_test\", \"status\":200, \"contain_message\":\"用户不存在\", \"msg\": \"用户不存在/密码错误\"},\n    {\"username\":\"admin1\", \"password\":\"HM_2023_test\", \"status\":200, \"contain_message\":\"用户不存在\", \"msg\": \"用户不存在/密码错误\"}\n]\n","source":"doc/Test Learning/api-test/登录/parameterization.json","raw":"[\n    {\"username\":\"admin\", \"password\":\"HM_2023_test\", \"status\":\"200\", \"contain_message\":\"作成功\", \"msg\": \"操作成功\"},\n    {\"username\":\"\", \"password\":\"HM_2023_test\", \"status\":200, \"contain_message\":\"用户不存在\", \"msg\": \"用户不存在/密码错误\"},\n    {\"username\":\"admin1\", \"password\":\"HM_2023_test\", \"status\":200, \"contain_message\":\"用户不存在\", \"msg\": \"用户不存在/密码错误\"}\n]\n","date":"2023-11-08T23:11:26.285Z","updated":"2023-11-08T23:11:26.285Z","path":"doc/Test Learning/api-test/登录/parameterization.json","layout":"false","_id":"clnpw4duw00008ghz8au41dsk","title":"","comments":1,"content":"[{\"username\":\"admin\",\"password\":\"HM_2023_test\",\"status\":\"200\",\"contain_message\":\"作成功\",\"msg\":\"操作成功\"},{\"username\":\"\",\"password\":\"HM_2023_test\",\"status\":200,\"contain_message\":\"用户不存在\",\"msg\":\"用户不存在/密码错误\"},{\"username\":\"admin1\",\"password\":\"HM_2023_test\",\"status\":200,\"contain_message\":\"用户不存在\",\"msg\":\"用户不存在/密码错误\"}]","site":{"data":{}},"excerpt":"","more":"[{\"username\":\"admin\",\"password\":\"HM_2023_test\",\"status\":\"200\",\"contain_message\":\"作成功\",\"msg\":\"操作成功\"},{\"username\":\"\",\"password\":\"HM_2023_test\",\"status\":200,\"contain_message\":\"用户不存在\",\"msg\":\"用户不存在/密码错误\"},{\"username\":\"admin1\",\"password\":\"HM_2023_test\",\"status\":200,\"contain_message\":\"用户不存在\",\"msg\":\"用户不存在/密码错误\"}]"}],"Post":[{"title":"Web自动化测试快速入门(Java + Selenium 4)","date":"2023-09-28T01:19:00.000Z","_content":"\n## 1. Selenium官方文档\n> https://www.selenium.dev/documentation/\n\n\n\n## 2. 第一个Selenium测试案例\n使用idea，新建maven项目，导入junit和selenium依赖。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.anicaaz</groupId>\n    <artifactId>Selenium-Learning</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-java</artifactId> <!-- <=左键点这里的selenium-Java -->\n            <version>4.12.1</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-api</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n    </dependencies>\n</project>\n```\n\n\n网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被<artifactId>标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。\n\n```xml\n<dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-firefox-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-ie-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-remote-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-safari-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n```\n\n\n\n> 第一个测试案例，测试title名称。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest {\n\n    @Test\n    public void firstTest() {\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(\"https://www.baidu.com\");//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, \"百度一下，你就知道\");//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    }\n}\n```\n\n\n\n## 3. 元素定位方式\n\n> 在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：\n>\n> 1. 找到要测试的元素\n> 2. 对其进行测试\n\n在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。\n\n* 找什么： 找属性、标签、层级、路径\n* 怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。\n\n\n\n**在Selenium中，元素定位方式，标准来讲，是以下八种**\n\n### 3.1 id （元素属性）\n\nid定位就是通过元素的id属性来定位元素。\n\nHTML规定id属性在整个Html文档中是**唯一**的\n\n使用id定位的前提是元素**得有id属性**。\n\n具体怎么用，直接看源码。\n\n![image-20230924004300712](../img/image-20230924004300712.png)\n\n所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：\n\n![image-20230924004452513](../img/image-20230924004452513.png)\n\n我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？\n\n![image-20230924004606568](./../img/image-20230924004606568.png)\n\n粗略看了一眼，By类是一个抽象类，By的具体实现应该是**静态内部类**实现的。以后分析。\n\n找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行**click，sendkeys**等操作。我们用.var来看一下这个对象的名字是什么。![image-20230924004941048](../img/image-20230924004941048.png)\n\n结果发现是WebElement接口，点进去，把方法看明白就行。\n\n![image-20230924005037622](../img/image-20230924005037622.png)\n\n完整demo\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo {\n    //通过\n    @Test\n    public void idTest() throws InterruptedException {\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        //查找用户名元素\n        By by = By.id(\"userA\");\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(\"passwordA\"));\n        //用户名输入框，输入admin\n        username.sendKeys(\"admin\");\n        //密码输入框，输入123456\n        password.sendKeys(\"123456\");\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    }\n}\n```\n\n链式写会更简洁。\n\n### 3.2 name （元素属性）\n\nname在html中可重复。\n\n使用前提是元素得有name属性。\n\n```java\n\t@Test\n    public void nameTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        driver.findElement(By.name(\"userA\")).sendKeys(\"admin\");\n        driver.findElement(By.name(\"passwordA\")).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.3 class_name （元素属性）\n\n和name、id方式几乎一致\n\n如果class有多个属性值，只能使用其中一个。\n\n```java\n\t@Test\n    public void classTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(\"telA\")).sendKeys(\"18611111111\");\n        /*driver.findElement(By.className(\"emailA\")).sendKeys(\"anicaazhu@gmail.com\");*/\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.4 tag_name （标签名称）\n\n和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。\n\n当然还是有办法可以找到第二个相同类型的tag的。```driver.findElements(By by)```会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。\n\n```java\n\t@Test\n    public void tagNameTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(\"input\")).sendKeys(\"TagName Test\");\n        driver.findElements(By.tagName(\"input\")).get(1).sendKeys(\"Second Input Tag Test\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.5 link_text （<a>超链接）\n\n文本必须为全部匹配\n\n必须只能定位a标签\n\n```html\n<a>aaaa</a>\n```\n\n匹配的就是这个”aaaa'\n\n```java\n\t@Test\n    public void linkTextTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(\"访问 新浪 网站\")).click();\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.6 partial_link_text (<a>超链接，模糊查找)\n\n和link_text唯一区别就是可以模糊查。\n\n模糊查并不是出现过相同字符就可以。必须是**缺少**才行。这么说可能有点抽象，举个例子：\n\n> 我们要找的linktext是 “aaaaa\".\n>\n> 那么。partialLinkText可以为“aaaaa\"(完全一致)，也可以为\"a\", \"aaa\", \"aa\", \"aaaa\". 但是，不可以是“aaaaaa\"或”aab\"这种。\n\n```java\n\t@Test\n    public void partialLinkTextTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(\"访问 新浪 网站\")).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(\"访问 新浪网站\")).click();//不可以\n        driver.findElement(By.partialLinkText(\"访问\")).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.7 XPath （基于元素路径）\n\n之所以用XPath和CSS，是因为万一**前六种情况都不能用**，就白瞎了。\n\n比如这种情况\n\n```<input type=\"submit\" value=\"提交\" />```\n\n没有id，没有name，没有class。\n\ntag吧，万一他不是该页面第一次出现的，也不好找。\n\nlink_text和partiall_link_text，专门给a标签用的，input不对口。\n\n所以只能能用XPath和CSS方法来定位。\n\n\n\n> XPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。\n>\n> HTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。\n>\n> 各种文件的作用：\n>\n> * XML的重点在于数据的存储和传递。常用于软件配置。\n> * HTML显示元素\n> * CSS控制显示元素的样式\n\nXPath偷懒，不手写：\n\n​\t![image-20230924203236506](../img/image-20230924203236506.png)\n\n#### 3.7.1 路径定位：绝对路径\n\n> 必须从html开始。格式：```/html/.../...```\n\n#### 3.7.2 路径定位：相对路径\n\n> 必须以```//元素名```开头\n>\n> 不知道元素名，用*代替\n>\n> 开发时建议相对路径：如果层级变化，绝对路径大概率会失效。\n\n```java\n\t@Test\n    public void xPathTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = \"/html/body/form/div/fieldset/p[1]/input\";\n        driver.findElement(By.xpath(absPath)).sendKeys(\"admin\");\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = \"//p[@id='p1']/input\";//\n       //p[@id=\"p1\"]/input  这样可以    //*[@id=\"userA\"]也可以  注意java“”中的“”要用\\\\隔开。即\\\"p1\\\"，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n#### 3.7.3 XPath扩展\n\n> 对于被标签夹着的文本。可以用```//*[text()='字符']```来定位\n\n> 对于属性中含有xxx元素，可以用//```*[contains(@attribute, '属性名')]```. 属性名可以模糊。\n>\n> 对于属性以xxx开头的元素，可以用```//*[start-with(@属性类型, '属性名')]```. 可以模糊。\n\n### 3.8 CSS （元素选择器）\n\n#### 3.8.1 id选择器\n\n根据id属性名来选择\n\n格式：#属性名\n\n#### 3.8.2 class选择器\n\n根据class属性名来选择\n\n格式：.属性名\n\n#### 3.8.3 元素选择器\n\n根据元素的标签名称来选择\n\n格式：标签名\n\n#### 3.8.4 属性选择器\n\n格式[属性=‘属性名’] \n\ne.g. [id='passwordA']\n\n#### 3.8.5 层级选择器\n\n```>```找直接子集，只能找下一级\n\n```空格```找后代\n\n```java\n\t@Test\n    public void cssSelectorTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(\"#userA\")).sendKeys(\"admin\");//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(\"[id='passwordA']\")).sendKeys(\"123456\");//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(\".telA\")).sendKeys(\"110\");//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(\"span\")).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(\"p>input[type='emailA']\")).sendKeys(\"123@qq.com\");//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n#### 3.8.6 CSS扩展\n\ninput[type^='p'] 以p开头的元素\n\ninput[type$='d'] 以d结尾的元素\n\ninput[type*='w'] 包含w的元素\n\n\n\n## 4. 元素操作\n\n### 4.1 元素操作常用方法 \n\n click( ) 单击元素\n\n clear() 清除文本\n\nsend_key(value) 输入文本\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void elementOperations() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(\"userA\"));\n        userA.sendKeys(\"admin\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(\"passwordA\")).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"telA\\\"]\")).sendKeys(\"1861111111111\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[4]/input\")).sendKeys(\"123@qq.com\");\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(\"18600000000\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"zc\\\"]/fieldset/button\")).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    }\n}\n```\n\n文件上传案例：\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[7]\")).click();//这样写是错误的\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[7]\")).sendKeys(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n\n```\n\n\n\n \n\n### 4.2 操作浏览器常用方法\n\nSelenium 4.0操作浏览器API变了。\n\n```\n//https://www.selenium.dev/documentation/webdriver/interactions/windows\n```\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void testOps() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[6]/a\")).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    }\n}\n```\n\n注意，close永远是关闭主窗口。\n\n```\n\t@Test\n    public void test() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"user\\\"]\")).sendKeys(\"admin\");\n        Thread.sleep(1000);\n        System.out.println(\"关闭主窗口之前的标题\" +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[8]/a\")).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    }\n```\n\n\n\n### 4.3 获取元素信息\n\n方法均来自于WebElement接口的对象。均以getXxx()开头。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).getSize();\n        System.out.println(\"Size: \" + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[6]/a\"));\n        String text = element.getText();\n        System.out.println(\"超链接文本: \" + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(\"href\");\n        System.out.println(\"超链接地址: \" + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[5]/span\"));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? \"可见\" : \"不可见\");\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[5]\")).isEnabled();\n        System.out.println(enabled ? \"可用\" : \"不可用\");\n        //6).判断页面中'旅游'对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[3]\")).isSelected();\n        System.out.println(selected ? \"选中\" : \"未选中\");\n        webDriver.quit();\n    }\n}\n\n```\n\n\n\n## 5. 鼠标和键盘操作\n\n### 5.1 鼠标操作\n\n> 鼠标操作官方文档： https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\n\nActions对象的创建需要传入webdriver。\n\n通过调用Actions对象方法，来编写鼠标操作\n\n并用```perform()```来执行操作。\n\n```java\npackage scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\"));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(\"admin\");\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/button\"));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    }\n}\n```\n\n\n\n拖拽操作demo：\n\n将red区块覆盖掉green区块。\n\n```\n\t@Test\n    public void testDragAndDrop() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(\"//*[@id=\\\"div1\\\"]\"));\n        WebElement green = webDriver.findElement(By.xpath(\"//*[@id=\\\"div2\\\"]\"));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    }\n```\n\n上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用\n\n```actions.dragAndDropBy(Webelement element, int xOffset, int yOffset)```来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。\n\n拖拽的实现，其实可以细分成以下动作：\n\n1. 鼠标悬停到指定区，\n2. 按住鼠标左键\n3. 将鼠标悬停到目标区块\n4. 松开鼠标\n\n\n\n### 5.2 键盘操作\n\nSelenium的键盘操作全部封装在Keys这个enum类中。\n\n![image-20230926224301341](../img/image-20230926224301341.png)\n\n通过```webDriver.sendKeys(Keys.XXX)```来调用\n\n\n\nDemo:\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\"));\n        usernameInput.sendKeys(\"admin1\");//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, \"a\");//全选\n        usernameInput.sendKeys(Keys.CONTROL, \"c\");//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[2]/input\"));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, \"v\");//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    }\n}\n```\n\n## 6.元素等待\n\n> 可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常\n>\n> 举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。\n>\n> 为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。\n>\n> 具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。\n\n### 6.1显示等待\n\n> 定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。\n>\n> 只针对单个元素有效\n\n官方文档：https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -> d.findElement(By.id(\"userAA\")));//故意写错的\n        element.sendKeys(\"admin\");\n        webDriver.quit();\n    }\n}\n\n```\n\n![image-20230927033247981](../img/image-20230927033247981.png)\n\n这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。\n\n因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。\n\n![image-20230927033542151](../img/image-20230927033542151.png)\n\n### 6.2隐式等待\n\n> 定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。\n>\n> 隐式等待对所有元素都有效\n\n```\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(\"aaa\"));\n        webDriver.quit();\n    }\n}\n\n```\n\n可以把```webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);```注释掉，对比一下，是不是真的等了10秒钟。\n\nimplicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法已经是deprecated的了。\n\n## 7. 下拉选择框\n\nhtml下拉框是```<select>```元素\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[11]/select/option[2]\")).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n\n}\n\n```\n\n### 7.1 Select类\n\n如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。\n\nselect类创建时需要将select标签的webelement作为参数传进去。\n\n具体看注释。写的很清楚了\n\n```java\n\t@Test\n    public void testSelectClass() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[11]/select\"));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(\"gz\");//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(\"A重庆\");//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n```\n\n\n\n## 8. 弹出框\n\n常用三种：\n\n1. alert 警告框\n\n2. confirm 确认框\n3. prompt 提示框\n\n处理方式都一样。\n\n* 如果点击警告框后不处理，那么后面的操作都无法执行。\n\n* 处理方法：\n  1. 切换到对话框\n  2. alert.text() / alert.dismiss() / alert.accept()\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[6]\")).click();//点击\n        Thread.sleep(5000);\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n\n```\n\n## 9. 滚动条操作\n> 滚动条菜单使用场景\n> 1. 在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 \n> 2.  页面注册同意条款，需要滚动条到最底层，才能点击同意\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo {\n\n    @Test\n    public void test() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(\"https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly\");\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(\"window.scrollTo(0,10000)\");//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    }\n}\n```\n\n## 10. Frame切换\n\n> 官网文档： https://www.selenium.dev/documentation/webdriver/interactions/frames/\n\n多种办法。swtich完了记得switch回来。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(\"myframe1\");\n        myframe1.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).sendKeys(\"admin\");\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(\"/html/body/form/div/fieldset/p[2]/input\")).sendKeys(\"123456\");\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).sendKeys(\"admin1\");//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    }\n}\n\n```\n\n## 11. 多窗口切换\n\n三个api：\n\n1. webDriver.switch().window(String handleName) 切换到指定句柄名的窗口\n   * 之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。\n2. webDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄\n3. webDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄\n\n代码注释很清楚了。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set<String> windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) {\n            System.out.println(s);\n        }\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[8]/a\")).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) {\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) {\n                webDriver.switchTo().window(s);\n            }\n        }\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    }\n}\n```\n\n## 12.截屏\n\n```\npackage scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo {\n\n    @Test\n    public void test() throws InterruptedException, IOException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(\"https://www.google.com\");\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(\"./resources/image.png\"));\n    }\n}\n```\n\nSelenium入门完结。\n\n-----\n","source":"_posts/Selenium学习.md","raw":"---\ntitle: Web自动化测试快速入门(Java + Selenium 4)\ndate: 2023-9-27 21:19:00\ntags:\n    - Selenium\n\ncategories:\n    - 软件测试\n---\n\n## 1. Selenium官方文档\n> https://www.selenium.dev/documentation/\n\n\n\n## 2. 第一个Selenium测试案例\n使用idea，新建maven项目，导入junit和selenium依赖。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.anicaaz</groupId>\n    <artifactId>Selenium-Learning</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>11</maven.compiler.source>\n        <maven.compiler.target>11</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-java</artifactId> <!-- <=左键点这里的selenium-Java -->\n            <version>4.12.1</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api -->\n        <dependency>\n            <groupId>org.junit.jupiter</groupId>\n            <artifactId>junit-jupiter-api</artifactId>\n            <version>5.10.0</version>\n            <scope>test</scope>\n        </dependency>\n\n    </dependencies>\n</project>\n```\n\n\n网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被<artifactId>标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。\n\n```xml\n<dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-firefox-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-ie-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-remote-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.seleniumhq.selenium</groupId>\n            <artifactId>selenium-safari-driver</artifactId>\n            <version>4.12.1</version>\n        </dependency>\n```\n\n\n\n> 第一个测试案例，测试title名称。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest {\n\n    @Test\n    public void firstTest() {\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(\"https://www.baidu.com\");//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, \"百度一下，你就知道\");//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    }\n}\n```\n\n\n\n## 3. 元素定位方式\n\n> 在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：\n>\n> 1. 找到要测试的元素\n> 2. 对其进行测试\n\n在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。\n\n* 找什么： 找属性、标签、层级、路径\n* 怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。\n\n\n\n**在Selenium中，元素定位方式，标准来讲，是以下八种**\n\n### 3.1 id （元素属性）\n\nid定位就是通过元素的id属性来定位元素。\n\nHTML规定id属性在整个Html文档中是**唯一**的\n\n使用id定位的前提是元素**得有id属性**。\n\n具体怎么用，直接看源码。\n\n![image-20230924004300712](../img/image-20230924004300712.png)\n\n所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：\n\n![image-20230924004452513](../img/image-20230924004452513.png)\n\n我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？\n\n![image-20230924004606568](./../img/image-20230924004606568.png)\n\n粗略看了一眼，By类是一个抽象类，By的具体实现应该是**静态内部类**实现的。以后分析。\n\n找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行**click，sendkeys**等操作。我们用.var来看一下这个对象的名字是什么。![image-20230924004941048](../img/image-20230924004941048.png)\n\n结果发现是WebElement接口，点进去，把方法看明白就行。\n\n![image-20230924005037622](../img/image-20230924005037622.png)\n\n完整demo\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo {\n    //通过\n    @Test\n    public void idTest() throws InterruptedException {\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        //查找用户名元素\n        By by = By.id(\"userA\");\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(\"passwordA\"));\n        //用户名输入框，输入admin\n        username.sendKeys(\"admin\");\n        //密码输入框，输入123456\n        password.sendKeys(\"123456\");\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    }\n}\n```\n\n链式写会更简洁。\n\n### 3.2 name （元素属性）\n\nname在html中可重复。\n\n使用前提是元素得有name属性。\n\n```java\n\t@Test\n    public void nameTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        driver.findElement(By.name(\"userA\")).sendKeys(\"admin\");\n        driver.findElement(By.name(\"passwordA\")).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.3 class_name （元素属性）\n\n和name、id方式几乎一致\n\n如果class有多个属性值，只能使用其中一个。\n\n```java\n\t@Test\n    public void classTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(\"telA\")).sendKeys(\"18611111111\");\n        /*driver.findElement(By.className(\"emailA\")).sendKeys(\"anicaazhu@gmail.com\");*/\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.4 tag_name （标签名称）\n\n和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。\n\n当然还是有办法可以找到第二个相同类型的tag的。```driver.findElements(By by)```会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。\n\n```java\n\t@Test\n    public void tagNameTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(\"input\")).sendKeys(\"TagName Test\");\n        driver.findElements(By.tagName(\"input\")).get(1).sendKeys(\"Second Input Tag Test\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.5 link_text （<a>超链接）\n\n文本必须为全部匹配\n\n必须只能定位a标签\n\n```html\n<a>aaaa</a>\n```\n\n匹配的就是这个”aaaa'\n\n```java\n\t@Test\n    public void linkTextTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(\"访问 新浪 网站\")).click();\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.6 partial_link_text (<a>超链接，模糊查找)\n\n和link_text唯一区别就是可以模糊查。\n\n模糊查并不是出现过相同字符就可以。必须是**缺少**才行。这么说可能有点抽象，举个例子：\n\n> 我们要找的linktext是 “aaaaa\".\n>\n> 那么。partialLinkText可以为“aaaaa\"(完全一致)，也可以为\"a\", \"aaa\", \"aa\", \"aaaa\". 但是，不可以是“aaaaaa\"或”aab\"这种。\n\n```java\n\t@Test\n    public void partialLinkTextTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(\"访问 新浪 网站\")).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(\"访问 新浪网站\")).click();//不可以\n        driver.findElement(By.partialLinkText(\"访问\")).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n### 3.7 XPath （基于元素路径）\n\n之所以用XPath和CSS，是因为万一**前六种情况都不能用**，就白瞎了。\n\n比如这种情况\n\n```<input type=\"submit\" value=\"提交\" />```\n\n没有id，没有name，没有class。\n\ntag吧，万一他不是该页面第一次出现的，也不好找。\n\nlink_text和partiall_link_text，专门给a标签用的，input不对口。\n\n所以只能能用XPath和CSS方法来定位。\n\n\n\n> XPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。\n>\n> HTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。\n>\n> 各种文件的作用：\n>\n> * XML的重点在于数据的存储和传递。常用于软件配置。\n> * HTML显示元素\n> * CSS控制显示元素的样式\n\nXPath偷懒，不手写：\n\n​\t![image-20230924203236506](../img/image-20230924203236506.png)\n\n#### 3.7.1 路径定位：绝对路径\n\n> 必须从html开始。格式：```/html/.../...```\n\n#### 3.7.2 路径定位：相对路径\n\n> 必须以```//元素名```开头\n>\n> 不知道元素名，用*代替\n>\n> 开发时建议相对路径：如果层级变化，绝对路径大概率会失效。\n\n```java\n\t@Test\n    public void xPathTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = \"/html/body/form/div/fieldset/p[1]/input\";\n        driver.findElement(By.xpath(absPath)).sendKeys(\"admin\");\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = \"//p[@id='p1']/input\";//\n       //p[@id=\"p1\"]/input  这样可以    //*[@id=\"userA\"]也可以  注意java“”中的“”要用\\\\隔开。即\\\"p1\\\"，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n#### 3.7.3 XPath扩展\n\n> 对于被标签夹着的文本。可以用```//*[text()='字符']```来定位\n\n> 对于属性中含有xxx元素，可以用//```*[contains(@attribute, '属性名')]```. 属性名可以模糊。\n>\n> 对于属性以xxx开头的元素，可以用```//*[start-with(@属性类型, '属性名')]```. 可以模糊。\n\n### 3.8 CSS （元素选择器）\n\n#### 3.8.1 id选择器\n\n根据id属性名来选择\n\n格式：#属性名\n\n#### 3.8.2 class选择器\n\n根据class属性名来选择\n\n格式：.属性名\n\n#### 3.8.3 元素选择器\n\n根据元素的标签名称来选择\n\n格式：标签名\n\n#### 3.8.4 属性选择器\n\n格式[属性=‘属性名’] \n\ne.g. [id='passwordA']\n\n#### 3.8.5 层级选择器\n\n```>```找直接子集，只能找下一级\n\n```空格```找后代\n\n```java\n\t@Test\n    public void cssSelectorTest() throws InterruptedException {\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(\"#userA\")).sendKeys(\"admin\");//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(\"[id='passwordA']\")).sendKeys(\"123456\");//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(\".telA\")).sendKeys(\"110\");//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(\"span\")).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(\"p>input[type='emailA']\")).sendKeys(\"123@qq.com\");//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    }\n```\n\n#### 3.8.6 CSS扩展\n\ninput[type^='p'] 以p开头的元素\n\ninput[type$='d'] 以d结尾的元素\n\ninput[type*='w'] 包含w的元素\n\n\n\n## 4. 元素操作\n\n### 4.1 元素操作常用方法 \n\n click( ) 单击元素\n\n clear() 清除文本\n\nsend_key(value) 输入文本\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void elementOperations() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(\"userA\"));\n        userA.sendKeys(\"admin\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(\"passwordA\")).sendKeys(\"123456\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"telA\\\"]\")).sendKeys(\"1861111111111\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[4]/input\")).sendKeys(\"123@qq.com\");\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(\"18600000000\");\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"zc\\\"]/fieldset/button\")).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    }\n}\n```\n\n文件上传案例：\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[7]\")).click();//这样写是错误的\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[7]\")).sendKeys(\"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\");\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n\n```\n\n\n\n \n\n### 4.2 操作浏览器常用方法\n\nSelenium 4.0操作浏览器API变了。\n\n```\n//https://www.selenium.dev/documentation/webdriver/interactions/windows\n```\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void testOps() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[6]/a\")).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    }\n}\n```\n\n注意，close永远是关闭主窗口。\n\n```\n\t@Test\n    public void test() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"user\\\"]\")).sendKeys(\"admin\");\n        Thread.sleep(1000);\n        System.out.println(\"关闭主窗口之前的标题\" +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[8]/a\")).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    }\n```\n\n\n\n### 4.3 获取元素信息\n\n方法均来自于WebElement接口的对象。均以getXxx()开头。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).getSize();\n        System.out.println(\"Size: \" + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[6]/a\"));\n        String text = element.getText();\n        System.out.println(\"超链接文本: \" + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(\"href\");\n        System.out.println(\"超链接地址: \" + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[5]/span\"));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? \"可见\" : \"不可见\");\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[5]\")).isEnabled();\n        System.out.println(enabled ? \"可用\" : \"不可用\");\n        //6).判断页面中'旅游'对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[3]\")).isSelected();\n        System.out.println(selected ? \"选中\" : \"未选中\");\n        webDriver.quit();\n    }\n}\n\n```\n\n\n\n## 5. 鼠标和键盘操作\n\n### 5.1 鼠标操作\n\n> 鼠标操作官方文档： https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\n\nActions对象的创建需要传入webdriver。\n\n通过调用Actions对象方法，来编写鼠标操作\n\n并用```perform()```来执行操作。\n\n```java\npackage scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\"));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(\"admin\");\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/button\"));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    }\n}\n```\n\n\n\n拖拽操作demo：\n\n将red区块覆盖掉green区块。\n\n```\n\t@Test\n    public void testDragAndDrop() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(\"//*[@id=\\\"div1\\\"]\"));\n        WebElement green = webDriver.findElement(By.xpath(\"//*[@id=\\\"div2\\\"]\"));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    }\n```\n\n上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用\n\n```actions.dragAndDropBy(Webelement element, int xOffset, int yOffset)```来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。\n\n拖拽的实现，其实可以细分成以下动作：\n\n1. 鼠标悬停到指定区，\n2. 按住鼠标左键\n3. 将鼠标悬停到目标区块\n4. 松开鼠标\n\n\n\n### 5.2 键盘操作\n\nSelenium的键盘操作全部封装在Keys这个enum类中。\n\n![image-20230926224301341](../img/image-20230926224301341.png)\n\n通过```webDriver.sendKeys(Keys.XXX)```来调用\n\n\n\nDemo:\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\"));\n        usernameInput.sendKeys(\"admin1\");//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, \"a\");//全选\n        usernameInput.sendKeys(Keys.CONTROL, \"c\");//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[2]/input\"));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, \"v\");//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    }\n}\n```\n\n## 6.元素等待\n\n> 可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常\n>\n> 举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。\n>\n> 为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。\n>\n> 具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。\n\n### 6.1显示等待\n\n> 定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。\n>\n> 只针对单个元素有效\n\n官方文档：https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -> d.findElement(By.id(\"userAA\")));//故意写错的\n        element.sendKeys(\"admin\");\n        webDriver.quit();\n    }\n}\n\n```\n\n![image-20230927033247981](../img/image-20230927033247981.png)\n\n这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。\n\n因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。\n\n![image-20230927033542151](../img/image-20230927033542151.png)\n\n### 6.2隐式等待\n\n> 定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。\n>\n> 隐式等待对所有元素都有效\n\n```\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(\"aaa\"));\n        webDriver.quit();\n    }\n}\n\n```\n\n可以把```webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);```注释掉，对比一下，是不是真的等了10秒钟。\n\nimplicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法已经是deprecated的了。\n\n## 7. 下拉选择框\n\nhtml下拉框是```<select>```元素\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[11]/select/option[2]\")).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n\n}\n\n```\n\n### 7.1 Select类\n\n如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。\n\nselect类创建时需要将select标签的webelement作为参数传进去。\n\n具体看注释。写的很清楚了\n\n```java\n\t@Test\n    public void testSelectClass() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[11]/select\"));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(\"gz\");//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(\"A重庆\");//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n```\n\n\n\n## 8. 弹出框\n\n常用三种：\n\n1. alert 警告框\n\n2. confirm 确认框\n3. prompt 提示框\n\n处理方式都一样。\n\n* 如果点击警告框后不处理，那么后面的操作都无法执行。\n\n* 处理方法：\n  1. 切换到对话框\n  2. alert.text() / alert.dismiss() / alert.accept()\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/form/input[6]\")).click();//点击\n        Thread.sleep(5000);\n        Wait<WebDriver> wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n\n```\n\n## 9. 滚动条操作\n> 滚动条菜单使用场景\n> 1. 在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 \n> 2.  页面注册同意条款，需要滚动条到最底层，才能点击同意\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo {\n\n    @Test\n    public void test() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(\"https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly\");\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(\"window.scrollTo(0,10000)\");//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    }\n}\n```\n\n## 10. Frame切换\n\n> 官网文档： https://www.selenium.dev/documentation/webdriver/interactions/frames/\n\n多种办法。swtich完了记得switch回来。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo {\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html\";\n\n    @Test\n    public void test() throws InterruptedException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(\"myframe1\");\n        myframe1.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).sendKeys(\"admin\");\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(\"/html/body/form/div/fieldset/p[2]/input\")).sendKeys(\"123456\");\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[1]/input\")).sendKeys(\"admin1\");//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    }\n}\n\n```\n\n## 11. 多窗口切换\n\n三个api：\n\n1. webDriver.switch().window(String handleName) 切换到指定句柄名的窗口\n   * 之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。\n2. webDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄\n3. webDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄\n\n代码注释很清楚了。\n\n```java\npackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo {\n\n    private String url = \"C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html\";\n\n    @Test\n    public void test() {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set<String> windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) {\n            System.out.println(s);\n        }\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(\"/html/body/form/div/fieldset/p[8]/a\")).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) {\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) {\n                webDriver.switchTo().window(s);\n            }\n        }\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    }\n}\n```\n\n## 12.截屏\n\n```\npackage scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo {\n\n    @Test\n    public void test() throws InterruptedException, IOException {\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(\"https://www.google.com\");\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(\"./resources/image.png\"));\n    }\n}\n```\n\nSelenium入门完结。\n\n-----\n","slug":"Selenium学习","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"cln44k4u90000awhz59cd0ya0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-Selenium官方文档\"><a href=\"#1-Selenium官方文档\" class=\"headerlink\" title=\"1. Selenium官方文档\"></a>1. Selenium官方文档</h2><blockquote>\n<p><a href=\"https://www.selenium.dev/documentation/\">https://www.selenium.dev/documentation/</a></p>\n</blockquote>\n<h2 id=\"2-第一个Selenium测试案例\"><a href=\"#2-第一个Selenium测试案例\" class=\"headerlink\" title=\"2. 第一个Selenium测试案例\"></a>2. 第一个Selenium测试案例</h2><p>使用idea，新建maven项目，导入junit和selenium依赖。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.anicaaz&lt;/groupId&gt;\n    &lt;artifactId&gt;Selenium-Learning&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;!-- &lt;=左键点这里的selenium-Java --&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n            &lt;version&gt;5.10.0&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被<artifactId>标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-ie-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-safari-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<blockquote>\n<p>第一个测试案例，测试title名称。</p>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest &#123;\n\n    @Test\n    public void firstTest() &#123;\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(&quot;https://www.baidu.com&quot;);//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, &quot;百度一下，你就知道&quot;);//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-元素定位方式\"><a href=\"#3-元素定位方式\" class=\"headerlink\" title=\"3. 元素定位方式\"></a>3. 元素定位方式</h2><blockquote>\n<p>在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：</p>\n<ol>\n<li>找到要测试的元素</li>\n<li>对其进行测试</li>\n</ol>\n</blockquote>\n<p>在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。</p>\n<ul>\n<li>找什么： 找属性、标签、层级、路径</li>\n<li>怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。</li>\n</ul>\n<p><strong>在Selenium中，元素定位方式，标准来讲，是以下八种</strong></p>\n<h3 id=\"3-1-id-（元素属性）\"><a href=\"#3-1-id-（元素属性）\" class=\"headerlink\" title=\"3.1 id （元素属性）\"></a>3.1 id （元素属性）</h3><p>id定位就是通过元素的id属性来定位元素。</p>\n<p>HTML规定id属性在整个Html文档中是<strong>唯一</strong>的</p>\n<p>使用id定位的前提是元素<strong>得有id属性</strong>。</p>\n<p>具体怎么用，直接看源码。</p>\n<p><img src=\"/../img/image-20230924004300712.png\" alt=\"image-20230924004300712\"></p>\n<p>所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：</p>\n<p><img src=\"/../img/image-20230924004452513.png\" alt=\"image-20230924004452513\"></p>\n<p>我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？</p>\n<p><img src=\"/./../img/image-20230924004606568.png\" alt=\"image-20230924004606568\"></p>\n<p>粗略看了一眼，By类是一个抽象类，By的具体实现应该是<strong>静态内部类</strong>实现的。以后分析。</p>\n<p>找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行<strong>click，sendkeys</strong>等操作。我们用.var来看一下这个对象的名字是什么。<img src=\"/../img/image-20230924004941048.png\" alt=\"image-20230924004941048\"></p>\n<p>结果发现是WebElement接口，点进去，把方法看明白就行。</p>\n<p><img src=\"/../img/image-20230924005037622.png\" alt=\"image-20230924005037622\"></p>\n<p>完整demo</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo &#123;\n    //通过\n    @Test\n    public void idTest() throws InterruptedException &#123;\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        //查找用户名元素\n        By by = By.id(&quot;userA&quot;);\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(&quot;passwordA&quot;));\n        //用户名输入框，输入admin\n        username.sendKeys(&quot;admin&quot;);\n        //密码输入框，输入123456\n        password.sendKeys(&quot;123456&quot;);\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>链式写会更简洁。</p>\n<h3 id=\"3-2-name-（元素属性）\"><a href=\"#3-2-name-（元素属性）\" class=\"headerlink\" title=\"3.2 name （元素属性）\"></a>3.2 name （元素属性）</h3><p>name在html中可重复。</p>\n<p>使用前提是元素得有name属性。</p>\n<pre><code class=\"java\">    @Test\n    public void nameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        driver.findElement(By.name(&quot;userA&quot;)).sendKeys(&quot;admin&quot;);\n        driver.findElement(By.name(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-3-class-name-（元素属性）\"><a href=\"#3-3-class-name-（元素属性）\" class=\"headerlink\" title=\"3.3 class_name （元素属性）\"></a>3.3 class_name （元素属性）</h3><p>和name、id方式几乎一致</p>\n<p>如果class有多个属性值，只能使用其中一个。</p>\n<pre><code class=\"java\">    @Test\n    public void classTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(&quot;telA&quot;)).sendKeys(&quot;18611111111&quot;);\n        /*driver.findElement(By.className(&quot;emailA&quot;)).sendKeys(&quot;anicaazhu@gmail.com&quot;);*/\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-4-tag-name-（标签名称）\"><a href=\"#3-4-tag-name-（标签名称）\" class=\"headerlink\" title=\"3.4 tag_name （标签名称）\"></a>3.4 tag_name （标签名称）</h3><p>和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。</p>\n<p>当然还是有办法可以找到第二个相同类型的tag的。<code>driver.findElements(By by)</code>会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。</p>\n<pre><code class=\"java\">    @Test\n    public void tagNameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(&quot;input&quot;)).sendKeys(&quot;TagName Test&quot;);\n        driver.findElements(By.tagName(&quot;input&quot;)).get(1).sendKeys(&quot;Second Input Tag Test&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-5-link-text-（超链接）\"><a href=\"#3-5-link-text-（超链接）\" class=\"headerlink\" title=\"3.5 link_text （超链接）\"></a>3.5 link_text （<a>超链接）</h3><p>文本必须为全部匹配</p>\n<p>必须只能定位a标签</p>\n<pre><code class=\"html\">&lt;a&gt;aaaa&lt;/a&gt;\n</code></pre>\n<p>匹配的就是这个”aaaa’</p>\n<pre><code class=\"java\">    @Test\n    public void linkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-6-partial-link-text-超链接，模糊查找\"><a href=\"#3-6-partial-link-text-超链接，模糊查找\" class=\"headerlink\" title=\"3.6 partial_link_text (超链接，模糊查找)\"></a>3.6 partial_link_text (<a>超链接，模糊查找)</h3><p>和link_text唯一区别就是可以模糊查。</p>\n<p>模糊查并不是出现过相同字符就可以。必须是<strong>缺少</strong>才行。这么说可能有点抽象，举个例子：</p>\n<blockquote>\n<p>我们要找的linktext是 “aaaaa”.</p>\n<p>那么。partialLinkText可以为“aaaaa”(完全一致)，也可以为”a”, “aaa”, “aa”, “aaaa”. 但是，不可以是“aaaaaa”或”aab”这种。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void partialLinkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(&quot;访问 新浪网站&quot;)).click();//不可以\n        driver.findElement(By.partialLinkText(&quot;访问&quot;)).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-7-XPath-（基于元素路径）\"><a href=\"#3-7-XPath-（基于元素路径）\" class=\"headerlink\" title=\"3.7 XPath （基于元素路径）\"></a>3.7 XPath （基于元素路径）</h3><p>之所以用XPath和CSS，是因为万一<strong>前六种情况都不能用</strong>，就白瞎了。</p>\n<p>比如这种情况</p>\n<p><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</code></p>\n<p>没有id，没有name，没有class。</p>\n<p>tag吧，万一他不是该页面第一次出现的，也不好找。</p>\n<p>link_text和partiall_link_text，专门给a标签用的，input不对口。</p>\n<p>所以只能能用XPath和CSS方法来定位。</p>\n<blockquote>\n<p>XPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。</p>\n<p>HTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。</p>\n<p>各种文件的作用：</p>\n<ul>\n<li>XML的重点在于数据的存储和传递。常用于软件配置。</li>\n<li>HTML显示元素</li>\n<li>CSS控制显示元素的样式</li>\n</ul>\n</blockquote>\n<p>XPath偷懒，不手写：</p>\n<p>​\t<img src=\"/../img/image-20230924203236506.png\" alt=\"image-20230924203236506\"></p>\n<h4 id=\"3-7-1-路径定位：绝对路径\"><a href=\"#3-7-1-路径定位：绝对路径\" class=\"headerlink\" title=\"3.7.1 路径定位：绝对路径\"></a>3.7.1 路径定位：绝对路径</h4><blockquote>\n<p>必须从html开始。格式：<code>/html/.../...</code></p>\n</blockquote>\n<h4 id=\"3-7-2-路径定位：相对路径\"><a href=\"#3-7-2-路径定位：相对路径\" class=\"headerlink\" title=\"3.7.2 路径定位：相对路径\"></a>3.7.2 路径定位：相对路径</h4><blockquote>\n<p>必须以<code>//元素名</code>开头</p>\n<p>不知道元素名，用*代替</p>\n<p>开发时建议相对路径：如果层级变化，绝对路径大概率会失效。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void xPathTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = &quot;/html/body/form/div/fieldset/p[1]/input&quot;;\n        driver.findElement(By.xpath(absPath)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = &quot;//p[@id=&#39;p1&#39;]/input&quot;;//\n       //p[@id=&quot;p1&quot;]/input  这样可以    //*[@id=&quot;userA&quot;]也可以  注意java“”中的“”要用\\\\隔开。即\\&quot;p1\\&quot;，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-7-3-XPath扩展\"><a href=\"#3-7-3-XPath扩展\" class=\"headerlink\" title=\"3.7.3 XPath扩展\"></a>3.7.3 XPath扩展</h4><blockquote>\n<p>对于被标签夹着的文本。可以用<code>//*[text()=&#39;字符&#39;]</code>来定位</p>\n</blockquote>\n<blockquote>\n<p>对于属性中含有xxx元素，可以用&#x2F;&#x2F;<code>*[contains(@attribute, &#39;属性名&#39;)]</code>. 属性名可以模糊。</p>\n<p>对于属性以xxx开头的元素，可以用<code>//*[start-with(@属性类型, &#39;属性名&#39;)]</code>. 可以模糊。</p>\n</blockquote>\n<h3 id=\"3-8-CSS-（元素选择器）\"><a href=\"#3-8-CSS-（元素选择器）\" class=\"headerlink\" title=\"3.8 CSS （元素选择器）\"></a>3.8 CSS （元素选择器）</h3><h4 id=\"3-8-1-id选择器\"><a href=\"#3-8-1-id选择器\" class=\"headerlink\" title=\"3.8.1 id选择器\"></a>3.8.1 id选择器</h4><p>根据id属性名来选择</p>\n<p>格式：#属性名</p>\n<h4 id=\"3-8-2-class选择器\"><a href=\"#3-8-2-class选择器\" class=\"headerlink\" title=\"3.8.2 class选择器\"></a>3.8.2 class选择器</h4><p>根据class属性名来选择</p>\n<p>格式：.属性名</p>\n<h4 id=\"3-8-3-元素选择器\"><a href=\"#3-8-3-元素选择器\" class=\"headerlink\" title=\"3.8.3 元素选择器\"></a>3.8.3 元素选择器</h4><p>根据元素的标签名称来选择</p>\n<p>格式：标签名</p>\n<h4 id=\"3-8-4-属性选择器\"><a href=\"#3-8-4-属性选择器\" class=\"headerlink\" title=\"3.8.4 属性选择器\"></a>3.8.4 属性选择器</h4><p>格式[属性&#x3D;‘属性名’] </p>\n<p>e.g. [id&#x3D;’passwordA’]</p>\n<h4 id=\"3-8-5-层级选择器\"><a href=\"#3-8-5-层级选择器\" class=\"headerlink\" title=\"3.8.5 层级选择器\"></a>3.8.5 层级选择器</h4><p><code>&gt;</code>找直接子集，只能找下一级</p>\n<p><code>空格</code>找后代</p>\n<pre><code class=\"java\">    @Test\n    public void cssSelectorTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(&quot;#userA&quot;)).sendKeys(&quot;admin&quot;);//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(&quot;[id=&#39;passwordA&#39;]&quot;)).sendKeys(&quot;123456&quot;);//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(&quot;.telA&quot;)).sendKeys(&quot;110&quot;);//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(&quot;span&quot;)).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(&quot;p&gt;input[type=&#39;emailA&#39;]&quot;)).sendKeys(&quot;123@qq.com&quot;);//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-8-6-CSS扩展\"><a href=\"#3-8-6-CSS扩展\" class=\"headerlink\" title=\"3.8.6 CSS扩展\"></a>3.8.6 CSS扩展</h4><p>input[type^&#x3D;’p’] 以p开头的元素</p>\n<p>input[type$&#x3D;’d’] 以d结尾的元素</p>\n<p>input[type*&#x3D;’w’] 包含w的元素</p>\n<h2 id=\"4-元素操作\"><a href=\"#4-元素操作\" class=\"headerlink\" title=\"4. 元素操作\"></a>4. 元素操作</h2><h3 id=\"4-1-元素操作常用方法\"><a href=\"#4-1-元素操作常用方法\" class=\"headerlink\" title=\"4.1 元素操作常用方法\"></a>4.1 元素操作常用方法</h3><p> click( ) 单击元素</p>\n<p> clear() 清除文本</p>\n<p>send_key(value) 输入文本</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void elementOperations() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(&quot;userA&quot;));\n        userA.sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;telA\\&quot;]&quot;)).sendKeys(&quot;1861111111111&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[4]/input&quot;)).sendKeys(&quot;123@qq.com&quot;);\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(&quot;18600000000&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;zc\\&quot;]/fieldset/button&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>文件上传案例：</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).click();//这样写是错误的\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).sendKeys(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-2-操作浏览器常用方法\"><a href=\"#4-2-操作浏览器常用方法\" class=\"headerlink\" title=\"4.2 操作浏览器常用方法\"></a>4.2 操作浏览器常用方法</h3><p>Selenium 4.0操作浏览器API变了。</p>\n<pre><code>//https://www.selenium.dev/documentation/webdriver/interactions/windows\n</code></pre>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testOps() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>注意，close永远是关闭主窗口。</p>\n<pre><code>    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;user\\&quot;]&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        System.out.println(&quot;关闭主窗口之前的标题&quot; +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"4-3-获取元素信息\"><a href=\"#4-3-获取元素信息\" class=\"headerlink\" title=\"4.3 获取元素信息\"></a>4.3 获取元素信息</h3><p>方法均来自于WebElement接口的对象。均以getXxx()开头。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).getSize();\n        System.out.println(&quot;Size: &quot; + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;));\n        String text = element.getText();\n        System.out.println(&quot;超链接文本: &quot; + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(&quot;href&quot;);\n        System.out.println(&quot;超链接地址: &quot; + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[5]/span&quot;));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? &quot;可见&quot; : &quot;不可见&quot;);\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[5]&quot;)).isEnabled();\n        System.out.println(enabled ? &quot;可用&quot; : &quot;不可用&quot;);\n        //6).判断页面中&#39;旅游&#39;对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[3]&quot;)).isSelected();\n        System.out.println(selected ? &quot;选中&quot; : &quot;未选中&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-鼠标和键盘操作\"><a href=\"#5-鼠标和键盘操作\" class=\"headerlink\" title=\"5. 鼠标和键盘操作\"></a>5. 鼠标和键盘操作</h2><h3 id=\"5-1-鼠标操作\"><a href=\"#5-1-鼠标操作\" class=\"headerlink\" title=\"5.1 鼠标操作\"></a>5.1 鼠标操作</h3><blockquote>\n<p>鼠标操作官方文档： <a href=\"https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\">https://www.selenium.dev/documentation/webdriver/actions_api/mouse/</a></p>\n</blockquote>\n<p>Actions对象的创建需要传入webdriver。</p>\n<p>通过调用Actions对象方法，来编写鼠标操作</p>\n<p>并用<code>perform()</code>来执行操作。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(&quot;admin&quot;);\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/button&quot;));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>拖拽操作demo：</p>\n<p>将red区块覆盖掉green区块。</p>\n<pre><code>    @Test\n    public void testDragAndDrop() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div1\\&quot;]&quot;));\n        WebElement green = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div2\\&quot;]&quot;));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<p>上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用</p>\n<p><code>actions.dragAndDropBy(Webelement element, int xOffset, int yOffset)</code>来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。</p>\n<p>拖拽的实现，其实可以细分成以下动作：</p>\n<ol>\n<li>鼠标悬停到指定区，</li>\n<li>按住鼠标左键</li>\n<li>将鼠标悬停到目标区块</li>\n<li>松开鼠标</li>\n</ol>\n<h3 id=\"5-2-键盘操作\"><a href=\"#5-2-键盘操作\" class=\"headerlink\" title=\"5.2 键盘操作\"></a>5.2 键盘操作</h3><p>Selenium的键盘操作全部封装在Keys这个enum类中。</p>\n<p><img src=\"/../img/image-20230926224301341.png\" alt=\"image-20230926224301341\"></p>\n<p>通过<code>webDriver.sendKeys(Keys.XXX)</code>来调用</p>\n<p>Demo:</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        usernameInput.sendKeys(&quot;admin1&quot;);//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, &quot;a&quot;);//全选\n        usernameInput.sendKeys(Keys.CONTROL, &quot;c&quot;);//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, &quot;v&quot;);//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"6-元素等待\"><a href=\"#6-元素等待\" class=\"headerlink\" title=\"6.元素等待\"></a>6.元素等待</h2><blockquote>\n<p>可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常</p>\n<p>举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。</p>\n<p>为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。</p>\n<p>具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。</p>\n</blockquote>\n<h3 id=\"6-1显示等待\"><a href=\"#6-1显示等待\" class=\"headerlink\" title=\"6.1显示等待\"></a>6.1显示等待</h3><blockquote>\n<p>定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。</p>\n<p>只针对单个元素有效</p>\n</blockquote>\n<p>官方文档：<a href=\"https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\">https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits</a></p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -&gt; d.findElement(By.id(&quot;userAA&quot;)));//故意写错的\n        element.sendKeys(&quot;admin&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"/../img/image-20230927033247981.png\" alt=\"image-20230927033247981\"></p>\n<p>这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。</p>\n<p>因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。</p>\n<p><img src=\"/../img/image-20230927033542151.png\" alt=\"image-20230927033542151\"></p>\n<h3 id=\"6-2隐式等待\"><a href=\"#6-2隐式等待\" class=\"headerlink\" title=\"6.2隐式等待\"></a>6.2隐式等待</h3><blockquote>\n<p>定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。</p>\n<p>隐式等待对所有元素都有效</p>\n</blockquote>\n<pre><code>package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(&quot;aaa&quot;));\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>可以把<code>webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</code>注释掉，对比一下，是不是真的等了10秒钟。</p>\n<p>implicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法已经是deprecated的了。</p>\n<h2 id=\"7-下拉选择框\"><a href=\"#7-下拉选择框\" class=\"headerlink\" title=\"7. 下拉选择框\"></a>7. 下拉选择框</h2><p>html下拉框是<code>&lt;select&gt;</code>元素</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select/option[2]&quot;)).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n\n&#125;\n</code></pre>\n<h3 id=\"7-1-Select类\"><a href=\"#7-1-Select类\" class=\"headerlink\" title=\"7.1 Select类\"></a>7.1 Select类</h3><p>如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。</p>\n<p>select类创建时需要将select标签的webelement作为参数传进去。</p>\n<p>具体看注释。写的很清楚了</p>\n<pre><code class=\"java\">    @Test\n    public void testSelectClass() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select&quot;));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(&quot;gz&quot;);//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(&quot;A重庆&quot;);//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h2 id=\"8-弹出框\"><a href=\"#8-弹出框\" class=\"headerlink\" title=\"8. 弹出框\"></a>8. 弹出框</h2><p>常用三种：</p>\n<ol>\n<li><p>alert 警告框</p>\n</li>\n<li><p>confirm 确认框</p>\n</li>\n<li><p>prompt 提示框</p>\n</li>\n</ol>\n<p>处理方式都一样。</p>\n<ul>\n<li><p>如果点击警告框后不处理，那么后面的操作都无法执行。</p>\n</li>\n<li><p>处理方法：</p>\n<ol>\n<li>切换到对话框</li>\n<li>alert.text() &#x2F; alert.dismiss() &#x2F; alert.accept()</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[6]&quot;)).click();//点击\n        Thread.sleep(5000);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"9-滚动条操作\"><a href=\"#9-滚动条操作\" class=\"headerlink\" title=\"9. 滚动条操作\"></a>9. 滚动条操作</h2><blockquote>\n<p>滚动条菜单使用场景</p>\n<ol>\n<li>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 </li>\n<li>页面注册同意条款，需要滚动条到最底层，才能点击同意</li>\n</ol>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly&quot;);\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(&quot;window.scrollTo(0,10000)&quot;);//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"10-Frame切换\"><a href=\"#10-Frame切换\" class=\"headerlink\" title=\"10. Frame切换\"></a>10. Frame切换</h2><blockquote>\n<p>官网文档： <a href=\"https://www.selenium.dev/documentation/webdriver/interactions/frames/\">https://www.selenium.dev/documentation/webdriver/interactions/frames/</a></p>\n</blockquote>\n<p>多种办法。swtich完了记得switch回来。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(&quot;myframe1&quot;);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin1&quot;);//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"11-多窗口切换\"><a href=\"#11-多窗口切换\" class=\"headerlink\" title=\"11. 多窗口切换\"></a>11. 多窗口切换</h2><p>三个api：</p>\n<ol>\n<li>webDriver.switch().window(String handleName) 切换到指定句柄名的窗口<ul>\n<li>之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。</li>\n</ul>\n</li>\n<li>webDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄</li>\n<li>webDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄</li>\n</ol>\n<p>代码注释很清楚了。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set&lt;String&gt; windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) &#123;\n            System.out.println(s);\n        &#125;\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) &#123;\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) &#123;\n                webDriver.switchTo().window(s);\n            &#125;\n        &#125;\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"12-截屏\"><a href=\"#12-截屏\" class=\"headerlink\" title=\"12.截屏\"></a>12.截屏</h2><pre><code>package scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException, IOException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.google.com&quot;);\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(&quot;./resources/image.png&quot;));\n    &#125;\n&#125;\n</code></pre>\n<p>Selenium入门完结。</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Selenium官方文档\"><a href=\"#1-Selenium官方文档\" class=\"headerlink\" title=\"1. Selenium官方文档\"></a>1. Selenium官方文档</h2><blockquote>\n<p><a href=\"https://www.selenium.dev/documentation/\">https://www.selenium.dev/documentation/</a></p>\n</blockquote>\n<h2 id=\"2-第一个Selenium测试案例\"><a href=\"#2-第一个Selenium测试案例\" class=\"headerlink\" title=\"2. 第一个Selenium测试案例\"></a>2. 第一个Selenium测试案例</h2><p>使用idea，新建maven项目，导入junit和selenium依赖。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.anicaaz&lt;/groupId&gt;\n    &lt;artifactId&gt;Selenium-Learning&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;!-- &lt;=左键点这里的selenium-Java --&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n            &lt;version&gt;5.10.0&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被<artifactId>标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-ie-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-safari-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<blockquote>\n<p>第一个测试案例，测试title名称。</p>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest &#123;\n\n    @Test\n    public void firstTest() &#123;\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(&quot;https://www.baidu.com&quot;);//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, &quot;百度一下，你就知道&quot;);//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-元素定位方式\"><a href=\"#3-元素定位方式\" class=\"headerlink\" title=\"3. 元素定位方式\"></a>3. 元素定位方式</h2><blockquote>\n<p>在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：</p>\n<ol>\n<li>找到要测试的元素</li>\n<li>对其进行测试</li>\n</ol>\n</blockquote>\n<p>在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。</p>\n<ul>\n<li>找什么： 找属性、标签、层级、路径</li>\n<li>怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。</li>\n</ul>\n<p><strong>在Selenium中，元素定位方式，标准来讲，是以下八种</strong></p>\n<h3 id=\"3-1-id-（元素属性）\"><a href=\"#3-1-id-（元素属性）\" class=\"headerlink\" title=\"3.1 id （元素属性）\"></a>3.1 id （元素属性）</h3><p>id定位就是通过元素的id属性来定位元素。</p>\n<p>HTML规定id属性在整个Html文档中是<strong>唯一</strong>的</p>\n<p>使用id定位的前提是元素<strong>得有id属性</strong>。</p>\n<p>具体怎么用，直接看源码。</p>\n<p><img src=\"/../img/image-20230924004300712.png\" alt=\"image-20230924004300712\"></p>\n<p>所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：</p>\n<p><img src=\"/../img/image-20230924004452513.png\" alt=\"image-20230924004452513\"></p>\n<p>我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？</p>\n<p><img src=\"/./../img/image-20230924004606568.png\" alt=\"image-20230924004606568\"></p>\n<p>粗略看了一眼，By类是一个抽象类，By的具体实现应该是<strong>静态内部类</strong>实现的。以后分析。</p>\n<p>找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行<strong>click，sendkeys</strong>等操作。我们用.var来看一下这个对象的名字是什么。<img src=\"/../img/image-20230924004941048.png\" alt=\"image-20230924004941048\"></p>\n<p>结果发现是WebElement接口，点进去，把方法看明白就行。</p>\n<p><img src=\"/../img/image-20230924005037622.png\" alt=\"image-20230924005037622\"></p>\n<p>完整demo</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo &#123;\n    //通过\n    @Test\n    public void idTest() throws InterruptedException &#123;\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        //查找用户名元素\n        By by = By.id(&quot;userA&quot;);\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(&quot;passwordA&quot;));\n        //用户名输入框，输入admin\n        username.sendKeys(&quot;admin&quot;);\n        //密码输入框，输入123456\n        password.sendKeys(&quot;123456&quot;);\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>链式写会更简洁。</p>\n<h3 id=\"3-2-name-（元素属性）\"><a href=\"#3-2-name-（元素属性）\" class=\"headerlink\" title=\"3.2 name （元素属性）\"></a>3.2 name （元素属性）</h3><p>name在html中可重复。</p>\n<p>使用前提是元素得有name属性。</p>\n<pre><code class=\"java\">    @Test\n    public void nameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        driver.findElement(By.name(&quot;userA&quot;)).sendKeys(&quot;admin&quot;);\n        driver.findElement(By.name(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-3-class-name-（元素属性）\"><a href=\"#3-3-class-name-（元素属性）\" class=\"headerlink\" title=\"3.3 class_name （元素属性）\"></a>3.3 class_name （元素属性）</h3><p>和name、id方式几乎一致</p>\n<p>如果class有多个属性值，只能使用其中一个。</p>\n<pre><code class=\"java\">    @Test\n    public void classTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(&quot;telA&quot;)).sendKeys(&quot;18611111111&quot;);\n        /*driver.findElement(By.className(&quot;emailA&quot;)).sendKeys(&quot;anicaazhu@gmail.com&quot;);*/\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-4-tag-name-（标签名称）\"><a href=\"#3-4-tag-name-（标签名称）\" class=\"headerlink\" title=\"3.4 tag_name （标签名称）\"></a>3.4 tag_name （标签名称）</h3><p>和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。</p>\n<p>当然还是有办法可以找到第二个相同类型的tag的。<code>driver.findElements(By by)</code>会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。</p>\n<pre><code class=\"java\">    @Test\n    public void tagNameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(&quot;input&quot;)).sendKeys(&quot;TagName Test&quot;);\n        driver.findElements(By.tagName(&quot;input&quot;)).get(1).sendKeys(&quot;Second Input Tag Test&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-5-link-text-（超链接）\"><a href=\"#3-5-link-text-（超链接）\" class=\"headerlink\" title=\"3.5 link_text （超链接）\"></a>3.5 link_text （<a>超链接）</h3><p>文本必须为全部匹配</p>\n<p>必须只能定位a标签</p>\n<pre><code class=\"html\">&lt;a&gt;aaaa&lt;/a&gt;\n</code></pre>\n<p>匹配的就是这个”aaaa’</p>\n<pre><code class=\"java\">    @Test\n    public void linkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-6-partial-link-text-超链接，模糊查找\"><a href=\"#3-6-partial-link-text-超链接，模糊查找\" class=\"headerlink\" title=\"3.6 partial_link_text (超链接，模糊查找)\"></a>3.6 partial_link_text (<a>超链接，模糊查找)</h3><p>和link_text唯一区别就是可以模糊查。</p>\n<p>模糊查并不是出现过相同字符就可以。必须是<strong>缺少</strong>才行。这么说可能有点抽象，举个例子：</p>\n<blockquote>\n<p>我们要找的linktext是 “aaaaa”.</p>\n<p>那么。partialLinkText可以为“aaaaa”(完全一致)，也可以为”a”, “aaa”, “aa”, “aaaa”. 但是，不可以是“aaaaaa”或”aab”这种。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void partialLinkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(&quot;访问 新浪网站&quot;)).click();//不可以\n        driver.findElement(By.partialLinkText(&quot;访问&quot;)).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-7-XPath-（基于元素路径）\"><a href=\"#3-7-XPath-（基于元素路径）\" class=\"headerlink\" title=\"3.7 XPath （基于元素路径）\"></a>3.7 XPath （基于元素路径）</h3><p>之所以用XPath和CSS，是因为万一<strong>前六种情况都不能用</strong>，就白瞎了。</p>\n<p>比如这种情况</p>\n<p><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</code></p>\n<p>没有id，没有name，没有class。</p>\n<p>tag吧，万一他不是该页面第一次出现的，也不好找。</p>\n<p>link_text和partiall_link_text，专门给a标签用的，input不对口。</p>\n<p>所以只能能用XPath和CSS方法来定位。</p>\n<blockquote>\n<p>XPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。</p>\n<p>HTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。</p>\n<p>各种文件的作用：</p>\n<ul>\n<li>XML的重点在于数据的存储和传递。常用于软件配置。</li>\n<li>HTML显示元素</li>\n<li>CSS控制显示元素的样式</li>\n</ul>\n</blockquote>\n<p>XPath偷懒，不手写：</p>\n<p>​\t<img src=\"/../img/image-20230924203236506.png\" alt=\"image-20230924203236506\"></p>\n<h4 id=\"3-7-1-路径定位：绝对路径\"><a href=\"#3-7-1-路径定位：绝对路径\" class=\"headerlink\" title=\"3.7.1 路径定位：绝对路径\"></a>3.7.1 路径定位：绝对路径</h4><blockquote>\n<p>必须从html开始。格式：<code>/html/.../...</code></p>\n</blockquote>\n<h4 id=\"3-7-2-路径定位：相对路径\"><a href=\"#3-7-2-路径定位：相对路径\" class=\"headerlink\" title=\"3.7.2 路径定位：相对路径\"></a>3.7.2 路径定位：相对路径</h4><blockquote>\n<p>必须以<code>//元素名</code>开头</p>\n<p>不知道元素名，用*代替</p>\n<p>开发时建议相对路径：如果层级变化，绝对路径大概率会失效。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void xPathTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = &quot;/html/body/form/div/fieldset/p[1]/input&quot;;\n        driver.findElement(By.xpath(absPath)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = &quot;//p[@id=&#39;p1&#39;]/input&quot;;//\n       //p[@id=&quot;p1&quot;]/input  这样可以    //*[@id=&quot;userA&quot;]也可以  注意java“”中的“”要用\\\\隔开。即\\&quot;p1\\&quot;，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-7-3-XPath扩展\"><a href=\"#3-7-3-XPath扩展\" class=\"headerlink\" title=\"3.7.3 XPath扩展\"></a>3.7.3 XPath扩展</h4><blockquote>\n<p>对于被标签夹着的文本。可以用<code>//*[text()=&#39;字符&#39;]</code>来定位</p>\n</blockquote>\n<blockquote>\n<p>对于属性中含有xxx元素，可以用&#x2F;&#x2F;<code>*[contains(@attribute, &#39;属性名&#39;)]</code>. 属性名可以模糊。</p>\n<p>对于属性以xxx开头的元素，可以用<code>//*[start-with(@属性类型, &#39;属性名&#39;)]</code>. 可以模糊。</p>\n</blockquote>\n<h3 id=\"3-8-CSS-（元素选择器）\"><a href=\"#3-8-CSS-（元素选择器）\" class=\"headerlink\" title=\"3.8 CSS （元素选择器）\"></a>3.8 CSS （元素选择器）</h3><h4 id=\"3-8-1-id选择器\"><a href=\"#3-8-1-id选择器\" class=\"headerlink\" title=\"3.8.1 id选择器\"></a>3.8.1 id选择器</h4><p>根据id属性名来选择</p>\n<p>格式：#属性名</p>\n<h4 id=\"3-8-2-class选择器\"><a href=\"#3-8-2-class选择器\" class=\"headerlink\" title=\"3.8.2 class选择器\"></a>3.8.2 class选择器</h4><p>根据class属性名来选择</p>\n<p>格式：.属性名</p>\n<h4 id=\"3-8-3-元素选择器\"><a href=\"#3-8-3-元素选择器\" class=\"headerlink\" title=\"3.8.3 元素选择器\"></a>3.8.3 元素选择器</h4><p>根据元素的标签名称来选择</p>\n<p>格式：标签名</p>\n<h4 id=\"3-8-4-属性选择器\"><a href=\"#3-8-4-属性选择器\" class=\"headerlink\" title=\"3.8.4 属性选择器\"></a>3.8.4 属性选择器</h4><p>格式[属性&#x3D;‘属性名’] </p>\n<p>e.g. [id&#x3D;’passwordA’]</p>\n<h4 id=\"3-8-5-层级选择器\"><a href=\"#3-8-5-层级选择器\" class=\"headerlink\" title=\"3.8.5 层级选择器\"></a>3.8.5 层级选择器</h4><p><code>&gt;</code>找直接子集，只能找下一级</p>\n<p><code>空格</code>找后代</p>\n<pre><code class=\"java\">    @Test\n    public void cssSelectorTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(&quot;#userA&quot;)).sendKeys(&quot;admin&quot;);//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(&quot;[id=&#39;passwordA&#39;]&quot;)).sendKeys(&quot;123456&quot;);//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(&quot;.telA&quot;)).sendKeys(&quot;110&quot;);//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(&quot;span&quot;)).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(&quot;p&gt;input[type=&#39;emailA&#39;]&quot;)).sendKeys(&quot;123@qq.com&quot;);//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-8-6-CSS扩展\"><a href=\"#3-8-6-CSS扩展\" class=\"headerlink\" title=\"3.8.6 CSS扩展\"></a>3.8.6 CSS扩展</h4><p>input[type^&#x3D;’p’] 以p开头的元素</p>\n<p>input[type$&#x3D;’d’] 以d结尾的元素</p>\n<p>input[type*&#x3D;’w’] 包含w的元素</p>\n<h2 id=\"4-元素操作\"><a href=\"#4-元素操作\" class=\"headerlink\" title=\"4. 元素操作\"></a>4. 元素操作</h2><h3 id=\"4-1-元素操作常用方法\"><a href=\"#4-1-元素操作常用方法\" class=\"headerlink\" title=\"4.1 元素操作常用方法\"></a>4.1 元素操作常用方法</h3><p> click( ) 单击元素</p>\n<p> clear() 清除文本</p>\n<p>send_key(value) 输入文本</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void elementOperations() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(&quot;userA&quot;));\n        userA.sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;telA\\&quot;]&quot;)).sendKeys(&quot;1861111111111&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[4]/input&quot;)).sendKeys(&quot;123@qq.com&quot;);\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(&quot;18600000000&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;zc\\&quot;]/fieldset/button&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>文件上传案例：</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).click();//这样写是错误的\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).sendKeys(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-2-操作浏览器常用方法\"><a href=\"#4-2-操作浏览器常用方法\" class=\"headerlink\" title=\"4.2 操作浏览器常用方法\"></a>4.2 操作浏览器常用方法</h3><p>Selenium 4.0操作浏览器API变了。</p>\n<pre><code>//https://www.selenium.dev/documentation/webdriver/interactions/windows\n</code></pre>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testOps() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>注意，close永远是关闭主窗口。</p>\n<pre><code>    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;user\\&quot;]&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        System.out.println(&quot;关闭主窗口之前的标题&quot; +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"4-3-获取元素信息\"><a href=\"#4-3-获取元素信息\" class=\"headerlink\" title=\"4.3 获取元素信息\"></a>4.3 获取元素信息</h3><p>方法均来自于WebElement接口的对象。均以getXxx()开头。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).getSize();\n        System.out.println(&quot;Size: &quot; + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;));\n        String text = element.getText();\n        System.out.println(&quot;超链接文本: &quot; + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(&quot;href&quot;);\n        System.out.println(&quot;超链接地址: &quot; + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[5]/span&quot;));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? &quot;可见&quot; : &quot;不可见&quot;);\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[5]&quot;)).isEnabled();\n        System.out.println(enabled ? &quot;可用&quot; : &quot;不可用&quot;);\n        //6).判断页面中&#39;旅游&#39;对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[3]&quot;)).isSelected();\n        System.out.println(selected ? &quot;选中&quot; : &quot;未选中&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-鼠标和键盘操作\"><a href=\"#5-鼠标和键盘操作\" class=\"headerlink\" title=\"5. 鼠标和键盘操作\"></a>5. 鼠标和键盘操作</h2><h3 id=\"5-1-鼠标操作\"><a href=\"#5-1-鼠标操作\" class=\"headerlink\" title=\"5.1 鼠标操作\"></a>5.1 鼠标操作</h3><blockquote>\n<p>鼠标操作官方文档： <a href=\"https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\">https://www.selenium.dev/documentation/webdriver/actions_api/mouse/</a></p>\n</blockquote>\n<p>Actions对象的创建需要传入webdriver。</p>\n<p>通过调用Actions对象方法，来编写鼠标操作</p>\n<p>并用<code>perform()</code>来执行操作。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(&quot;admin&quot;);\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/button&quot;));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>拖拽操作demo：</p>\n<p>将red区块覆盖掉green区块。</p>\n<pre><code>    @Test\n    public void testDragAndDrop() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div1\\&quot;]&quot;));\n        WebElement green = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div2\\&quot;]&quot;));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<p>上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用</p>\n<p><code>actions.dragAndDropBy(Webelement element, int xOffset, int yOffset)</code>来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。</p>\n<p>拖拽的实现，其实可以细分成以下动作：</p>\n<ol>\n<li>鼠标悬停到指定区，</li>\n<li>按住鼠标左键</li>\n<li>将鼠标悬停到目标区块</li>\n<li>松开鼠标</li>\n</ol>\n<h3 id=\"5-2-键盘操作\"><a href=\"#5-2-键盘操作\" class=\"headerlink\" title=\"5.2 键盘操作\"></a>5.2 键盘操作</h3><p>Selenium的键盘操作全部封装在Keys这个enum类中。</p>\n<p><img src=\"/../img/image-20230926224301341.png\" alt=\"image-20230926224301341\"></p>\n<p>通过<code>webDriver.sendKeys(Keys.XXX)</code>来调用</p>\n<p>Demo:</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        usernameInput.sendKeys(&quot;admin1&quot;);//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, &quot;a&quot;);//全选\n        usernameInput.sendKeys(Keys.CONTROL, &quot;c&quot;);//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, &quot;v&quot;);//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"6-元素等待\"><a href=\"#6-元素等待\" class=\"headerlink\" title=\"6.元素等待\"></a>6.元素等待</h2><blockquote>\n<p>可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常</p>\n<p>举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。</p>\n<p>为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。</p>\n<p>具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。</p>\n</blockquote>\n<h3 id=\"6-1显示等待\"><a href=\"#6-1显示等待\" class=\"headerlink\" title=\"6.1显示等待\"></a>6.1显示等待</h3><blockquote>\n<p>定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。</p>\n<p>只针对单个元素有效</p>\n</blockquote>\n<p>官方文档：<a href=\"https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\">https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits</a></p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -&gt; d.findElement(By.id(&quot;userAA&quot;)));//故意写错的\n        element.sendKeys(&quot;admin&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"/../img/image-20230927033247981.png\" alt=\"image-20230927033247981\"></p>\n<p>这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。</p>\n<p>因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。</p>\n<p><img src=\"/../img/image-20230927033542151.png\" alt=\"image-20230927033542151\"></p>\n<h3 id=\"6-2隐式等待\"><a href=\"#6-2隐式等待\" class=\"headerlink\" title=\"6.2隐式等待\"></a>6.2隐式等待</h3><blockquote>\n<p>定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。</p>\n<p>隐式等待对所有元素都有效</p>\n</blockquote>\n<pre><code>package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(&quot;aaa&quot;));\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>可以把<code>webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</code>注释掉，对比一下，是不是真的等了10秒钟。</p>\n<p>implicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法已经是deprecated的了。</p>\n<h2 id=\"7-下拉选择框\"><a href=\"#7-下拉选择框\" class=\"headerlink\" title=\"7. 下拉选择框\"></a>7. 下拉选择框</h2><p>html下拉框是<code>&lt;select&gt;</code>元素</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select/option[2]&quot;)).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n\n&#125;\n</code></pre>\n<h3 id=\"7-1-Select类\"><a href=\"#7-1-Select类\" class=\"headerlink\" title=\"7.1 Select类\"></a>7.1 Select类</h3><p>如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。</p>\n<p>select类创建时需要将select标签的webelement作为参数传进去。</p>\n<p>具体看注释。写的很清楚了</p>\n<pre><code class=\"java\">    @Test\n    public void testSelectClass() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select&quot;));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(&quot;gz&quot;);//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(&quot;A重庆&quot;);//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h2 id=\"8-弹出框\"><a href=\"#8-弹出框\" class=\"headerlink\" title=\"8. 弹出框\"></a>8. 弹出框</h2><p>常用三种：</p>\n<ol>\n<li><p>alert 警告框</p>\n</li>\n<li><p>confirm 确认框</p>\n</li>\n<li><p>prompt 提示框</p>\n</li>\n</ol>\n<p>处理方式都一样。</p>\n<ul>\n<li><p>如果点击警告框后不处理，那么后面的操作都无法执行。</p>\n</li>\n<li><p>处理方法：</p>\n<ol>\n<li>切换到对话框</li>\n<li>alert.text() &#x2F; alert.dismiss() &#x2F; alert.accept()</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[6]&quot;)).click();//点击\n        Thread.sleep(5000);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"9-滚动条操作\"><a href=\"#9-滚动条操作\" class=\"headerlink\" title=\"9. 滚动条操作\"></a>9. 滚动条操作</h2><blockquote>\n<p>滚动条菜单使用场景</p>\n<ol>\n<li>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 </li>\n<li>页面注册同意条款，需要滚动条到最底层，才能点击同意</li>\n</ol>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly&quot;);\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(&quot;window.scrollTo(0,10000)&quot;);//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"10-Frame切换\"><a href=\"#10-Frame切换\" class=\"headerlink\" title=\"10. Frame切换\"></a>10. Frame切换</h2><blockquote>\n<p>官网文档： <a href=\"https://www.selenium.dev/documentation/webdriver/interactions/frames/\">https://www.selenium.dev/documentation/webdriver/interactions/frames/</a></p>\n</blockquote>\n<p>多种办法。swtich完了记得switch回来。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(&quot;myframe1&quot;);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin1&quot;);//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"11-多窗口切换\"><a href=\"#11-多窗口切换\" class=\"headerlink\" title=\"11. 多窗口切换\"></a>11. 多窗口切换</h2><p>三个api：</p>\n<ol>\n<li>webDriver.switch().window(String handleName) 切换到指定句柄名的窗口<ul>\n<li>之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。</li>\n</ul>\n</li>\n<li>webDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄</li>\n<li>webDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄</li>\n</ol>\n<p>代码注释很清楚了。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set&lt;String&gt; windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) &#123;\n            System.out.println(s);\n        &#125;\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) &#123;\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) &#123;\n                webDriver.switchTo().window(s);\n            &#125;\n        &#125;\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"12-截屏\"><a href=\"#12-截屏\" class=\"headerlink\" title=\"12.截屏\"></a>12.截屏</h2><pre><code>package scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException, IOException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.google.com&quot;);\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(&quot;./resources/image.png&quot;));\n    &#125;\n&#125;\n</code></pre>\n<p>Selenium入门完结。</p>\n<hr>\n"},{"title":"多线程笔记","date":"2023-03-12T10:02:04.000Z","cover":"/img/cake.jpg","_content":"\n## Thread的三种创建方式\n\n### 1. 继承Thread类\n> 重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。\n\n* 调用run()方法，**必然先执行**run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会**交替执行**run内部代码以及run后面的代码。\n* 这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看**CPU调度**.\n* Demo: MyThread & MutiThreadDownloadDemo\n```java\npackage com.anicaaz.thread;\n\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"run方法被执行了\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"start方法被执行了\" + i);\n        }\n    }\n}\n```\n```java\npackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread{\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) {\n        this.url = url;\n        this.filename = filename;\n    }\n\n\n    @Override\n    public void run() {\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(\"下载了文件名\" + this.filename);\n    }\n\n    public static void main(String[] args){\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"1.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"2.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"3.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"4.jpg\");\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    }\n}\n```\n```java\npackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader{\n    public void download(String url, String filename) {\n        try {\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"URL对象创建失败\");\n        }\n    }\n}\n\n```\n\n### 2. 实现Runnable接口\n> 定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对\n> 象时的参数。最后调用thread对象的start()方法，开启线程\n\n* 本质是代理的思想。\n* Thread类其实也实现了Runnable接口。\n* Demo: MyRunnable\n```java\npackage com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"run方法被执行了\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"start后面的代码执行了\" + i);\n        }\n    }\n}\n\n```\n* 思考：将MutiThreadDownload改造成实现Runnable接口方式\n\n#### 2.1 两种创建方式的对比\n> 和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。\n> 继承了Thread类，那么别的类就继承不了了。\n\n#### 2.2 初识并发问题\n> 火车票，多人抢了同一张票。\n\n* Demo: TrainTicketDemo\n```java\npackage com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable {\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNumber <= 0) {\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + ticketNumber-- + \"张票\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, \"小明\");\n        Thread xiaofang = new Thread(train, \"小芳\");\n        Thread xiaoli = new Thread(train, \"小李\");\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    }\n}\n\n```\n\n### 3. 实现Callable接口\n> 创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后\n> 调用submit()方法提交执行，并启动该线程。可以用Future<>来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。\n\n* Demo: MyCallable\n```java\n    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable<Boolean> {\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) {\n        this.url = url;\n        this.fileName = fileName;\n    }\n\n    @Override\n    public Boolean call() throws Exception {\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(\"下载了\" + url + \" 地址的\" + fileName + \"文件\");\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable1 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"1.png\");\n        MyCallable myCallable2 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"2.png\");\n        MyCallable myCallable3 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"3.png\");\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future<Boolean> f1 = executorService.submit(myCallable1);\n        Future<Boolean> f2 = executorService.submit(myCallable2);\n        Future<Boolean> f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    }\n}\n\n```\n\n### 补票： 静态代理模式\n> 其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。\n\n* Runnable接口实现类和Thread的关系\n* Demo： StaticProxyDemo\n```java\npackage com.anicaaz.thread;\n\npublic class StaticProxyDemo {\n    public static void main(String[] args) {\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    }\n}\n\ninterface Marry {\n    void getMarried();\n}\n\nclass You implements Marry {\n    @Override\n    public void getMarried() {\n        System.out.println(\"你结婚了\");\n    }\n}\n\nclass WeddingCompany implements Marry {\n    private You you;\n\n    public WeddingCompany(You you) {\n        this.you = you;\n    }\n\n    @Override\n    public void getMarried() {\n        System.out.println(\"定酒店\");\n        System.out.println(\"布置\");\n        you.getMarried();\n        System.out.println(\"收拾\");\n        System.out.println(\"结账\");\n    }\n}\n\n```\n\n\n### 4. Lamda表达式 (package: lambda)\n> 任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();\n```java\npublic interface MyRunnable {\n    public abstract void run(); // => void run();\n}\n```\n对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。\n\n#### 4.1 Lambda的演化过程:\n\n##### 4.1.1 传统写法：创建实现类对象，调用接口方法。\n```java\npublic class TestLambda1 implements MyRunnable{\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() {\n        System.out.println(\"标准的实现方法\");\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.2 静态内部类写法 \n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda2 {\n\n    static class MyRunnableImpl implements MyRunnable {\n        @Override\n        public void run() {\n            System.out.println(\"静态内部类实现\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    }\n\n}\n```\n\n##### 4.1.3 局部内部类写法 \n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda3 {\n\n    public static void main(String[] args) {\n        class MyRunnableImpl implements MyRunnable {\n            @Override\n            public void run() {\n                System.out.println(\"局部内部类写法\");\n            }\n        }\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.4 匿名内部类写法 \n没有类的名字\n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda4 {\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable() {\n            @Override\n            public void run() {\n                System.out.println(\"匿名内部类写法\");\n            }\n        };\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.5 Lambda写法\n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda5 {\n    public static void main(String[] args) {\n        MyRunnable myRunnable = () -> {\n            System.out.println(\"Lambda 写法\");\n        };\n        myRunnable.run();\n    }\n}\n```\nLambda的主要作用是**避免内部类过多**\n\nLambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果**参数只有一个**，可以省略括号。如果**行数只有一行**，可以省略大括号。\n```java\npackage com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 {\n\n    public static void main(String[] args) {\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -> {\n            System.out.println(a + b);\n        };\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -> {\n            System.out.println(a + b);\n        };\n        myRunnable2.run(1 , 2);\n    }\n}\n```\n\n\n### 5. 线程状态  (package: threadState)\n1. 新生\n> 线程的创建\n```java\nThread thread = new Thread();\n```\n2. 就绪\n```java\nthread.start();\n```\n3. 运行\nstart之后，抢占到cpu资源。cpu调度开始执行。\n4. 阻塞\n调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行\n5. 死亡\n线程中断或结束，就进入死亡状态，无法重新启动。\n\n#### 5.1 如何停止线程\n> 建议使用flag停止线程。不建议使用destory()、stop()进行停止。\n```java\npackage com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable{\n\n    private boolean flag;\n\n    @Override\n    public void run() {\n        while (flag) {\n            System.out.println(\"线程正在运行\");\n        }\n    }\n\n    public void stop() {\n        this.flag = false;\n    }\n\n    public static void main(String[] args) {\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i < 1000; i++) {\n            if (i == 900) {\n                runnable.stop();\n                System.out.println(\"线程停止了\");\n            } else {\n                System.out.println(\"main\" + i);\n            }\n        }\n    }\n}\n```\n\n#### 5.2 Sleep 线程阻塞(休眠)\n* sleep中的参数指的是当前线程阻塞的毫秒数\n* 需要抛InterruptedException\n* sleep之间到达之后线程进入阻塞状态\n* **每个对象都有一个锁**，sleep不会释放锁\n\nDemo： 打表\n```java\npackage com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) {\n            System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        }\n    }\n}\n```\n\n#### 5.3 Yield，线程礼让\n> 礼让线程，让当前正在执行的线程暂停，但不阻塞\n> 让线程从**运行状态**转为**就绪状态**\n> 让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现**不成功**的现象\n```java\npackage com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"线程开始执行\");\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + \"线程停止执行\");\n    }\n\n    public static void main(String[] args) {\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n#### 5.4 join线程强制执行\n> 可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。\n\n```java\npackage com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 300; i++) {\n            System.out.println(Thread.currentThread().getName() + i + \"正在执行\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, \"vip\");\n        thread.start();\n        for (int i = 0; i < 500; i++) {\n            System.out.println(Thread.currentThread().getName() + i + \"正在执行\");\n            if (i == 100) {\n                try {\n                    thread.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/多线程.md","raw":"---\ntitle: 多线程笔记\ndate: 2023-3-12 05:02:04\ntags:\n- Java多线程\n\ncategories:\n- Java基础\n\ncover: /img/cake.jpg\n---\n\n## Thread的三种创建方式\n\n### 1. 继承Thread类\n> 重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。\n\n* 调用run()方法，**必然先执行**run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会**交替执行**run内部代码以及run后面的代码。\n* 这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看**CPU调度**.\n* Demo: MyThread & MutiThreadDownloadDemo\n```java\npackage com.anicaaz.thread;\n\npublic class MyThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"run方法被执行了\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"start方法被执行了\" + i);\n        }\n    }\n}\n```\n```java\npackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread{\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) {\n        this.url = url;\n        this.filename = filename;\n    }\n\n\n    @Override\n    public void run() {\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(\"下载了文件名\" + this.filename);\n    }\n\n    public static void main(String[] args){\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"1.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"2.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"3.jpg\");\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(\"https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&w=48&q=75\", \"4.jpg\");\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    }\n}\n```\n```java\npackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader{\n    public void download(String url, String filename) {\n        try {\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.out.println(\"URL对象创建失败\");\n        }\n    }\n}\n\n```\n\n### 2. 实现Runnable接口\n> 定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对\n> 象时的参数。最后调用thread对象的start()方法，开启线程\n\n* 本质是代理的思想。\n* Thread类其实也实现了Runnable接口。\n* Demo: MyRunnable\n```java\npackage com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable{\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"run方法被执行了\" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"start后面的代码执行了\" + i);\n        }\n    }\n}\n\n```\n* 思考：将MutiThreadDownload改造成实现Runnable接口方式\n\n#### 2.1 两种创建方式的对比\n> 和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。\n> 继承了Thread类，那么别的类就继承不了了。\n\n#### 2.2 初识并发问题\n> 火车票，多人抢了同一张票。\n\n* Demo: TrainTicketDemo\n```java\npackage com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable {\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() {\n        while (true) {\n            if (ticketNumber <= 0) {\n                break;\n            }\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \"抢到了第\" + ticketNumber-- + \"张票\");\n        }\n    }\n\n    public static void main(String[] args) {\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, \"小明\");\n        Thread xiaofang = new Thread(train, \"小芳\");\n        Thread xiaoli = new Thread(train, \"小李\");\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    }\n}\n\n```\n\n### 3. 实现Callable接口\n> 创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后\n> 调用submit()方法提交执行，并启动该线程。可以用Future<>来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。\n\n* Demo: MyCallable\n```java\n    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable<Boolean> {\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) {\n        this.url = url;\n        this.fileName = fileName;\n    }\n\n    @Override\n    public Boolean call() throws Exception {\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(\"下载了\" + url + \" 地址的\" + fileName + \"文件\");\n        return true;\n    }\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable1 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"1.png\");\n        MyCallable myCallable2 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"2.png\");\n        MyCallable myCallable3 = new MyCallable(\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\", \"3.png\");\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future<Boolean> f1 = executorService.submit(myCallable1);\n        Future<Boolean> f2 = executorService.submit(myCallable2);\n        Future<Boolean> f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    }\n}\n\n```\n\n### 补票： 静态代理模式\n> 其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。\n\n* Runnable接口实现类和Thread的关系\n* Demo： StaticProxyDemo\n```java\npackage com.anicaaz.thread;\n\npublic class StaticProxyDemo {\n    public static void main(String[] args) {\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    }\n}\n\ninterface Marry {\n    void getMarried();\n}\n\nclass You implements Marry {\n    @Override\n    public void getMarried() {\n        System.out.println(\"你结婚了\");\n    }\n}\n\nclass WeddingCompany implements Marry {\n    private You you;\n\n    public WeddingCompany(You you) {\n        this.you = you;\n    }\n\n    @Override\n    public void getMarried() {\n        System.out.println(\"定酒店\");\n        System.out.println(\"布置\");\n        you.getMarried();\n        System.out.println(\"收拾\");\n        System.out.println(\"结账\");\n    }\n}\n\n```\n\n\n### 4. Lamda表达式 (package: lambda)\n> 任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();\n```java\npublic interface MyRunnable {\n    public abstract void run(); // => void run();\n}\n```\n对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。\n\n#### 4.1 Lambda的演化过程:\n\n##### 4.1.1 传统写法：创建实现类对象，调用接口方法。\n```java\npublic class TestLambda1 implements MyRunnable{\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() {\n        System.out.println(\"标准的实现方法\");\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.2 静态内部类写法 \n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda2 {\n\n    static class MyRunnableImpl implements MyRunnable {\n        @Override\n        public void run() {\n            System.out.println(\"静态内部类实现\");\n        }\n    }\n\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    }\n\n}\n```\n\n##### 4.1.3 局部内部类写法 \n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda3 {\n\n    public static void main(String[] args) {\n        class MyRunnableImpl implements MyRunnable {\n            @Override\n            public void run() {\n                System.out.println(\"局部内部类写法\");\n            }\n        }\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.4 匿名内部类写法 \n没有类的名字\n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda4 {\n    public static void main(String[] args) {\n        MyRunnable myRunnable = new MyRunnable() {\n            @Override\n            public void run() {\n                System.out.println(\"匿名内部类写法\");\n            }\n        };\n        myRunnable.run();\n    }\n}\n```\n\n##### 4.1.5 Lambda写法\n```java\npackage com.anicaaz.lambda;\n\npublic class TestLambda5 {\n    public static void main(String[] args) {\n        MyRunnable myRunnable = () -> {\n            System.out.println(\"Lambda 写法\");\n        };\n        myRunnable.run();\n    }\n}\n```\nLambda的主要作用是**避免内部类过多**\n\nLambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果**参数只有一个**，可以省略括号。如果**行数只有一行**，可以省略大括号。\n```java\npackage com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 {\n\n    public static void main(String[] args) {\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -> {\n            System.out.println(a + b);\n        };\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -> {\n            System.out.println(a + b);\n        };\n        myRunnable2.run(1 , 2);\n    }\n}\n```\n\n\n### 5. 线程状态  (package: threadState)\n1. 新生\n> 线程的创建\n```java\nThread thread = new Thread();\n```\n2. 就绪\n```java\nthread.start();\n```\n3. 运行\nstart之后，抢占到cpu资源。cpu调度开始执行。\n4. 阻塞\n调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行\n5. 死亡\n线程中断或结束，就进入死亡状态，无法重新启动。\n\n#### 5.1 如何停止线程\n> 建议使用flag停止线程。不建议使用destory()、stop()进行停止。\n```java\npackage com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable{\n\n    private boolean flag;\n\n    @Override\n    public void run() {\n        while (flag) {\n            System.out.println(\"线程正在运行\");\n        }\n    }\n\n    public void stop() {\n        this.flag = false;\n    }\n\n    public static void main(String[] args) {\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i < 1000; i++) {\n            if (i == 900) {\n                runnable.stop();\n                System.out.println(\"线程停止了\");\n            } else {\n                System.out.println(\"main\" + i);\n            }\n        }\n    }\n}\n```\n\n#### 5.2 Sleep 线程阻塞(休眠)\n* sleep中的参数指的是当前线程阻塞的毫秒数\n* 需要抛InterruptedException\n* sleep之间到达之后线程进入阻塞状态\n* **每个对象都有一个锁**，sleep不会释放锁\n\nDemo： 打表\n```java\npackage com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) {\n            System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        }\n    }\n}\n```\n\n#### 5.3 Yield，线程礼让\n> 礼让线程，让当前正在执行的线程暂停，但不阻塞\n> 让线程从**运行状态**转为**就绪状态**\n> 让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现**不成功**的现象\n```java\npackage com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"线程开始执行\");\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + \"线程停止执行\");\n    }\n\n    public static void main(String[] args) {\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    }\n}\n```\n\n#### 5.4 join线程强制执行\n> 可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。\n\n```java\npackage com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i < 300; i++) {\n            System.out.println(Thread.currentThread().getName() + i + \"正在执行\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, \"vip\");\n        thread.start();\n        for (int i = 0; i < 500; i++) {\n            System.out.println(Thread.currentThread().getName() + i + \"正在执行\");\n            if (i == 100) {\n                try {\n                    thread.join();\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n```","slug":"多线程","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"cln44k4uh0002awhz8q097wnl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Thread的三种创建方式\"><a href=\"#Thread的三种创建方式\" class=\"headerlink\" title=\"Thread的三种创建方式\"></a>Thread的三种创建方式</h2><h3 id=\"1-继承Thread类\"><a href=\"#1-继承Thread类\" class=\"headerlink\" title=\"1. 继承Thread类\"></a>1. 继承Thread类</h3><blockquote>\n<p>重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。</p>\n</blockquote>\n<ul>\n<li>调用run()方法，<strong>必然先执行</strong>run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会<strong>交替执行</strong>run内部代码以及run后面的代码。</li>\n<li>这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看<strong>CPU调度</strong>.</li>\n<li>Demo: MyThread &amp; MutiThreadDownloadDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyThread extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start方法被执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread&#123;\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) &#123;\n        this.url = url;\n        this.filename = filename;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(&quot;下载了文件名&quot; + this.filename);\n    &#125;\n\n    public static void main(String[] args)&#123;\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;1.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;2.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;3.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;4.jpg&quot;);\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader&#123;\n    public void download(String url, String filename) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;URL对象创建失败&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-实现Runnable接口\"><a href=\"#2-实现Runnable接口\" class=\"headerlink\" title=\"2. 实现Runnable接口\"></a>2. 实现Runnable接口</h3><blockquote>\n<p>定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对<br>象时的参数。最后调用thread对象的start()方法，开启线程</p>\n</blockquote>\n<ul>\n<li>本质是代理的思想。</li>\n<li>Thread类其实也实现了Runnable接口。</li>\n<li>Demo: MyRunnable</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start后面的代码执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>思考：将MutiThreadDownload改造成实现Runnable接口方式</li>\n</ul>\n<h4 id=\"2-1-两种创建方式的对比\"><a href=\"#2-1-两种创建方式的对比\" class=\"headerlink\" title=\"2.1 两种创建方式的对比\"></a>2.1 两种创建方式的对比</h4><blockquote>\n<p>和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。<br>继承了Thread类，那么别的类就继承不了了。</p>\n</blockquote>\n<h4 id=\"2-2-初识并发问题\"><a href=\"#2-2-初识并发问题\" class=\"headerlink\" title=\"2.2 初识并发问题\"></a>2.2 初识并发问题</h4><blockquote>\n<p>火车票，多人抢了同一张票。</p>\n</blockquote>\n<ul>\n<li>Demo: TrainTicketDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable &#123;\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNumber &lt;= 0) &#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了第&quot; + ticketNumber-- + &quot;张票&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, &quot;小明&quot;);\n        Thread xiaofang = new Thread(train, &quot;小芳&quot;);\n        Thread xiaoli = new Thread(train, &quot;小李&quot;);\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-实现Callable接口\"><a href=\"#3-实现Callable接口\" class=\"headerlink\" title=\"3. 实现Callable接口\"></a>3. 实现Callable接口</h3><blockquote>\n<p>创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后<br>调用submit()方法提交执行，并启动该线程。可以用Future&lt;&gt;来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。</p>\n</blockquote>\n<ul>\n<li>Demo: MyCallable</li>\n</ul>\n<pre><code class=\"java\">    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable&lt;Boolean&gt; &#123;\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) &#123;\n        this.url = url;\n        this.fileName = fileName;\n    &#125;\n\n    @Override\n    public Boolean call() throws Exception &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(&quot;下载了&quot; + url + &quot; 地址的&quot; + fileName + &quot;文件&quot;);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        MyCallable myCallable1 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;1.png&quot;);\n        MyCallable myCallable2 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;2.png&quot;);\n        MyCallable myCallable3 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;3.png&quot;);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future&lt;Boolean&gt; f1 = executorService.submit(myCallable1);\n        Future&lt;Boolean&gt; f2 = executorService.submit(myCallable2);\n        Future&lt;Boolean&gt; f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"补票：-静态代理模式\"><a href=\"#补票：-静态代理模式\" class=\"headerlink\" title=\"补票： 静态代理模式\"></a>补票： 静态代理模式</h3><blockquote>\n<p>其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。</p>\n</blockquote>\n<ul>\n<li>Runnable接口实现类和Thread的关系</li>\n<li>Demo： StaticProxyDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class StaticProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void getMarried();\n&#125;\n\nclass You implements Marry &#123;\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;你结婚了&quot;);\n    &#125;\n&#125;\n\nclass WeddingCompany implements Marry &#123;\n    private You you;\n\n    public WeddingCompany(You you) &#123;\n        this.you = you;\n    &#125;\n\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;定酒店&quot;);\n        System.out.println(&quot;布置&quot;);\n        you.getMarried();\n        System.out.println(&quot;收拾&quot;);\n        System.out.println(&quot;结账&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-Lamda表达式-package-lambda\"><a href=\"#4-Lamda表达式-package-lambda\" class=\"headerlink\" title=\"4. Lamda表达式 (package: lambda)\"></a>4. Lamda表达式 (package: lambda)</h3><blockquote>\n<p>任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();</p>\n</blockquote>\n<pre><code class=\"java\">public interface MyRunnable &#123;\n    public abstract void run(); // =&gt; void run();\n&#125;\n</code></pre>\n<p>对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。</p>\n<h4 id=\"4-1-Lambda的演化过程\"><a href=\"#4-1-Lambda的演化过程\" class=\"headerlink\" title=\"4.1 Lambda的演化过程:\"></a>4.1 Lambda的演化过程:</h4><h5 id=\"4-1-1-传统写法：创建实现类对象，调用接口方法。\"><a href=\"#4-1-1-传统写法：创建实现类对象，调用接口方法。\" class=\"headerlink\" title=\"4.1.1 传统写法：创建实现类对象，调用接口方法。\"></a>4.1.1 传统写法：创建实现类对象，调用接口方法。</h5><pre><code class=\"java\">public class TestLambda1 implements MyRunnable&#123;\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;标准的实现方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-2-静态内部类写法\"><a href=\"#4-1-2-静态内部类写法\" class=\"headerlink\" title=\"4.1.2 静态内部类写法\"></a>4.1.2 静态内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda2 &#123;\n\n    static class MyRunnableImpl implements MyRunnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;静态内部类实现&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n\n&#125;\n</code></pre>\n<h5 id=\"4-1-3-局部内部类写法\"><a href=\"#4-1-3-局部内部类写法\" class=\"headerlink\" title=\"4.1.3 局部内部类写法\"></a>4.1.3 局部内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda3 &#123;\n\n    public static void main(String[] args) &#123;\n        class MyRunnableImpl implements MyRunnable &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;局部内部类写法&quot;);\n            &#125;\n        &#125;\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-4-匿名内部类写法\"><a href=\"#4-1-4-匿名内部类写法\" class=\"headerlink\" title=\"4.1.4 匿名内部类写法\"></a>4.1.4 匿名内部类写法</h5><p>没有类的名字</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda4 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;匿名内部类写法&quot;);\n            &#125;\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-5-Lambda写法\"><a href=\"#4-1-5-Lambda写法\" class=\"headerlink\" title=\"4.1.5 Lambda写法\"></a>4.1.5 Lambda写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda5 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = () -&gt; &#123;\n            System.out.println(&quot;Lambda 写法&quot;);\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<p>Lambda的主要作用是<strong>避免内部类过多</strong></p>\n<p>Lambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果<strong>参数只有一个</strong>，可以省略括号。如果<strong>行数只有一行</strong>，可以省略大括号。</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 &#123;\n\n    public static void main(String[] args) &#123;\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1 , 2);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-线程状态-package-threadState\"><a href=\"#5-线程状态-package-threadState\" class=\"headerlink\" title=\"5. 线程状态  (package: threadState)\"></a>5. 线程状态  (package: threadState)</h3><ol>\n<li>新生<blockquote>\n<p>线程的创建</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"java\">Thread thread = new Thread();\n</code></pre>\n<ol start=\"2\">\n<li>就绪</li>\n</ol>\n<pre><code class=\"java\">thread.start();\n</code></pre>\n<ol start=\"3\">\n<li>运行<br>start之后，抢占到cpu资源。cpu调度开始执行。</li>\n<li>阻塞<br>调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行</li>\n<li>死亡<br>线程中断或结束，就进入死亡状态，无法重新启动。</li>\n</ol>\n<h4 id=\"5-1-如何停止线程\"><a href=\"#5-1-如何停止线程\" class=\"headerlink\" title=\"5.1 如何停止线程\"></a>5.1 如何停止线程</h4><blockquote>\n<p>建议使用flag停止线程。不建议使用destory()、stop()进行停止。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable&#123;\n\n    private boolean flag;\n\n    @Override\n    public void run() &#123;\n        while (flag) &#123;\n            System.out.println(&quot;线程正在运行&quot;);\n        &#125;\n    &#125;\n\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            if (i == 900) &#123;\n                runnable.stop();\n                System.out.println(&quot;线程停止了&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;main&quot; + i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-2-Sleep-线程阻塞-休眠\"><a href=\"#5-2-Sleep-线程阻塞-休眠\" class=\"headerlink\" title=\"5.2 Sleep 线程阻塞(休眠)\"></a>5.2 Sleep 线程阻塞(休眠)</h4><ul>\n<li>sleep中的参数指的是当前线程阻塞的毫秒数</li>\n<li>需要抛InterruptedException</li>\n<li>sleep之间到达之后线程进入阻塞状态</li>\n<li><strong>每个对象都有一个锁</strong>，sleep不会释放锁</li>\n</ul>\n<p>Demo： 打表</p>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-3-Yield，线程礼让\"><a href=\"#5-3-Yield，线程礼让\" class=\"headerlink\" title=\"5.3 Yield，线程礼让\"></a>5.3 Yield，线程礼让</h4><blockquote>\n<p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>让线程从<strong>运行状态</strong>转为<strong>就绪状态</strong><br>让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现<strong>不成功</strong>的现象</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-4-join线程强制执行\"><a href=\"#5-4-join线程强制执行\" class=\"headerlink\" title=\"5.4 join线程强制执行\"></a>5.4 join线程强制执行</h4><blockquote>\n<p>可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 300; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, &quot;vip&quot;);\n        thread.start();\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n            if (i == 100) &#123;\n                try &#123;\n                    thread.join();\n                &#125; catch (InterruptedException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Thread的三种创建方式\"><a href=\"#Thread的三种创建方式\" class=\"headerlink\" title=\"Thread的三种创建方式\"></a>Thread的三种创建方式</h2><h3 id=\"1-继承Thread类\"><a href=\"#1-继承Thread类\" class=\"headerlink\" title=\"1. 继承Thread类\"></a>1. 继承Thread类</h3><blockquote>\n<p>重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。</p>\n</blockquote>\n<ul>\n<li>调用run()方法，<strong>必然先执行</strong>run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会<strong>交替执行</strong>run内部代码以及run后面的代码。</li>\n<li>这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看<strong>CPU调度</strong>.</li>\n<li>Demo: MyThread &amp; MutiThreadDownloadDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyThread extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start方法被执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread&#123;\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) &#123;\n        this.url = url;\n        this.filename = filename;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(&quot;下载了文件名&quot; + this.filename);\n    &#125;\n\n    public static void main(String[] args)&#123;\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;1.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;2.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;3.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;4.jpg&quot;);\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader&#123;\n    public void download(String url, String filename) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;URL对象创建失败&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-实现Runnable接口\"><a href=\"#2-实现Runnable接口\" class=\"headerlink\" title=\"2. 实现Runnable接口\"></a>2. 实现Runnable接口</h3><blockquote>\n<p>定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对<br>象时的参数。最后调用thread对象的start()方法，开启线程</p>\n</blockquote>\n<ul>\n<li>本质是代理的思想。</li>\n<li>Thread类其实也实现了Runnable接口。</li>\n<li>Demo: MyRunnable</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start后面的代码执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>思考：将MutiThreadDownload改造成实现Runnable接口方式</li>\n</ul>\n<h4 id=\"2-1-两种创建方式的对比\"><a href=\"#2-1-两种创建方式的对比\" class=\"headerlink\" title=\"2.1 两种创建方式的对比\"></a>2.1 两种创建方式的对比</h4><blockquote>\n<p>和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。<br>继承了Thread类，那么别的类就继承不了了。</p>\n</blockquote>\n<h4 id=\"2-2-初识并发问题\"><a href=\"#2-2-初识并发问题\" class=\"headerlink\" title=\"2.2 初识并发问题\"></a>2.2 初识并发问题</h4><blockquote>\n<p>火车票，多人抢了同一张票。</p>\n</blockquote>\n<ul>\n<li>Demo: TrainTicketDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable &#123;\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNumber &lt;= 0) &#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了第&quot; + ticketNumber-- + &quot;张票&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, &quot;小明&quot;);\n        Thread xiaofang = new Thread(train, &quot;小芳&quot;);\n        Thread xiaoli = new Thread(train, &quot;小李&quot;);\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-实现Callable接口\"><a href=\"#3-实现Callable接口\" class=\"headerlink\" title=\"3. 实现Callable接口\"></a>3. 实现Callable接口</h3><blockquote>\n<p>创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后<br>调用submit()方法提交执行，并启动该线程。可以用Future&lt;&gt;来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。</p>\n</blockquote>\n<ul>\n<li>Demo: MyCallable</li>\n</ul>\n<pre><code class=\"java\">    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable&lt;Boolean&gt; &#123;\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) &#123;\n        this.url = url;\n        this.fileName = fileName;\n    &#125;\n\n    @Override\n    public Boolean call() throws Exception &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(&quot;下载了&quot; + url + &quot; 地址的&quot; + fileName + &quot;文件&quot;);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        MyCallable myCallable1 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;1.png&quot;);\n        MyCallable myCallable2 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;2.png&quot;);\n        MyCallable myCallable3 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;3.png&quot;);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future&lt;Boolean&gt; f1 = executorService.submit(myCallable1);\n        Future&lt;Boolean&gt; f2 = executorService.submit(myCallable2);\n        Future&lt;Boolean&gt; f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"补票：-静态代理模式\"><a href=\"#补票：-静态代理模式\" class=\"headerlink\" title=\"补票： 静态代理模式\"></a>补票： 静态代理模式</h3><blockquote>\n<p>其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。</p>\n</blockquote>\n<ul>\n<li>Runnable接口实现类和Thread的关系</li>\n<li>Demo： StaticProxyDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class StaticProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void getMarried();\n&#125;\n\nclass You implements Marry &#123;\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;你结婚了&quot;);\n    &#125;\n&#125;\n\nclass WeddingCompany implements Marry &#123;\n    private You you;\n\n    public WeddingCompany(You you) &#123;\n        this.you = you;\n    &#125;\n\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;定酒店&quot;);\n        System.out.println(&quot;布置&quot;);\n        you.getMarried();\n        System.out.println(&quot;收拾&quot;);\n        System.out.println(&quot;结账&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-Lamda表达式-package-lambda\"><a href=\"#4-Lamda表达式-package-lambda\" class=\"headerlink\" title=\"4. Lamda表达式 (package: lambda)\"></a>4. Lamda表达式 (package: lambda)</h3><blockquote>\n<p>任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();</p>\n</blockquote>\n<pre><code class=\"java\">public interface MyRunnable &#123;\n    public abstract void run(); // =&gt; void run();\n&#125;\n</code></pre>\n<p>对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。</p>\n<h4 id=\"4-1-Lambda的演化过程\"><a href=\"#4-1-Lambda的演化过程\" class=\"headerlink\" title=\"4.1 Lambda的演化过程:\"></a>4.1 Lambda的演化过程:</h4><h5 id=\"4-1-1-传统写法：创建实现类对象，调用接口方法。\"><a href=\"#4-1-1-传统写法：创建实现类对象，调用接口方法。\" class=\"headerlink\" title=\"4.1.1 传统写法：创建实现类对象，调用接口方法。\"></a>4.1.1 传统写法：创建实现类对象，调用接口方法。</h5><pre><code class=\"java\">public class TestLambda1 implements MyRunnable&#123;\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;标准的实现方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-2-静态内部类写法\"><a href=\"#4-1-2-静态内部类写法\" class=\"headerlink\" title=\"4.1.2 静态内部类写法\"></a>4.1.2 静态内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda2 &#123;\n\n    static class MyRunnableImpl implements MyRunnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;静态内部类实现&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n\n&#125;\n</code></pre>\n<h5 id=\"4-1-3-局部内部类写法\"><a href=\"#4-1-3-局部内部类写法\" class=\"headerlink\" title=\"4.1.3 局部内部类写法\"></a>4.1.3 局部内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda3 &#123;\n\n    public static void main(String[] args) &#123;\n        class MyRunnableImpl implements MyRunnable &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;局部内部类写法&quot;);\n            &#125;\n        &#125;\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-4-匿名内部类写法\"><a href=\"#4-1-4-匿名内部类写法\" class=\"headerlink\" title=\"4.1.4 匿名内部类写法\"></a>4.1.4 匿名内部类写法</h5><p>没有类的名字</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda4 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;匿名内部类写法&quot;);\n            &#125;\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-5-Lambda写法\"><a href=\"#4-1-5-Lambda写法\" class=\"headerlink\" title=\"4.1.5 Lambda写法\"></a>4.1.5 Lambda写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda5 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = () -&gt; &#123;\n            System.out.println(&quot;Lambda 写法&quot;);\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<p>Lambda的主要作用是<strong>避免内部类过多</strong></p>\n<p>Lambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果<strong>参数只有一个</strong>，可以省略括号。如果<strong>行数只有一行</strong>，可以省略大括号。</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 &#123;\n\n    public static void main(String[] args) &#123;\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1 , 2);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-线程状态-package-threadState\"><a href=\"#5-线程状态-package-threadState\" class=\"headerlink\" title=\"5. 线程状态  (package: threadState)\"></a>5. 线程状态  (package: threadState)</h3><ol>\n<li>新生<blockquote>\n<p>线程的创建</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"java\">Thread thread = new Thread();\n</code></pre>\n<ol start=\"2\">\n<li>就绪</li>\n</ol>\n<pre><code class=\"java\">thread.start();\n</code></pre>\n<ol start=\"3\">\n<li>运行<br>start之后，抢占到cpu资源。cpu调度开始执行。</li>\n<li>阻塞<br>调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行</li>\n<li>死亡<br>线程中断或结束，就进入死亡状态，无法重新启动。</li>\n</ol>\n<h4 id=\"5-1-如何停止线程\"><a href=\"#5-1-如何停止线程\" class=\"headerlink\" title=\"5.1 如何停止线程\"></a>5.1 如何停止线程</h4><blockquote>\n<p>建议使用flag停止线程。不建议使用destory()、stop()进行停止。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable&#123;\n\n    private boolean flag;\n\n    @Override\n    public void run() &#123;\n        while (flag) &#123;\n            System.out.println(&quot;线程正在运行&quot;);\n        &#125;\n    &#125;\n\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            if (i == 900) &#123;\n                runnable.stop();\n                System.out.println(&quot;线程停止了&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;main&quot; + i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-2-Sleep-线程阻塞-休眠\"><a href=\"#5-2-Sleep-线程阻塞-休眠\" class=\"headerlink\" title=\"5.2 Sleep 线程阻塞(休眠)\"></a>5.2 Sleep 线程阻塞(休眠)</h4><ul>\n<li>sleep中的参数指的是当前线程阻塞的毫秒数</li>\n<li>需要抛InterruptedException</li>\n<li>sleep之间到达之后线程进入阻塞状态</li>\n<li><strong>每个对象都有一个锁</strong>，sleep不会释放锁</li>\n</ul>\n<p>Demo： 打表</p>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-3-Yield，线程礼让\"><a href=\"#5-3-Yield，线程礼让\" class=\"headerlink\" title=\"5.3 Yield，线程礼让\"></a>5.3 Yield，线程礼让</h4><blockquote>\n<p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>让线程从<strong>运行状态</strong>转为<strong>就绪状态</strong><br>让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现<strong>不成功</strong>的现象</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-4-join线程强制执行\"><a href=\"#5-4-join线程强制执行\" class=\"headerlink\" title=\"5.4 join线程强制执行\"></a>5.4 join线程强制执行</h4><blockquote>\n<p>可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 300; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, &quot;vip&quot;);\n        thread.start();\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n            if (i == 100) &#123;\n                try &#123;\n                    thread.join();\n                &#125; catch (InterruptedException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"Spring笔记","date":"2023-02-12T14:34:49.000Z","cover":"/img/rice.jpg","_content":"\n\n# Spring复习笔记\n\n>\n> Spring是开源的免费框架\n>\n> **轻量级、非入侵式的**\n>\n> **IOC控制反转， AOP面向切面**编程 \t\t\t\t\t是重点\n>\n> 支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点\n\n总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。\n\n\n\n## LC1. 任何项目，首先先导这两个maven\n\n```\n1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\n```\n\n![image-20230417092051417](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092051417.png)\n\n\n\n## LC2. Spring简介\n\n> - Springboot快速开发的脚手架。基于springboot可以快速开发单个微服务.\n>\n> - Springcloud是基于springboot实现的。\n\nSpring起到了承上启下的作用。\n\n弊端： 发展了太久，违背了原来的理念。\n\n\n\n> ## LC3. Spring IOC\n\n以前写业务\n\n* UserDao接口\n\n* UserDaoImpl实现类(会有多个)\n\n* UserService 业务接口\n\n* UserServiceImpl业务实现类(会有多个)\n* ![image-20230417104203040](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417104203040.png)\n\n![image-20230417092414541](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092414541.png)\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。\n\n\n\n改进1：![image-20230417092618282](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092618282.png)\n\n这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。\n\n也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。**系统的耦合性降低**。\n\n\n\n## LC4: IOC本质\n\n![image-20230417101934817](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417101934817.png)\n\n\n\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。\n\n**控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。**\n\n> **大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可**\n\n\n\n## LC5: Bean Definition Inheritance (Bean标签的理解)\n\n> \"Bean definition can contain a lot of configuration information, including **constructor arguments**, **property values**, and **container-specific information**, such as the **initialization method**, a static factory method name, and so on. \"\n\n需要掌握的代码\n\n```java\nApplicationContext applicationConext = new ClassPathXmlApplicationContext(\"BeanName.xml\");\n```\n\n\n\n## LC6. Spring对象的创建\n\n1. Spring容器默认使用无参构造创建对象\n2. 假如需要使用有参构造创建对象， 三种方式 <constructor-arg>\n    1.  下标 index\n    2. 参数类型 type   -> 不建议使用，多个同类型的参数，会乱。\n    3. 直接通过参数名 name.\n        * 也可以用ref 对象的方法。和通过参数名类似。\n\n**总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。**\n\n> 面试： BeanFactory相关。\n>\n> BeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了\n\n\n\n### 1.BeanPostProcessor 是什么？\n\n> \"The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.\"\n\n首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。\n\n\n\n\n\n\n\n## LC7. Spring配置详解\n\n### 1. 别名\n\n<bean> 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。\n\n使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。\n\n\n\n### 2. Import\n\n将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下\n\n```xml\n<import resource=\"beans1.xml\">\n<import resource=\"beans2.xml\">    \n<import resource=\"beans3.xml\">    \n```\n\n\n\n## LC8. 依赖注入\n\n### 1. 构造器注入\n\n​\t前面讲过了\n\n```xml\n<constructor-arg>\n```\n\n\n\n### 2. Set方式注入\n\n> 各种数据类型的注入\n>\n> ![image-20230417165807121](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165807121.png![image-20230417165836555](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165836555.png)\n\n\n\n### 3. 拓展方式注入\n\n命名空间注入：\n\n比如 p命名空间，直接能够注入property\n\n```\n<beans id=\"xxx\" class=\"com.xxx.xxx\" p:name=\"xxx\" p:age=\"11\";\n```\n\n以及  c命名空间，其实就是constructor-arg\n\n\n\n## LC9. Bean的作用域\n\n1. 单例模式（默认）\n2. 原型模式\n\n\n\n## LC10. Bean的自动装配\n\n> 1. **如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错**\n> 2. **而byType相反。你bean id想怎么写就怎么写。** 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.\n\n\n\nSpring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。\n\n可以直接去Spring官网复制黏贴代码就可以。节约时间。\n\n链接： https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n\n```\n\n复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。\n\n\n\n补充:\n\n```\n<context:annotation-config/> 隐式的注册了以下的PostProcessors\n\n\tConfigurationClassPostProcessor\n\n\tAutowiredAnnotationBeanPostProcessor\n\n\tCommonAnnotationBeanPostProcessor\n\n\tPersistenceAnnotationBeanPostProcessor\n\n\tEventListenerMethodProcessor\n\n\n```\n\n\n\n### 1. Autowired可以用在哪里\n\n* 构造器上\n\n    * 注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。\n\n      ```\n      As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n      ```\n\n*  传统的set方法上\n\n```java\npublic class SimpleMovieLister {\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // ...\n}\n```\n\n\n\n* 带参的方法上\n\n  ```\n  public class MovieRecommender {\n  \n      private MovieCatalog movieCatalog;\n  \n      private CustomerPreferenceDao customerPreferenceDao;\n  \n      @Autowired\n      public void prepare(MovieCatalog movieCatalog,\n              CustomerPreferenceDao customerPreferenceDao) {\n          this.movieCatalog = movieCatalog;\n          this.customerPreferenceDao = customerPreferenceDao;\n      }\n  \n      // ...\n  }\n  ```\n\n\n\n* 成员变量和构造方法上\n\n  ```java\n  public class MovieRecommender {\n  \n      private final CustomerPreferenceDao customerPreferenceDao;\n  \n      @Autowired\n      private MovieCatalog movieCatalog;\n  \n      @Autowired\n      public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n          this.customerPreferenceDao = customerPreferenceDao;\n      }\n  \n      // ...\n  }\n  \n  ```\n\n\n\n* 如果想让Spring为相同类型的多个bean的话，可以使用数组、集合\n\n  ```\n  public class MovieRecommender {\n  \n      @Autowired\n      private MovieCatalog[] movieCatalogs;\n  \n      // ...\n  }\n  \n  public class MovieRecommender {\n  \n      private Set<MovieCatalog> movieCatalogs;\n  \n      @Autowired\n      public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {\n          this.movieCatalogs = movieCatalogs;\n      }\n  \n      // ...\n  }\n  \n  \n  ```\n\n\n\n### 2. Autowire失败条件\n\n> utowiring fails when no matching candidate beans are available for a given injection point.\n\n\n\n### 3. @Autowiresd(required= false) 意思\n\n```\nIn other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.\n```\n\n其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。\n\n\n\n### 4. 什么是Qualifier\n\n> 多个同类型的bean实现autowire的时候使用\n>\n> ```xml\n> @AutoWired\n> @Qualifier(value=xxx1)\n> private Dog dog;\n> \n> \n> \n> \n> <xml ....>\n> \n> <bean id='xxx1' class=\"dog\">\n> <bean id=\"xxx\", class = \"dog\">\n> ```\n\n\n\n### 5. Resource注解\n\n> Javax.annotation.resource\n>\n> Ioc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。\n\n\n\n引申问题： Resource和Autowire的区别？\n\n\n\n\n\n## LC11 注解开发\n\n关键字：@ component\n\n在spring4之后，需要导入aop包，来开启注解开发。\n\n```\nspring-aop\n```\n\n\n\n流程：\n\n1. ```xml\n    <context:annotation-config> \n    \n    ```\n\n2. ```xml\n    <context:component-scan base-package=\"com.example.xxx\">\n    <!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效-->\n    ```\n\n\n\n@component 挂在类上，代表这个类被spring管理了\n\n@Value挂在变量上面，代表这个变量的值\n\n```java\n@Value(\"anicaa\")\nprivate String name;\n```\n\n* 也可以挂在set方法上。同理\n\n  ```java\n  @Value(\"anicaa\")\n  public void setName(String name){\n  \tthis.name = name;\n  }\n  ```\n\n\n\n@Scope，就是决定单例，多例的注解。同样挂在类上。\n\n```java\n@Scope(\"prototype\")\n@Scope(\"singleton\")\n```\n\n\n\n### @components注解的衍生\n\n> 在web开发中，我们会按照model-view-controller三层架构来分层。\n>\n> 1. dao层\n> 2. service层\n> 3. controller层\n>\n> **每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。**\n\n\n\n## LC12. 使用纯Java配置Spring\n\n> 旨在离开xml配置，只使用java就能完成配置。\n\n```java\n//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig {\n\n    @Bean\n    public User getUser(){\n        return new User();\n    }\n\n}\n\n```\n\n```java\n//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User {\n    @Value(\"anicaa\")\n    private String name;\n\n    public String getName(){\n        return this.name;\n    }\n}\n\n```\n\n```java\n测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(\"getUser\");\n        System.out.println(user.getName());\n    }\n}\n\n```\n\n- 挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.\n\n- @ComponentScan(\"com.exmaple.xxx\"). 挂在config类头上，就是扫描。\n- @Import() 导入别的config类.\n\n\n\n## LC13. AOP\n\n> Spring中比较重要的模式： 代理模式 和 工厂模式\n\n### 设计模式-代理模式（AOP底层）\n\n#### 1. 静态代理\n\n> 静态代理的**静态**，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例\n\n1. User Service接口\n\n```java\npackage com.example.test;\n\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n}\n\n```\n\n2.  UserServiceImpl 实现类\n\n```java\npackage com.example.test;\n\npublic class UserServiceImpl implements UserService{\n\n\n    @Override\n    public void add() {\n        System.out.println(\"添加了\");\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"删除了\");\n    }\n\n    @Override\n    public void query() {\n        System.out.println(\"查询了\");\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"更新了\");\n    }\n}\n\n```\n\n3. UserServiceProxy 静态代理类。\n\n```\npackage com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService {\n    private UserServiceImpl userService;\n\n    public UserServiceProxy(){\n\n    }\n\n    public UserServiceProxy(UserServiceImpl userService){\n        this.userService = userService;\n    }\n\n    @Override\n    public void add() {\n        log(\"add\");\n        userService.add();\n    }\n\n    @Override\n    public void delete() {\n        log(\"delete\");\n        userService.delete();\n    }\n\n    @Override\n    public void query() {\n        log(\"query\");\n        userService.query();\n    }\n\n    @Override\n    public void update() {\n        log(\"update\");\n        userService.update();\n    }\n\n    public void log(String str){\n        System.out.println(\"call \" + str);\n    }\n}\n\n```\n\n4.Client 类. 调用了代理，执行接口的放法。\n\n```\npackage com.example.test;\n\npublic class Client {\n    public static void main(String[] args) {\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    }\n}\n\n```\n\n在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。\n\n\n\n#### 2. 动态代理\n\n> 而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。\n>\n> 在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。\n>\n> 原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。\n>\n> 现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler\n>\n> ```java\n> setTarget(Object target)\n> ```\n>\n> 就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类**所对应的接口**，并把这个接口返回给我们。\n> 之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。\n\n\n\n1. InvocationHandler\n\n```\npackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler {\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    }\n\n    public void setTarget(Object target){\n        this.target = target;\n    }\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        log(method.getName());\n        return method.invoke(target, args);\n    }\n\n    private void log(String msg){\n        System.out.println(\"Calling\" + msg);\n    }\n}\n\n```\n\n2. Client\n\n```\npackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler {\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    }\n\n    public void setTarget(Object target){\n        this.target = target;\n    }\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        log(method.getName());\n        return method.invoke(target, args);\n    }\n\n    private void log(String msg){\n        System.out.println(\"Calling\" + msg);\n    }\n}\n\n```\n\n\n\n## LC14. Spring AOP\n","source":"_posts/Spring笔记.md","raw":"---\ntitle: Spring笔记\ndate: 2023-2-12 09:34:49\ntags:\n    - Spring\n\ncategories:\n    - 后端开发    \n\ncover: /img/rice.jpg\n---\n\n\n# Spring复习笔记\n\n>\n> Spring是开源的免费框架\n>\n> **轻量级、非入侵式的**\n>\n> **IOC控制反转， AOP面向切面**编程 \t\t\t\t\t是重点\n>\n> 支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点\n\n总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。\n\n\n\n## LC1. 任何项目，首先先导这两个maven\n\n```\n1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\n```\n\n![image-20230417092051417](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092051417.png)\n\n\n\n## LC2. Spring简介\n\n> - Springboot快速开发的脚手架。基于springboot可以快速开发单个微服务.\n>\n> - Springcloud是基于springboot实现的。\n\nSpring起到了承上启下的作用。\n\n弊端： 发展了太久，违背了原来的理念。\n\n\n\n> ## LC3. Spring IOC\n\n以前写业务\n\n* UserDao接口\n\n* UserDaoImpl实现类(会有多个)\n\n* UserService 业务接口\n\n* UserServiceImpl业务实现类(会有多个)\n* ![image-20230417104203040](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417104203040.png)\n\n![image-20230417092414541](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092414541.png)\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。\n\n\n\n改进1：![image-20230417092618282](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092618282.png)\n\n这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。\n\n也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。**系统的耦合性降低**。\n\n\n\n## LC4: IOC本质\n\n![image-20230417101934817](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417101934817.png)\n\n\n\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。\n\n**控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。**\n\n> **大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可**\n\n\n\n## LC5: Bean Definition Inheritance (Bean标签的理解)\n\n> \"Bean definition can contain a lot of configuration information, including **constructor arguments**, **property values**, and **container-specific information**, such as the **initialization method**, a static factory method name, and so on. \"\n\n需要掌握的代码\n\n```java\nApplicationContext applicationConext = new ClassPathXmlApplicationContext(\"BeanName.xml\");\n```\n\n\n\n## LC6. Spring对象的创建\n\n1. Spring容器默认使用无参构造创建对象\n2. 假如需要使用有参构造创建对象， 三种方式 <constructor-arg>\n    1.  下标 index\n    2. 参数类型 type   -> 不建议使用，多个同类型的参数，会乱。\n    3. 直接通过参数名 name.\n        * 也可以用ref 对象的方法。和通过参数名类似。\n\n**总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。**\n\n> 面试： BeanFactory相关。\n>\n> BeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了\n\n\n\n### 1.BeanPostProcessor 是什么？\n\n> \"The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.\"\n\n首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。\n\n\n\n\n\n\n\n## LC7. Spring配置详解\n\n### 1. 别名\n\n<bean> 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。\n\n使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。\n\n\n\n### 2. Import\n\n将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下\n\n```xml\n<import resource=\"beans1.xml\">\n<import resource=\"beans2.xml\">    \n<import resource=\"beans3.xml\">    \n```\n\n\n\n## LC8. 依赖注入\n\n### 1. 构造器注入\n\n​\t前面讲过了\n\n```xml\n<constructor-arg>\n```\n\n\n\n### 2. Set方式注入\n\n> 各种数据类型的注入\n>\n> ![image-20230417165807121](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165807121.png![image-20230417165836555](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165836555.png)\n\n\n\n### 3. 拓展方式注入\n\n命名空间注入：\n\n比如 p命名空间，直接能够注入property\n\n```\n<beans id=\"xxx\" class=\"com.xxx.xxx\" p:name=\"xxx\" p:age=\"11\";\n```\n\n以及  c命名空间，其实就是constructor-arg\n\n\n\n## LC9. Bean的作用域\n\n1. 单例模式（默认）\n2. 原型模式\n\n\n\n## LC10. Bean的自动装配\n\n> 1. **如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错**\n> 2. **而byType相反。你bean id想怎么写就怎么写。** 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.\n\n\n\nSpring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。\n\n可以直接去Spring官网复制黏贴代码就可以。节约时间。\n\n链接： https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n\n```\n\n复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。\n\n\n\n补充:\n\n```\n<context:annotation-config/> 隐式的注册了以下的PostProcessors\n\n\tConfigurationClassPostProcessor\n\n\tAutowiredAnnotationBeanPostProcessor\n\n\tCommonAnnotationBeanPostProcessor\n\n\tPersistenceAnnotationBeanPostProcessor\n\n\tEventListenerMethodProcessor\n\n\n```\n\n\n\n### 1. Autowired可以用在哪里\n\n* 构造器上\n\n    * 注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。\n\n      ```\n      As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n      ```\n\n*  传统的set方法上\n\n```java\npublic class SimpleMovieLister {\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // ...\n}\n```\n\n\n\n* 带参的方法上\n\n  ```\n  public class MovieRecommender {\n  \n      private MovieCatalog movieCatalog;\n  \n      private CustomerPreferenceDao customerPreferenceDao;\n  \n      @Autowired\n      public void prepare(MovieCatalog movieCatalog,\n              CustomerPreferenceDao customerPreferenceDao) {\n          this.movieCatalog = movieCatalog;\n          this.customerPreferenceDao = customerPreferenceDao;\n      }\n  \n      // ...\n  }\n  ```\n\n\n\n* 成员变量和构造方法上\n\n  ```java\n  public class MovieRecommender {\n  \n      private final CustomerPreferenceDao customerPreferenceDao;\n  \n      @Autowired\n      private MovieCatalog movieCatalog;\n  \n      @Autowired\n      public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n          this.customerPreferenceDao = customerPreferenceDao;\n      }\n  \n      // ...\n  }\n  \n  ```\n\n\n\n* 如果想让Spring为相同类型的多个bean的话，可以使用数组、集合\n\n  ```\n  public class MovieRecommender {\n  \n      @Autowired\n      private MovieCatalog[] movieCatalogs;\n  \n      // ...\n  }\n  \n  public class MovieRecommender {\n  \n      private Set<MovieCatalog> movieCatalogs;\n  \n      @Autowired\n      public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {\n          this.movieCatalogs = movieCatalogs;\n      }\n  \n      // ...\n  }\n  \n  \n  ```\n\n\n\n### 2. Autowire失败条件\n\n> utowiring fails when no matching candidate beans are available for a given injection point.\n\n\n\n### 3. @Autowiresd(required= false) 意思\n\n```\nIn other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.\n```\n\n其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。\n\n\n\n### 4. 什么是Qualifier\n\n> 多个同类型的bean实现autowire的时候使用\n>\n> ```xml\n> @AutoWired\n> @Qualifier(value=xxx1)\n> private Dog dog;\n> \n> \n> \n> \n> <xml ....>\n> \n> <bean id='xxx1' class=\"dog\">\n> <bean id=\"xxx\", class = \"dog\">\n> ```\n\n\n\n### 5. Resource注解\n\n> Javax.annotation.resource\n>\n> Ioc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。\n\n\n\n引申问题： Resource和Autowire的区别？\n\n\n\n\n\n## LC11 注解开发\n\n关键字：@ component\n\n在spring4之后，需要导入aop包，来开启注解开发。\n\n```\nspring-aop\n```\n\n\n\n流程：\n\n1. ```xml\n    <context:annotation-config> \n    \n    ```\n\n2. ```xml\n    <context:component-scan base-package=\"com.example.xxx\">\n    <!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效-->\n    ```\n\n\n\n@component 挂在类上，代表这个类被spring管理了\n\n@Value挂在变量上面，代表这个变量的值\n\n```java\n@Value(\"anicaa\")\nprivate String name;\n```\n\n* 也可以挂在set方法上。同理\n\n  ```java\n  @Value(\"anicaa\")\n  public void setName(String name){\n  \tthis.name = name;\n  }\n  ```\n\n\n\n@Scope，就是决定单例，多例的注解。同样挂在类上。\n\n```java\n@Scope(\"prototype\")\n@Scope(\"singleton\")\n```\n\n\n\n### @components注解的衍生\n\n> 在web开发中，我们会按照model-view-controller三层架构来分层。\n>\n> 1. dao层\n> 2. service层\n> 3. controller层\n>\n> **每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。**\n\n\n\n## LC12. 使用纯Java配置Spring\n\n> 旨在离开xml配置，只使用java就能完成配置。\n\n```java\n//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig {\n\n    @Bean\n    public User getUser(){\n        return new User();\n    }\n\n}\n\n```\n\n```java\n//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User {\n    @Value(\"anicaa\")\n    private String name;\n\n    public String getName(){\n        return this.name;\n    }\n}\n\n```\n\n```java\n测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(\"getUser\");\n        System.out.println(user.getName());\n    }\n}\n\n```\n\n- 挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.\n\n- @ComponentScan(\"com.exmaple.xxx\"). 挂在config类头上，就是扫描。\n- @Import() 导入别的config类.\n\n\n\n## LC13. AOP\n\n> Spring中比较重要的模式： 代理模式 和 工厂模式\n\n### 设计模式-代理模式（AOP底层）\n\n#### 1. 静态代理\n\n> 静态代理的**静态**，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例\n\n1. User Service接口\n\n```java\npackage com.example.test;\n\npublic interface UserService {\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n}\n\n```\n\n2.  UserServiceImpl 实现类\n\n```java\npackage com.example.test;\n\npublic class UserServiceImpl implements UserService{\n\n\n    @Override\n    public void add() {\n        System.out.println(\"添加了\");\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"删除了\");\n    }\n\n    @Override\n    public void query() {\n        System.out.println(\"查询了\");\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"更新了\");\n    }\n}\n\n```\n\n3. UserServiceProxy 静态代理类。\n\n```\npackage com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService {\n    private UserServiceImpl userService;\n\n    public UserServiceProxy(){\n\n    }\n\n    public UserServiceProxy(UserServiceImpl userService){\n        this.userService = userService;\n    }\n\n    @Override\n    public void add() {\n        log(\"add\");\n        userService.add();\n    }\n\n    @Override\n    public void delete() {\n        log(\"delete\");\n        userService.delete();\n    }\n\n    @Override\n    public void query() {\n        log(\"query\");\n        userService.query();\n    }\n\n    @Override\n    public void update() {\n        log(\"update\");\n        userService.update();\n    }\n\n    public void log(String str){\n        System.out.println(\"call \" + str);\n    }\n}\n\n```\n\n4.Client 类. 调用了代理，执行接口的放法。\n\n```\npackage com.example.test;\n\npublic class Client {\n    public static void main(String[] args) {\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    }\n}\n\n```\n\n在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。\n\n\n\n#### 2. 动态代理\n\n> 而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。\n>\n> 在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。\n>\n> 原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。\n>\n> 现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler\n>\n> ```java\n> setTarget(Object target)\n> ```\n>\n> 就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类**所对应的接口**，并把这个接口返回给我们。\n> 之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。\n\n\n\n1. InvocationHandler\n\n```\npackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler {\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    }\n\n    public void setTarget(Object target){\n        this.target = target;\n    }\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        log(method.getName());\n        return method.invoke(target, args);\n    }\n\n    private void log(String msg){\n        System.out.println(\"Calling\" + msg);\n    }\n}\n\n```\n\n2. Client\n\n```\npackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler {\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    }\n\n    public void setTarget(Object target){\n        this.target = target;\n    }\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        log(method.getName());\n        return method.invoke(target, args);\n    }\n\n    private void log(String msg){\n        System.out.println(\"Calling\" + msg);\n    }\n}\n\n```\n\n\n\n## LC14. Spring AOP\n","slug":"Spring笔记","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"cln44k4um0005awhzgxun60y3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Spring复习笔记\"><a href=\"#Spring复习笔记\" class=\"headerlink\" title=\"Spring复习笔记\"></a>Spring复习笔记</h1><blockquote>\n<p>Spring是开源的免费框架</p>\n<p><strong>轻量级、非入侵式的</strong></p>\n<p><strong>IOC控制反转， AOP面向切面</strong>编程 \t\t\t\t\t是重点</p>\n<p>支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点</p>\n</blockquote>\n<p>总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。</p>\n<h2 id=\"LC1-任何项目，首先先导这两个maven\"><a href=\"#LC1-任何项目，首先先导这两个maven\" class=\"headerlink\" title=\"LC1. 任何项目，首先先导这两个maven\"></a>LC1. 任何项目，首先先导这两个maven</h2><pre><code>1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\n</code></pre>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092051417.png\" alt=\"image-20230417092051417\"></p>\n<h2 id=\"LC2-Spring简介\"><a href=\"#LC2-Spring简介\" class=\"headerlink\" title=\"LC2. Spring简介\"></a>LC2. Spring简介</h2><blockquote>\n<ul>\n<li><p>Springboot快速开发的脚手架。基于springboot可以快速开发单个微服务.</p>\n</li>\n<li><p>Springcloud是基于springboot实现的。</p>\n</li>\n</ul>\n</blockquote>\n<p>Spring起到了承上启下的作用。</p>\n<p>弊端： 发展了太久，违背了原来的理念。</p>\n<blockquote>\n<h2 id=\"LC3-Spring-IOC\"><a href=\"#LC3-Spring-IOC\" class=\"headerlink\" title=\"LC3. Spring IOC\"></a>LC3. Spring IOC</h2></blockquote>\n<p>以前写业务</p>\n<ul>\n<li><p>UserDao接口</p>\n</li>\n<li><p>UserDaoImpl实现类(会有多个)</p>\n</li>\n<li><p>UserService 业务接口</p>\n</li>\n<li><p>UserServiceImpl业务实现类(会有多个)</p>\n</li>\n<li><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417104203040.png\" alt=\"image-20230417104203040\"></p>\n</li>\n</ul>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092414541.png\" alt=\"image-20230417092414541\"></p>\n<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。</p>\n<p>改进1：<img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092618282.png\" alt=\"image-20230417092618282\"></p>\n<p>这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。</p>\n<p>也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。<strong>系统的耦合性降低</strong>。</p>\n<h2 id=\"LC4-IOC本质\"><a href=\"#LC4-IOC本质\" class=\"headerlink\" title=\"LC4: IOC本质\"></a>LC4: IOC本质</h2><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417101934817.png\" alt=\"image-20230417101934817\"></p>\n<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。</p>\n<p><strong>控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。</strong></p>\n<blockquote>\n<p><strong>大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可</strong></p>\n</blockquote>\n<h2 id=\"LC5-Bean-Definition-Inheritance-Bean标签的理解\"><a href=\"#LC5-Bean-Definition-Inheritance-Bean标签的理解\" class=\"headerlink\" title=\"LC5: Bean Definition Inheritance (Bean标签的理解)\"></a>LC5: Bean Definition Inheritance (Bean标签的理解)</h2><blockquote>\n<p>“Bean definition can contain a lot of configuration information, including <strong>constructor arguments</strong>, <strong>property values</strong>, and <strong>container-specific information</strong>, such as the <strong>initialization method</strong>, a static factory method name, and so on. “</p>\n</blockquote>\n<p>需要掌握的代码</p>\n<pre><code class=\"java\">ApplicationContext applicationConext = new ClassPathXmlApplicationContext(&quot;BeanName.xml&quot;);\n</code></pre>\n<h2 id=\"LC6-Spring对象的创建\"><a href=\"#LC6-Spring对象的创建\" class=\"headerlink\" title=\"LC6. Spring对象的创建\"></a>LC6. Spring对象的创建</h2><ol>\n<li>Spring容器默认使用无参构造创建对象</li>\n<li>假如需要使用有参构造创建对象， 三种方式 <constructor-arg><ol>\n<li>下标 index</li>\n<li>参数类型 type   -&gt; 不建议使用，多个同类型的参数，会乱。</li>\n<li>直接通过参数名 name.<ul>\n<li>也可以用ref 对象的方法。和通过参数名类似。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。</strong></p>\n<blockquote>\n<p>面试： BeanFactory相关。</p>\n<p>BeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了</p>\n</blockquote>\n<h3 id=\"1-BeanPostProcessor-是什么？\"><a href=\"#1-BeanPostProcessor-是什么？\" class=\"headerlink\" title=\"1.BeanPostProcessor 是什么？\"></a>1.BeanPostProcessor 是什么？</h3><blockquote>\n<p>“The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom <code>BeanPostProcessor</code> implementations.”</p>\n</blockquote>\n<p>首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。</p>\n<h2 id=\"LC7-Spring配置详解\"><a href=\"#LC7-Spring配置详解\" class=\"headerlink\" title=\"LC7. Spring配置详解\"></a>LC7. Spring配置详解</h2><h3 id=\"1-别名\"><a href=\"#1-别名\" class=\"headerlink\" title=\"1. 别名\"></a>1. 别名</h3><p><bean> 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。</p>\n<p>使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。</p>\n<h3 id=\"2-Import\"><a href=\"#2-Import\" class=\"headerlink\" title=\"2. Import\"></a>2. Import</h3><p>将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下</p>\n<pre><code class=\"xml\">&lt;import resource=&quot;beans1.xml&quot;&gt;\n&lt;import resource=&quot;beans2.xml&quot;&gt;    \n&lt;import resource=&quot;beans3.xml&quot;&gt;    \n</code></pre>\n<h2 id=\"LC8-依赖注入\"><a href=\"#LC8-依赖注入\" class=\"headerlink\" title=\"LC8. 依赖注入\"></a>LC8. 依赖注入</h2><h3 id=\"1-构造器注入\"><a href=\"#1-构造器注入\" class=\"headerlink\" title=\"1. 构造器注入\"></a>1. 构造器注入</h3><p>​\t前面讲过了</p>\n<pre><code class=\"xml\">&lt;constructor-arg&gt;\n</code></pre>\n<h3 id=\"2-Set方式注入\"><a href=\"#2-Set方式注入\" class=\"headerlink\" title=\"2. Set方式注入\"></a>2. Set方式注入</h3><blockquote>\n<p>各种数据类型的注入</p>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165807121.png![image-20230417165836555](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165836555.png\" alt=\"image-20230417165807121\"></p>\n</blockquote>\n<h3 id=\"3-拓展方式注入\"><a href=\"#3-拓展方式注入\" class=\"headerlink\" title=\"3. 拓展方式注入\"></a>3. 拓展方式注入</h3><p>命名空间注入：</p>\n<p>比如 p命名空间，直接能够注入property</p>\n<pre><code>&lt;beans id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; p:name=&quot;xxx&quot; p:age=&quot;11&quot;;\n</code></pre>\n<p>以及  c命名空间，其实就是constructor-arg</p>\n<h2 id=\"LC9-Bean的作用域\"><a href=\"#LC9-Bean的作用域\" class=\"headerlink\" title=\"LC9. Bean的作用域\"></a>LC9. Bean的作用域</h2><ol>\n<li>单例模式（默认）</li>\n<li>原型模式</li>\n</ol>\n<h2 id=\"LC10-Bean的自动装配\"><a href=\"#LC10-Bean的自动装配\" class=\"headerlink\" title=\"LC10. Bean的自动装配\"></a>LC10. Bean的自动装配</h2><blockquote>\n<ol>\n<li><strong>如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错</strong></li>\n<li><strong>而byType相反。你bean id想怎么写就怎么写。</strong> 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.</li>\n</ol>\n</blockquote>\n<p>Spring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。</p>\n<p>可以直接去Spring官网复制黏贴代码就可以。节约时间。</p>\n<p>链接： <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config</a></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。</p>\n<p>补充:</p>\n<pre><code>&lt;context:annotation-config/&gt; 隐式的注册了以下的PostProcessors\n\n    ConfigurationClassPostProcessor\n\n    AutowiredAnnotationBeanPostProcessor\n\n    CommonAnnotationBeanPostProcessor\n\n    PersistenceAnnotationBeanPostProcessor\n\n    EventListenerMethodProcessor\n\n</code></pre>\n<h3 id=\"1-Autowired可以用在哪里\"><a href=\"#1-Autowired可以用在哪里\" class=\"headerlink\" title=\"1. Autowired可以用在哪里\"></a>1. Autowired可以用在哪里</h3><ul>\n<li><p>构造器上</p>\n<ul>\n<li><p>注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。</p>\n<pre><code>As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>传统的set方法上</p>\n</li>\n</ul>\n<pre><code class=\"java\">public class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n<ul>\n<li><p>带参的方法上</p>\n<pre><code>public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(MovieCatalog movieCatalog,\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>成员变量和构造方法上</p>\n<pre><code class=\"java\">public class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>如果想让Spring为相同类型的多个bean的话，可以使用数组、集合</p>\n<pre><code>public class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n\n    // ...\n&#125;\n\npublic class MovieRecommender &#123;\n\n    private Set&lt;MovieCatalog&gt; movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n</code></pre>\n</li>\n</ul>\n<h3 id=\"2-Autowire失败条件\"><a href=\"#2-Autowire失败条件\" class=\"headerlink\" title=\"2. Autowire失败条件\"></a>2. Autowire失败条件</h3><blockquote>\n<p>utowiring fails when no matching candidate beans are available for a given injection point.</p>\n</blockquote>\n<h3 id=\"3-Autowiresd-required-false-意思\"><a href=\"#3-Autowiresd-required-false-意思\" class=\"headerlink\" title=\"3. @Autowiresd(required&#x3D; false) 意思\"></a>3. @Autowiresd(required&#x3D; false) 意思</h3><pre><code>In other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.\n</code></pre>\n<p>其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。</p>\n<h3 id=\"4-什么是Qualifier\"><a href=\"#4-什么是Qualifier\" class=\"headerlink\" title=\"4. 什么是Qualifier\"></a>4. 什么是Qualifier</h3><blockquote>\n<p>多个同类型的bean实现autowire的时候使用</p>\n<pre><code class=\"xml\">@AutoWired\n@Qualifier(value=xxx1)\nprivate Dog dog;\n\n\n\n\n&lt;xml ....&gt;\n\n&lt;bean id=&#39;xxx1&#39; class=&quot;dog&quot;&gt;\n&lt;bean id=&quot;xxx&quot;, class = &quot;dog&quot;&gt;\n</code></pre>\n</blockquote>\n<h3 id=\"5-Resource注解\"><a href=\"#5-Resource注解\" class=\"headerlink\" title=\"5. Resource注解\"></a>5. Resource注解</h3><blockquote>\n<p>Javax.annotation.resource</p>\n<p>Ioc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。</p>\n</blockquote>\n<p>引申问题： Resource和Autowire的区别？</p>\n<h2 id=\"LC11-注解开发\"><a href=\"#LC11-注解开发\" class=\"headerlink\" title=\"LC11 注解开发\"></a>LC11 注解开发</h2><p>关键字：@ component</p>\n<p>在spring4之后，需要导入aop包，来开启注解开发。</p>\n<pre><code>spring-aop\n</code></pre>\n<p>流程：</p>\n<ol>\n<li><pre><code class=\"xml\"> &lt;context:annotation-config&gt; \n \n</code></pre>\n</li>\n<li><pre><code class=\"xml\"> &lt;context:component-scan base-package=&quot;com.example.xxx&quot;&gt;\n &lt;!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效--&gt;\n</code></pre>\n</li>\n</ol>\n<p>@component 挂在类上，代表这个类被spring管理了</p>\n<p>@Value挂在变量上面，代表这个变量的值</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\nprivate String name;\n</code></pre>\n<ul>\n<li><p>也可以挂在set方法上。同理</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\npublic void setName(String name)&#123;\n    this.name = name;\n&#125;\n</code></pre>\n</li>\n</ul>\n<p>@Scope，就是决定单例，多例的注解。同样挂在类上。</p>\n<pre><code class=\"java\">@Scope(&quot;prototype&quot;)\n@Scope(&quot;singleton&quot;)\n</code></pre>\n<h3 id=\"components注解的衍生\"><a href=\"#components注解的衍生\" class=\"headerlink\" title=\"@components注解的衍生\"></a>@components注解的衍生</h3><blockquote>\n<p>在web开发中，我们会按照model-view-controller三层架构来分层。</p>\n<ol>\n<li>dao层</li>\n<li>service层</li>\n<li>controller层</li>\n</ol>\n<p><strong>每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。</strong></p>\n</blockquote>\n<h2 id=\"LC12-使用纯Java配置Spring\"><a href=\"#LC12-使用纯Java配置Spring\" class=\"headerlink\" title=\"LC12. 使用纯Java配置Spring\"></a>LC12. 使用纯Java配置Spring</h2><blockquote>\n<p>旨在离开xml配置，只使用java就能完成配置。</p>\n</blockquote>\n<pre><code class=\"java\">//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig &#123;\n\n    @Bean\n    public User getUser()&#123;\n        return new User();\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n    @Value(&quot;anicaa&quot;)\n    private String name;\n\n    public String getName()&#123;\n        return this.name;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(&quot;getUser&quot;);\n        System.out.println(user.getName());\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><p>挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.</p>\n</li>\n<li><p>@ComponentScan(“com.exmaple.xxx”). 挂在config类头上，就是扫描。</p>\n</li>\n<li><p>@Import() 导入别的config类.</p>\n</li>\n</ul>\n<h2 id=\"LC13-AOP\"><a href=\"#LC13-AOP\" class=\"headerlink\" title=\"LC13. AOP\"></a>LC13. AOP</h2><blockquote>\n<p>Spring中比较重要的模式： 代理模式 和 工厂模式</p>\n</blockquote>\n<h3 id=\"设计模式-代理模式（AOP底层）\"><a href=\"#设计模式-代理模式（AOP底层）\" class=\"headerlink\" title=\"设计模式-代理模式（AOP底层）\"></a>设计模式-代理模式（AOP底层）</h3><h4 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. 静态代理</h4><blockquote>\n<p>静态代理的<strong>静态</strong>，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例</p>\n</blockquote>\n<ol>\n<li>User Service接口</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>UserServiceImpl 实现类</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic class UserServiceImpl implements UserService&#123;\n\n\n    @Override\n    public void add() &#123;\n        System.out.println(&quot;添加了&quot;);\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        System.out.println(&quot;删除了&quot;);\n    &#125;\n\n    @Override\n    public void query() &#123;\n        System.out.println(&quot;查询了&quot;);\n    &#125;\n\n    @Override\n    public void update() &#123;\n        System.out.println(&quot;更新了&quot;);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>UserServiceProxy 静态代理类。</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService &#123;\n    private UserServiceImpl userService;\n\n    public UserServiceProxy()&#123;\n\n    &#125;\n\n    public UserServiceProxy(UserServiceImpl userService)&#123;\n        this.userService = userService;\n    &#125;\n\n    @Override\n    public void add() &#123;\n        log(&quot;add&quot;);\n        userService.add();\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        log(&quot;delete&quot;);\n        userService.delete();\n    &#125;\n\n    @Override\n    public void query() &#123;\n        log(&quot;query&quot;);\n        userService.query();\n    &#125;\n\n    @Override\n    public void update() &#123;\n        log(&quot;update&quot;);\n        userService.update();\n    &#125;\n\n    public void log(String str)&#123;\n        System.out.println(&quot;call &quot; + str);\n    &#125;\n&#125;\n</code></pre>\n<p>4.Client 类. 调用了代理，执行接口的放法。</p>\n<pre><code>package com.example.test;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    &#125;\n&#125;\n</code></pre>\n<p>在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。</p>\n<h4 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. 动态代理</h4><blockquote>\n<p>而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。</p>\n<p>在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。</p>\n<p>原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。</p>\n<p>现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler</p>\n<pre><code class=\"java\">setTarget(Object target)\n</code></pre>\n<p>就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类<strong>所对应的接口</strong>，并把这个接口返回给我们。<br>之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。</p>\n</blockquote>\n<ol>\n<li>InvocationHandler</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>Client</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"LC14-Spring-AOP\"><a href=\"#LC14-Spring-AOP\" class=\"headerlink\" title=\"LC14. Spring AOP\"></a>LC14. Spring AOP</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring复习笔记\"><a href=\"#Spring复习笔记\" class=\"headerlink\" title=\"Spring复习笔记\"></a>Spring复习笔记</h1><blockquote>\n<p>Spring是开源的免费框架</p>\n<p><strong>轻量级、非入侵式的</strong></p>\n<p><strong>IOC控制反转， AOP面向切面</strong>编程 \t\t\t\t\t是重点</p>\n<p>支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点</p>\n</blockquote>\n<p>总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。</p>\n<h2 id=\"LC1-任何项目，首先先导这两个maven\"><a href=\"#LC1-任何项目，首先先导这两个maven\" class=\"headerlink\" title=\"LC1. 任何项目，首先先导这两个maven\"></a>LC1. 任何项目，首先先导这两个maven</h2><pre><code>1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\n</code></pre>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092051417.png\" alt=\"image-20230417092051417\"></p>\n<h2 id=\"LC2-Spring简介\"><a href=\"#LC2-Spring简介\" class=\"headerlink\" title=\"LC2. Spring简介\"></a>LC2. Spring简介</h2><blockquote>\n<ul>\n<li><p>Springboot快速开发的脚手架。基于springboot可以快速开发单个微服务.</p>\n</li>\n<li><p>Springcloud是基于springboot实现的。</p>\n</li>\n</ul>\n</blockquote>\n<p>Spring起到了承上启下的作用。</p>\n<p>弊端： 发展了太久，违背了原来的理念。</p>\n<blockquote>\n<h2 id=\"LC3-Spring-IOC\"><a href=\"#LC3-Spring-IOC\" class=\"headerlink\" title=\"LC3. Spring IOC\"></a>LC3. Spring IOC</h2></blockquote>\n<p>以前写业务</p>\n<ul>\n<li><p>UserDao接口</p>\n</li>\n<li><p>UserDaoImpl实现类(会有多个)</p>\n</li>\n<li><p>UserService 业务接口</p>\n</li>\n<li><p>UserServiceImpl业务实现类(会有多个)</p>\n</li>\n<li><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417104203040.png\" alt=\"image-20230417104203040\"></p>\n</li>\n</ul>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092414541.png\" alt=\"image-20230417092414541\"></p>\n<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。</p>\n<p>改进1：<img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092618282.png\" alt=\"image-20230417092618282\"></p>\n<p>这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。</p>\n<p>也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。<strong>系统的耦合性降低</strong>。</p>\n<h2 id=\"LC4-IOC本质\"><a href=\"#LC4-IOC本质\" class=\"headerlink\" title=\"LC4: IOC本质\"></a>LC4: IOC本质</h2><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417101934817.png\" alt=\"image-20230417101934817\"></p>\n<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。</p>\n<p><strong>控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。</strong></p>\n<blockquote>\n<p><strong>大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可</strong></p>\n</blockquote>\n<h2 id=\"LC5-Bean-Definition-Inheritance-Bean标签的理解\"><a href=\"#LC5-Bean-Definition-Inheritance-Bean标签的理解\" class=\"headerlink\" title=\"LC5: Bean Definition Inheritance (Bean标签的理解)\"></a>LC5: Bean Definition Inheritance (Bean标签的理解)</h2><blockquote>\n<p>“Bean definition can contain a lot of configuration information, including <strong>constructor arguments</strong>, <strong>property values</strong>, and <strong>container-specific information</strong>, such as the <strong>initialization method</strong>, a static factory method name, and so on. “</p>\n</blockquote>\n<p>需要掌握的代码</p>\n<pre><code class=\"java\">ApplicationContext applicationConext = new ClassPathXmlApplicationContext(&quot;BeanName.xml&quot;);\n</code></pre>\n<h2 id=\"LC6-Spring对象的创建\"><a href=\"#LC6-Spring对象的创建\" class=\"headerlink\" title=\"LC6. Spring对象的创建\"></a>LC6. Spring对象的创建</h2><ol>\n<li>Spring容器默认使用无参构造创建对象</li>\n<li>假如需要使用有参构造创建对象， 三种方式 <constructor-arg><ol>\n<li>下标 index</li>\n<li>参数类型 type   -&gt; 不建议使用，多个同类型的参数，会乱。</li>\n<li>直接通过参数名 name.<ul>\n<li>也可以用ref 对象的方法。和通过参数名类似。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。</strong></p>\n<blockquote>\n<p>面试： BeanFactory相关。</p>\n<p>BeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了</p>\n</blockquote>\n<h3 id=\"1-BeanPostProcessor-是什么？\"><a href=\"#1-BeanPostProcessor-是什么？\" class=\"headerlink\" title=\"1.BeanPostProcessor 是什么？\"></a>1.BeanPostProcessor 是什么？</h3><blockquote>\n<p>“The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom <code>BeanPostProcessor</code> implementations.”</p>\n</blockquote>\n<p>首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。</p>\n<h2 id=\"LC7-Spring配置详解\"><a href=\"#LC7-Spring配置详解\" class=\"headerlink\" title=\"LC7. Spring配置详解\"></a>LC7. Spring配置详解</h2><h3 id=\"1-别名\"><a href=\"#1-别名\" class=\"headerlink\" title=\"1. 别名\"></a>1. 别名</h3><p><bean> 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。</p>\n<p>使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。</p>\n<h3 id=\"2-Import\"><a href=\"#2-Import\" class=\"headerlink\" title=\"2. Import\"></a>2. Import</h3><p>将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下</p>\n<pre><code class=\"xml\">&lt;import resource=&quot;beans1.xml&quot;&gt;\n&lt;import resource=&quot;beans2.xml&quot;&gt;    \n&lt;import resource=&quot;beans3.xml&quot;&gt;    \n</code></pre>\n<h2 id=\"LC8-依赖注入\"><a href=\"#LC8-依赖注入\" class=\"headerlink\" title=\"LC8. 依赖注入\"></a>LC8. 依赖注入</h2><h3 id=\"1-构造器注入\"><a href=\"#1-构造器注入\" class=\"headerlink\" title=\"1. 构造器注入\"></a>1. 构造器注入</h3><p>​\t前面讲过了</p>\n<pre><code class=\"xml\">&lt;constructor-arg&gt;\n</code></pre>\n<h3 id=\"2-Set方式注入\"><a href=\"#2-Set方式注入\" class=\"headerlink\" title=\"2. Set方式注入\"></a>2. Set方式注入</h3><blockquote>\n<p>各种数据类型的注入</p>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165807121.png![image-20230417165836555](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165836555.png\" alt=\"image-20230417165807121\"></p>\n</blockquote>\n<h3 id=\"3-拓展方式注入\"><a href=\"#3-拓展方式注入\" class=\"headerlink\" title=\"3. 拓展方式注入\"></a>3. 拓展方式注入</h3><p>命名空间注入：</p>\n<p>比如 p命名空间，直接能够注入property</p>\n<pre><code>&lt;beans id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; p:name=&quot;xxx&quot; p:age=&quot;11&quot;;\n</code></pre>\n<p>以及  c命名空间，其实就是constructor-arg</p>\n<h2 id=\"LC9-Bean的作用域\"><a href=\"#LC9-Bean的作用域\" class=\"headerlink\" title=\"LC9. Bean的作用域\"></a>LC9. Bean的作用域</h2><ol>\n<li>单例模式（默认）</li>\n<li>原型模式</li>\n</ol>\n<h2 id=\"LC10-Bean的自动装配\"><a href=\"#LC10-Bean的自动装配\" class=\"headerlink\" title=\"LC10. Bean的自动装配\"></a>LC10. Bean的自动装配</h2><blockquote>\n<ol>\n<li><strong>如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错</strong></li>\n<li><strong>而byType相反。你bean id想怎么写就怎么写。</strong> 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.</li>\n</ol>\n</blockquote>\n<p>Spring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。</p>\n<p>可以直接去Spring官网复制黏贴代码就可以。节约时间。</p>\n<p>链接： <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config</a></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。</p>\n<p>补充:</p>\n<pre><code>&lt;context:annotation-config/&gt; 隐式的注册了以下的PostProcessors\n\n    ConfigurationClassPostProcessor\n\n    AutowiredAnnotationBeanPostProcessor\n\n    CommonAnnotationBeanPostProcessor\n\n    PersistenceAnnotationBeanPostProcessor\n\n    EventListenerMethodProcessor\n\n</code></pre>\n<h3 id=\"1-Autowired可以用在哪里\"><a href=\"#1-Autowired可以用在哪里\" class=\"headerlink\" title=\"1. Autowired可以用在哪里\"></a>1. Autowired可以用在哪里</h3><ul>\n<li><p>构造器上</p>\n<ul>\n<li><p>注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。</p>\n<pre><code>As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>传统的set方法上</p>\n</li>\n</ul>\n<pre><code class=\"java\">public class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n<ul>\n<li><p>带参的方法上</p>\n<pre><code>public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(MovieCatalog movieCatalog,\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>成员变量和构造方法上</p>\n<pre><code class=\"java\">public class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>如果想让Spring为相同类型的多个bean的话，可以使用数组、集合</p>\n<pre><code>public class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n\n    // ...\n&#125;\n\npublic class MovieRecommender &#123;\n\n    private Set&lt;MovieCatalog&gt; movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n</code></pre>\n</li>\n</ul>\n<h3 id=\"2-Autowire失败条件\"><a href=\"#2-Autowire失败条件\" class=\"headerlink\" title=\"2. Autowire失败条件\"></a>2. Autowire失败条件</h3><blockquote>\n<p>utowiring fails when no matching candidate beans are available for a given injection point.</p>\n</blockquote>\n<h3 id=\"3-Autowiresd-required-false-意思\"><a href=\"#3-Autowiresd-required-false-意思\" class=\"headerlink\" title=\"3. @Autowiresd(required&#x3D; false) 意思\"></a>3. @Autowiresd(required&#x3D; false) 意思</h3><pre><code>In other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.\n</code></pre>\n<p>其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。</p>\n<h3 id=\"4-什么是Qualifier\"><a href=\"#4-什么是Qualifier\" class=\"headerlink\" title=\"4. 什么是Qualifier\"></a>4. 什么是Qualifier</h3><blockquote>\n<p>多个同类型的bean实现autowire的时候使用</p>\n<pre><code class=\"xml\">@AutoWired\n@Qualifier(value=xxx1)\nprivate Dog dog;\n\n\n\n\n&lt;xml ....&gt;\n\n&lt;bean id=&#39;xxx1&#39; class=&quot;dog&quot;&gt;\n&lt;bean id=&quot;xxx&quot;, class = &quot;dog&quot;&gt;\n</code></pre>\n</blockquote>\n<h3 id=\"5-Resource注解\"><a href=\"#5-Resource注解\" class=\"headerlink\" title=\"5. Resource注解\"></a>5. Resource注解</h3><blockquote>\n<p>Javax.annotation.resource</p>\n<p>Ioc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。</p>\n</blockquote>\n<p>引申问题： Resource和Autowire的区别？</p>\n<h2 id=\"LC11-注解开发\"><a href=\"#LC11-注解开发\" class=\"headerlink\" title=\"LC11 注解开发\"></a>LC11 注解开发</h2><p>关键字：@ component</p>\n<p>在spring4之后，需要导入aop包，来开启注解开发。</p>\n<pre><code>spring-aop\n</code></pre>\n<p>流程：</p>\n<ol>\n<li><pre><code class=\"xml\"> &lt;context:annotation-config&gt; \n \n</code></pre>\n</li>\n<li><pre><code class=\"xml\"> &lt;context:component-scan base-package=&quot;com.example.xxx&quot;&gt;\n &lt;!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效--&gt;\n</code></pre>\n</li>\n</ol>\n<p>@component 挂在类上，代表这个类被spring管理了</p>\n<p>@Value挂在变量上面，代表这个变量的值</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\nprivate String name;\n</code></pre>\n<ul>\n<li><p>也可以挂在set方法上。同理</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\npublic void setName(String name)&#123;\n    this.name = name;\n&#125;\n</code></pre>\n</li>\n</ul>\n<p>@Scope，就是决定单例，多例的注解。同样挂在类上。</p>\n<pre><code class=\"java\">@Scope(&quot;prototype&quot;)\n@Scope(&quot;singleton&quot;)\n</code></pre>\n<h3 id=\"components注解的衍生\"><a href=\"#components注解的衍生\" class=\"headerlink\" title=\"@components注解的衍生\"></a>@components注解的衍生</h3><blockquote>\n<p>在web开发中，我们会按照model-view-controller三层架构来分层。</p>\n<ol>\n<li>dao层</li>\n<li>service层</li>\n<li>controller层</li>\n</ol>\n<p><strong>每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。</strong></p>\n</blockquote>\n<h2 id=\"LC12-使用纯Java配置Spring\"><a href=\"#LC12-使用纯Java配置Spring\" class=\"headerlink\" title=\"LC12. 使用纯Java配置Spring\"></a>LC12. 使用纯Java配置Spring</h2><blockquote>\n<p>旨在离开xml配置，只使用java就能完成配置。</p>\n</blockquote>\n<pre><code class=\"java\">//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig &#123;\n\n    @Bean\n    public User getUser()&#123;\n        return new User();\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n    @Value(&quot;anicaa&quot;)\n    private String name;\n\n    public String getName()&#123;\n        return this.name;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(&quot;getUser&quot;);\n        System.out.println(user.getName());\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><p>挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.</p>\n</li>\n<li><p>@ComponentScan(“com.exmaple.xxx”). 挂在config类头上，就是扫描。</p>\n</li>\n<li><p>@Import() 导入别的config类.</p>\n</li>\n</ul>\n<h2 id=\"LC13-AOP\"><a href=\"#LC13-AOP\" class=\"headerlink\" title=\"LC13. AOP\"></a>LC13. AOP</h2><blockquote>\n<p>Spring中比较重要的模式： 代理模式 和 工厂模式</p>\n</blockquote>\n<h3 id=\"设计模式-代理模式（AOP底层）\"><a href=\"#设计模式-代理模式（AOP底层）\" class=\"headerlink\" title=\"设计模式-代理模式（AOP底层）\"></a>设计模式-代理模式（AOP底层）</h3><h4 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. 静态代理</h4><blockquote>\n<p>静态代理的<strong>静态</strong>，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例</p>\n</blockquote>\n<ol>\n<li>User Service接口</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>UserServiceImpl 实现类</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic class UserServiceImpl implements UserService&#123;\n\n\n    @Override\n    public void add() &#123;\n        System.out.println(&quot;添加了&quot;);\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        System.out.println(&quot;删除了&quot;);\n    &#125;\n\n    @Override\n    public void query() &#123;\n        System.out.println(&quot;查询了&quot;);\n    &#125;\n\n    @Override\n    public void update() &#123;\n        System.out.println(&quot;更新了&quot;);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>UserServiceProxy 静态代理类。</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService &#123;\n    private UserServiceImpl userService;\n\n    public UserServiceProxy()&#123;\n\n    &#125;\n\n    public UserServiceProxy(UserServiceImpl userService)&#123;\n        this.userService = userService;\n    &#125;\n\n    @Override\n    public void add() &#123;\n        log(&quot;add&quot;);\n        userService.add();\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        log(&quot;delete&quot;);\n        userService.delete();\n    &#125;\n\n    @Override\n    public void query() &#123;\n        log(&quot;query&quot;);\n        userService.query();\n    &#125;\n\n    @Override\n    public void update() &#123;\n        log(&quot;update&quot;);\n        userService.update();\n    &#125;\n\n    public void log(String str)&#123;\n        System.out.println(&quot;call &quot; + str);\n    &#125;\n&#125;\n</code></pre>\n<p>4.Client 类. 调用了代理，执行接口的放法。</p>\n<pre><code>package com.example.test;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    &#125;\n&#125;\n</code></pre>\n<p>在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。</p>\n<h4 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. 动态代理</h4><blockquote>\n<p>而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。</p>\n<p>在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。</p>\n<p>原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。</p>\n<p>现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler</p>\n<pre><code class=\"java\">setTarget(Object target)\n</code></pre>\n<p>就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类<strong>所对应的接口</strong>，并把这个接口返回给我们。<br>之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。</p>\n</blockquote>\n<ol>\n<li>InvocationHandler</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>Client</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"LC14-Spring-AOP\"><a href=\"#LC14-Spring-AOP\" class=\"headerlink\" title=\"LC14. Spring AOP\"></a>LC14. Spring AOP</h2>"},{"title":"速通TestNG","date":"2023-09-28T01:19:00.000Z","_content":"\n\n# TestNG\n## 1. TestNG官方文档：\n> https://testng.org/doc/documentation-main.html\n\n## 2. 什么是TestNG？\n> TestNG 是一个测试框架。用于unit（单元测试）、integration（集成测试）、end to end（端到端测试）以及function testing（功能测试.\n\n* NG: next generation\n\n* 目前学习TestNG主要还是为了以下几点：\n\n  1. 批量进行测试用例管理和调度执行\n  2. 生成报告。\n  3. 结合PO设计模式进行Web自动化测试\n\n* 博客： https://bbs.huaweicloud.com/blogs/300746\n\n## 3. 第一个Selenium + TestNG测试案例\n\n> 打开谷歌。在搜索栏填入信息，按下enter。\n\n其实写法和JUnit是完全一样的。\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FirstTestNGDemo {\n\n    @Test\n    public void firstTest() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();;\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(\"https://www.google.com\");\n        webDriver.findElement(By.name(\"q\")).sendKeys(\"www.anicaaz.com\", Keys.ENTER);\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n```\n\n### 3.1 默认测试报告\n\n![image-20230928082013863](../img/image-20230928082013863.png)\n\n\n\n![image-20230928082103488](../img/image-20230928082103488.png)\n\n然后就能看到这个文件夹。里面这个emailable-report.html就是报告。\n\n![image-20230928082117273](../img/image-20230928082117273.png)\n\n\n\n\n\n## 小问题：WebDriver成员变量\n\n我们的测试类不可能永远只写一个方法。当存在多个方法时，我们想高效地利用WebDriver，比如保存WebDriver的状态，这样各个method就能衔接起来。\n\n举个例子:\n\n我们要测试登录qq账号以及发消息给好友。那第一个method就是登录。如果没有全局变量，那在登录里我们就要创建WebDriver对象，给url。登录method写完了，当写发消息时，我们得重新创建对象，给对应的url。很麻烦。有人说为什么不把两个方法和在一起，那样就太乱了。一个类不可能永远只写一个代码，这时候就需要将WebDriver设为成员变量。当你登录成功，那WebDriver就是跳转到好友列表时候的状态。这样就不用重新创WebDriver了\n\n> 当然这是当前阶段的小问题。之后不可能这么些，因为这样还是很乱，封装的力度不够。\n\n\n\n## 4. TestNG 常用注解\n\n> 常用after/before Suite、class。after/before Test用的都算少了\n\n下面有这么多，其实都大差不差。\n\n@Before一般用于测试**环境准备**\n\n@After一般用于**测试环境清理**\n\n\n\n那么，我们想，当我们进行测试的时候，打开浏览器这个动作，其实跟测试内容的关系不是很大，是不是就是测试环境的准备？因此，我们可以用@BeforeClass，将其封装起来。\n\n```\n...\n\nprivate WebDriver webDriver;\n@BeforeClass\npublic void openBrowser() {\n\t//窗口、等待...etc..\n\twebDriver.getUrl();\n}\n```\n\n### @Test\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FindWebsite {\n    private WebDriver webDriver;\n\n    @BeforeClass\n    public void openBrowser() {\n        webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n    }\n\n    //搜索www.anicaaz.com, 并判断第一条结果是否为“Kangwei Zhu's Blog: 首页”\n    @Test (priority = 1)\n    public void searchAnicaa() throws InterruptedException {\n        webDriver.get(\"https://www.google.com\");\n        webDriver.findElement(By.name(\"q\")).sendKeys(\"www.anicaaz.com\", Keys.ENTER);\n        System.out.println(webDriver.getTitle());\n        WebElement element = webDriver.findElement(By.xpath(\"//*[@id=\\\"rso\\\"]/div[1]/div/div/div[1]/div/div/span/a/h3\"));\n        String text = element.getText();\n        Assert.assertEquals(text, \"Kangwei Zhu's Blog: 首页\");\n    }\n\n    //跳转到www.anicaaz.com\n    @Test (priority = 2)\n    public void goToWebsite() throws InterruptedException {\n        System.out.println(webDriver.getCurrentUrl());\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"rso\\\"]/div[1]/div/div/div[1]/div/div/span/a/h3\")).click();\n    }\n\n    @AfterClass\n    public void quitBrowser() {\n        webDriver.close();\n    }\n}\n```\n\n在这个demo中，我们有两个**连续**的方法。搜索某网站时，肯定是先输入搜索内容，然后在从搜索结果里点击内容。但是，由于抢占问题，搜索结果这个步骤可能会优先执行，这样永远都是报错。因此，我们可以设置优先级。优先级默认值为0。优先级可以作用在类上，也可以作用在方法上。\n\n如果你的测试不仅仅只是测试能否访问网页，可能还有别的目的的话，记得用Assert。因为可能网页跑通了，testng就认为你通过测试了，但是你的功能其实是有问题的。\n\n此外，涉及到网页跳转的场景时，要注意别忘了隐式/显示等待。因为网页加载需要时间。有时候可能脚本执行得比加载速度快，从而导致找不到元素。\n\n### @BeforeMethod\n\n每个测试方法之前需要执行\n\n### @AfterMethod\n\n每个测试方法之后需要执行\n\n### @BeforeClass\n\n在当前类的第一个测试方法调用之前执行\n\n### @AfterClass\n\n在当前类的最后一个测试方法调用之后执行\n\n### @BeforeTest\n\n在当前类的第一个测试方法调用之前执行\n\n### @AfterTest\n\n在测试之后需要执行的\n\n### @BeforeSuite\n\n在测试之前需要执行的\n\n### @AfterSuite\n\n测试套件在执行之后需要执行的\n\n第二个demo：\n\nclass1: 测试能否登录功能（这里选择谷歌账号）。\n\nclass2： 测试能否获取个人信息。\n\n在这里，如果没有登录。是拿不到个人信息的。因为class2的运行会一直卡在登录页面（class2的```webDriver.get()```内参数是登录之后的主页url）。\n\n要解决这个问题，就需要将class1中的WebDriver设为public static变量，方便调用。但是问题来了。你执行class2的时候，class1不可能一起执行啊。\n\n```java\nclass1：\n\tprivate static WebDrvier webDriver;\n\nclass2:\n\tprivate WebDriver webDriver;\n\t@BeforeClass\n\tpublic void openBrowser() {\n\t\twebDriver = class1.webDriver;\n\t}\n\t\n\t..\n\n```\n\n\n因此WebDriver就变成了空指针。这时候，就需要用到suite来管理这些类了。\n\n在TestNG中，最好一个类管理一个测试用例(具体还是看测试用例有多少），所有类（测试用例），则用suite管理。下面5.1.2会写道。\n\n\n\n## 5. TestNG XML文件\n\n### 1.1 TestNG XML文件的作用\n\nXML是用来写配置的，TestNG的xml也不例外。 \n\n在我们之前写过的所有demo中，每个测试类，大抵都只有一两个测试方法，我们只需要手动执行它。\n\n但是，在项目中，我们通常会有几百上千个类和方法，这种情况下，我们如何去执行，执行哪些，以什么顺序去执行这些测试方法，就成了问题。\n\n通过编写TestNG XML 文件，我们就可以很好的解决这个问题。\n\n### 1.1.1 安装TestNG插件\n\nidea -> plugin -> 搜索create testng xml\n\n### 1.2 编写TestNG XML\n\nxml名字任意，xml文件数量任意。但是通常命名为testng.xml\n\nxml得放在resources里面\n\n> Testng管理层级：\n>\n> suite->test->class->method\n\n* testng.xml骨架\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  \n  <suite>\n      <test>\n          <classes>\n              <class>\n                  <methods>\n                      \n                  </methods>\n              </class>\n          </classes>\n      </test>\n  </suite>\n  ```\n\n  当然，手写很麻烦，可以直接通过testng插件生成。\n\n### 1.3 XML DEMO\n\n改造一下findWebsite，创建两个类。一个findWebiste，查找并进入www.anicaaz.com.另一个类findBlog，点击博客第一条。\n\nFindWebsite改动\n\n![image-20230928213416192](../img/image-20230928213416192.png)\n\n\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\npublic class FindBlog {\n\n    private WebDriver webDriver;\n\n\n    @BeforeClass\n    public void setWebDriver() {\n        webDriver = FindWebsite.webDriver;\n    }\n\n    @Test\n    public void findBlog() {\n        webDriver.findElement(By.xpath(\"/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div[1]/div/div[2]/a/h1\")).click();\n        String text = webDriver.findElement(By.xpath(\"/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div/h1\")).getText();\n        Assert.assertEquals(text, \"速通TestNG\");\n    }\n\n    @AfterClass\n    public void closeWebDriver() {\n        webDriver.close();\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE suite SYSTEM \"http://testng.org/testng-1.0.dtd\">\n<suite name=\"All Test Suite\">\n    <test verbose=\"2\" preserve-order=\"true\"\n          name=\"查找网站\">\n        <classes>\n            <class name=\"FindWebsite\">\n                <methods>\n                    <include name=\"searchAnicaa\"/>\n                    <include name=\"goToWebsite\"/>\n                </methods>\n            </class>\n        </classes>\n    </test>\n    <test verbose=\"2\" preserve-order=\"true\"\n          name=\"查找博客首页第一篇博客\">\n        <classes>\n            <class name=\"FindBlog\">\n                <methods>\n                    <include name=\"findBlog\"/>\n                </methods>\n            </class>\n        </classes>\n    </test>\n</suite>\n```\n\n![image-20230928213811991](../img/image-20230928213811991.png)\n\n把Assert内容随便乱改点，就可以看到成功的报错了。\n\n![image-20230928213734939](../img/image-20230928213734939.png)\n\n\n\n## 6. PO模式与TestNG\n\n其实就是把页面当成一个对象来看。一个类，对应一个页面。\n\nPO： Page Object\n\n抽象对象：\n\n1. 属性： url 元素（元素定位表达式）\n2. 方法： 业务流程操作。\n\n高内聚: 页面属性放一块\n\n低耦合：不同页面通过webDriver来传递\n\n\n\n","source":"_posts/TestNG学习.md","raw":"---\ntitle: 速通TestNG\ndate: 2023-9-27 21:19:00\ntags:\n    - TestNG\n\ncategories:\n    - 软件测试\n---\n\n\n# TestNG\n## 1. TestNG官方文档：\n> https://testng.org/doc/documentation-main.html\n\n## 2. 什么是TestNG？\n> TestNG 是一个测试框架。用于unit（单元测试）、integration（集成测试）、end to end（端到端测试）以及function testing（功能测试.\n\n* NG: next generation\n\n* 目前学习TestNG主要还是为了以下几点：\n\n  1. 批量进行测试用例管理和调度执行\n  2. 生成报告。\n  3. 结合PO设计模式进行Web自动化测试\n\n* 博客： https://bbs.huaweicloud.com/blogs/300746\n\n## 3. 第一个Selenium + TestNG测试案例\n\n> 打开谷歌。在搜索栏填入信息，按下enter。\n\n其实写法和JUnit是完全一样的。\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FirstTestNGDemo {\n\n    @Test\n    public void firstTest() throws InterruptedException{\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();;\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(\"https://www.google.com\");\n        webDriver.findElement(By.name(\"q\")).sendKeys(\"www.anicaaz.com\", Keys.ENTER);\n        Thread.sleep(5000);\n        webDriver.quit();\n    }\n}\n```\n\n### 3.1 默认测试报告\n\n![image-20230928082013863](../img/image-20230928082013863.png)\n\n\n\n![image-20230928082103488](../img/image-20230928082103488.png)\n\n然后就能看到这个文件夹。里面这个emailable-report.html就是报告。\n\n![image-20230928082117273](../img/image-20230928082117273.png)\n\n\n\n\n\n## 小问题：WebDriver成员变量\n\n我们的测试类不可能永远只写一个方法。当存在多个方法时，我们想高效地利用WebDriver，比如保存WebDriver的状态，这样各个method就能衔接起来。\n\n举个例子:\n\n我们要测试登录qq账号以及发消息给好友。那第一个method就是登录。如果没有全局变量，那在登录里我们就要创建WebDriver对象，给url。登录method写完了，当写发消息时，我们得重新创建对象，给对应的url。很麻烦。有人说为什么不把两个方法和在一起，那样就太乱了。一个类不可能永远只写一个代码，这时候就需要将WebDriver设为成员变量。当你登录成功，那WebDriver就是跳转到好友列表时候的状态。这样就不用重新创WebDriver了\n\n> 当然这是当前阶段的小问题。之后不可能这么些，因为这样还是很乱，封装的力度不够。\n\n\n\n## 4. TestNG 常用注解\n\n> 常用after/before Suite、class。after/before Test用的都算少了\n\n下面有这么多，其实都大差不差。\n\n@Before一般用于测试**环境准备**\n\n@After一般用于**测试环境清理**\n\n\n\n那么，我们想，当我们进行测试的时候，打开浏览器这个动作，其实跟测试内容的关系不是很大，是不是就是测试环境的准备？因此，我们可以用@BeforeClass，将其封装起来。\n\n```\n...\n\nprivate WebDriver webDriver;\n@BeforeClass\npublic void openBrowser() {\n\t//窗口、等待...etc..\n\twebDriver.getUrl();\n}\n```\n\n### @Test\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FindWebsite {\n    private WebDriver webDriver;\n\n    @BeforeClass\n    public void openBrowser() {\n        webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n    }\n\n    //搜索www.anicaaz.com, 并判断第一条结果是否为“Kangwei Zhu's Blog: 首页”\n    @Test (priority = 1)\n    public void searchAnicaa() throws InterruptedException {\n        webDriver.get(\"https://www.google.com\");\n        webDriver.findElement(By.name(\"q\")).sendKeys(\"www.anicaaz.com\", Keys.ENTER);\n        System.out.println(webDriver.getTitle());\n        WebElement element = webDriver.findElement(By.xpath(\"//*[@id=\\\"rso\\\"]/div[1]/div/div/div[1]/div/div/span/a/h3\"));\n        String text = element.getText();\n        Assert.assertEquals(text, \"Kangwei Zhu's Blog: 首页\");\n    }\n\n    //跳转到www.anicaaz.com\n    @Test (priority = 2)\n    public void goToWebsite() throws InterruptedException {\n        System.out.println(webDriver.getCurrentUrl());\n        webDriver.findElement(By.xpath(\"//*[@id=\\\"rso\\\"]/div[1]/div/div/div[1]/div/div/span/a/h3\")).click();\n    }\n\n    @AfterClass\n    public void quitBrowser() {\n        webDriver.close();\n    }\n}\n```\n\n在这个demo中，我们有两个**连续**的方法。搜索某网站时，肯定是先输入搜索内容，然后在从搜索结果里点击内容。但是，由于抢占问题，搜索结果这个步骤可能会优先执行，这样永远都是报错。因此，我们可以设置优先级。优先级默认值为0。优先级可以作用在类上，也可以作用在方法上。\n\n如果你的测试不仅仅只是测试能否访问网页，可能还有别的目的的话，记得用Assert。因为可能网页跑通了，testng就认为你通过测试了，但是你的功能其实是有问题的。\n\n此外，涉及到网页跳转的场景时，要注意别忘了隐式/显示等待。因为网页加载需要时间。有时候可能脚本执行得比加载速度快，从而导致找不到元素。\n\n### @BeforeMethod\n\n每个测试方法之前需要执行\n\n### @AfterMethod\n\n每个测试方法之后需要执行\n\n### @BeforeClass\n\n在当前类的第一个测试方法调用之前执行\n\n### @AfterClass\n\n在当前类的最后一个测试方法调用之后执行\n\n### @BeforeTest\n\n在当前类的第一个测试方法调用之前执行\n\n### @AfterTest\n\n在测试之后需要执行的\n\n### @BeforeSuite\n\n在测试之前需要执行的\n\n### @AfterSuite\n\n测试套件在执行之后需要执行的\n\n第二个demo：\n\nclass1: 测试能否登录功能（这里选择谷歌账号）。\n\nclass2： 测试能否获取个人信息。\n\n在这里，如果没有登录。是拿不到个人信息的。因为class2的运行会一直卡在登录页面（class2的```webDriver.get()```内参数是登录之后的主页url）。\n\n要解决这个问题，就需要将class1中的WebDriver设为public static变量，方便调用。但是问题来了。你执行class2的时候，class1不可能一起执行啊。\n\n```java\nclass1：\n\tprivate static WebDrvier webDriver;\n\nclass2:\n\tprivate WebDriver webDriver;\n\t@BeforeClass\n\tpublic void openBrowser() {\n\t\twebDriver = class1.webDriver;\n\t}\n\t\n\t..\n\n```\n\n\n因此WebDriver就变成了空指针。这时候，就需要用到suite来管理这些类了。\n\n在TestNG中，最好一个类管理一个测试用例(具体还是看测试用例有多少），所有类（测试用例），则用suite管理。下面5.1.2会写道。\n\n\n\n## 5. TestNG XML文件\n\n### 1.1 TestNG XML文件的作用\n\nXML是用来写配置的，TestNG的xml也不例外。 \n\n在我们之前写过的所有demo中，每个测试类，大抵都只有一两个测试方法，我们只需要手动执行它。\n\n但是，在项目中，我们通常会有几百上千个类和方法，这种情况下，我们如何去执行，执行哪些，以什么顺序去执行这些测试方法，就成了问题。\n\n通过编写TestNG XML 文件，我们就可以很好的解决这个问题。\n\n### 1.1.1 安装TestNG插件\n\nidea -> plugin -> 搜索create testng xml\n\n### 1.2 编写TestNG XML\n\nxml名字任意，xml文件数量任意。但是通常命名为testng.xml\n\nxml得放在resources里面\n\n> Testng管理层级：\n>\n> suite->test->class->method\n\n* testng.xml骨架\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  \n  <suite>\n      <test>\n          <classes>\n              <class>\n                  <methods>\n                      \n                  </methods>\n              </class>\n          </classes>\n      </test>\n  </suite>\n  ```\n\n  当然，手写很麻烦，可以直接通过testng插件生成。\n\n### 1.3 XML DEMO\n\n改造一下findWebsite，创建两个类。一个findWebiste，查找并进入www.anicaaz.com.另一个类findBlog，点击博客第一条。\n\nFindWebsite改动\n\n![image-20230928213416192](../img/image-20230928213416192.png)\n\n\n\n```java\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\npublic class FindBlog {\n\n    private WebDriver webDriver;\n\n\n    @BeforeClass\n    public void setWebDriver() {\n        webDriver = FindWebsite.webDriver;\n    }\n\n    @Test\n    public void findBlog() {\n        webDriver.findElement(By.xpath(\"/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div[1]/div/div[2]/a/h1\")).click();\n        String text = webDriver.findElement(By.xpath(\"/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div/h1\")).getText();\n        Assert.assertEquals(text, \"速通TestNG\");\n    }\n\n    @AfterClass\n    public void closeWebDriver() {\n        webDriver.close();\n    }\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE suite SYSTEM \"http://testng.org/testng-1.0.dtd\">\n<suite name=\"All Test Suite\">\n    <test verbose=\"2\" preserve-order=\"true\"\n          name=\"查找网站\">\n        <classes>\n            <class name=\"FindWebsite\">\n                <methods>\n                    <include name=\"searchAnicaa\"/>\n                    <include name=\"goToWebsite\"/>\n                </methods>\n            </class>\n        </classes>\n    </test>\n    <test verbose=\"2\" preserve-order=\"true\"\n          name=\"查找博客首页第一篇博客\">\n        <classes>\n            <class name=\"FindBlog\">\n                <methods>\n                    <include name=\"findBlog\"/>\n                </methods>\n            </class>\n        </classes>\n    </test>\n</suite>\n```\n\n![image-20230928213811991](../img/image-20230928213811991.png)\n\n把Assert内容随便乱改点，就可以看到成功的报错了。\n\n![image-20230928213734939](../img/image-20230928213734939.png)\n\n\n\n## 6. PO模式与TestNG\n\n其实就是把页面当成一个对象来看。一个类，对应一个页面。\n\nPO： Page Object\n\n抽象对象：\n\n1. 属性： url 元素（元素定位表达式）\n2. 方法： 业务流程操作。\n\n高内聚: 页面属性放一块\n\n低耦合：不同页面通过webDriver来传递\n\n\n\n","slug":"TestNG学习","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"cln44k4un0006awhzcq6mbvan","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"TestNG\"><a href=\"#TestNG\" class=\"headerlink\" title=\"TestNG\"></a>TestNG</h1><h2 id=\"1-TestNG官方文档：\"><a href=\"#1-TestNG官方文档：\" class=\"headerlink\" title=\"1. TestNG官方文档：\"></a>1. TestNG官方文档：</h2><blockquote>\n<p><a href=\"https://testng.org/doc/documentation-main.html\">https://testng.org/doc/documentation-main.html</a></p>\n</blockquote>\n<h2 id=\"2-什么是TestNG？\"><a href=\"#2-什么是TestNG？\" class=\"headerlink\" title=\"2. 什么是TestNG？\"></a>2. 什么是TestNG？</h2><blockquote>\n<p>TestNG 是一个测试框架。用于unit（单元测试）、integration（集成测试）、end to end（端到端测试）以及function testing（功能测试.</p>\n</blockquote>\n<ul>\n<li><p>NG: next generation</p>\n</li>\n<li><p>目前学习TestNG主要还是为了以下几点：</p>\n<ol>\n<li>批量进行测试用例管理和调度执行</li>\n<li>生成报告。</li>\n<li>结合PO设计模式进行Web自动化测试</li>\n</ol>\n</li>\n<li><p>博客： <a href=\"https://bbs.huaweicloud.com/blogs/300746\">https://bbs.huaweicloud.com/blogs/300746</a></p>\n</li>\n</ul>\n<h2 id=\"3-第一个Selenium-TestNG测试案例\"><a href=\"#3-第一个Selenium-TestNG测试案例\" class=\"headerlink\" title=\"3. 第一个Selenium + TestNG测试案例\"></a>3. 第一个Selenium + TestNG测试案例</h2><blockquote>\n<p>打开谷歌。在搜索栏填入信息，按下enter。</p>\n</blockquote>\n<p>其实写法和JUnit是完全一样的。</p>\n<pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FirstTestNGDemo &#123;\n\n    @Test\n    public void firstTest() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();;\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-1-默认测试报告\"><a href=\"#3-1-默认测试报告\" class=\"headerlink\" title=\"3.1 默认测试报告\"></a>3.1 默认测试报告</h3><p><img src=\"/../img/image-20230928082013863.png\" alt=\"image-20230928082013863\"></p>\n<p><img src=\"/../img/image-20230928082103488.png\" alt=\"image-20230928082103488\"></p>\n<p>然后就能看到这个文件夹。里面这个emailable-report.html就是报告。</p>\n<p><img src=\"/../img/image-20230928082117273.png\" alt=\"image-20230928082117273\"></p>\n<h2 id=\"小问题：WebDriver成员变量\"><a href=\"#小问题：WebDriver成员变量\" class=\"headerlink\" title=\"小问题：WebDriver成员变量\"></a>小问题：WebDriver成员变量</h2><p>我们的测试类不可能永远只写一个方法。当存在多个方法时，我们想高效地利用WebDriver，比如保存WebDriver的状态，这样各个method就能衔接起来。</p>\n<p>举个例子:</p>\n<p>我们要测试登录qq账号以及发消息给好友。那第一个method就是登录。如果没有全局变量，那在登录里我们就要创建WebDriver对象，给url。登录method写完了，当写发消息时，我们得重新创建对象，给对应的url。很麻烦。有人说为什么不把两个方法和在一起，那样就太乱了。一个类不可能永远只写一个代码，这时候就需要将WebDriver设为成员变量。当你登录成功，那WebDriver就是跳转到好友列表时候的状态。这样就不用重新创WebDriver了</p>\n<blockquote>\n<p>当然这是当前阶段的小问题。之后不可能这么些，因为这样还是很乱，封装的力度不够。</p>\n</blockquote>\n<h2 id=\"4-TestNG-常用注解\"><a href=\"#4-TestNG-常用注解\" class=\"headerlink\" title=\"4. TestNG 常用注解\"></a>4. TestNG 常用注解</h2><blockquote>\n<p>常用after&#x2F;before Suite、class。after&#x2F;before Test用的都算少了</p>\n</blockquote>\n<p>下面有这么多，其实都大差不差。</p>\n<p>@Before一般用于测试<strong>环境准备</strong></p>\n<p>@After一般用于<strong>测试环境清理</strong></p>\n<p>那么，我们想，当我们进行测试的时候，打开浏览器这个动作，其实跟测试内容的关系不是很大，是不是就是测试环境的准备？因此，我们可以用@BeforeClass，将其封装起来。</p>\n<pre><code>...\n\nprivate WebDriver webDriver;\n@BeforeClass\npublic void openBrowser() &#123;\n    //窗口、等待...etc..\n    webDriver.getUrl();\n&#125;\n</code></pre>\n<h3 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"@Test\"></a>@Test</h3><pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FindWebsite &#123;\n    private WebDriver webDriver;\n\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n    &#125;\n\n    //搜索www.anicaaz.com, 并判断第一条结果是否为“Kangwei Zhu&#39;s Blog: 首页”\n    @Test (priority = 1)\n    public void searchAnicaa() throws InterruptedException &#123;\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        System.out.println(webDriver.getTitle());\n        WebElement element = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;));\n        String text = element.getText();\n        Assert.assertEquals(text, &quot;Kangwei Zhu&#39;s Blog: 首页&quot;);\n    &#125;\n\n    //跳转到www.anicaaz.com\n    @Test (priority = 2)\n    public void goToWebsite() throws InterruptedException &#123;\n        System.out.println(webDriver.getCurrentUrl());\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;)).click();\n    &#125;\n\n    @AfterClass\n    public void quitBrowser() &#123;\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>在这个demo中，我们有两个<strong>连续</strong>的方法。搜索某网站时，肯定是先输入搜索内容，然后在从搜索结果里点击内容。但是，由于抢占问题，搜索结果这个步骤可能会优先执行，这样永远都是报错。因此，我们可以设置优先级。优先级默认值为0。优先级可以作用在类上，也可以作用在方法上。</p>\n<p>如果你的测试不仅仅只是测试能否访问网页，可能还有别的目的的话，记得用Assert。因为可能网页跑通了，testng就认为你通过测试了，但是你的功能其实是有问题的。</p>\n<p>此外，涉及到网页跳转的场景时，要注意别忘了隐式&#x2F;显示等待。因为网页加载需要时间。有时候可能脚本执行得比加载速度快，从而导致找不到元素。</p>\n<h3 id=\"BeforeMethod\"><a href=\"#BeforeMethod\" class=\"headerlink\" title=\"@BeforeMethod\"></a>@BeforeMethod</h3><p>每个测试方法之前需要执行</p>\n<h3 id=\"AfterMethod\"><a href=\"#AfterMethod\" class=\"headerlink\" title=\"@AfterMethod\"></a>@AfterMethod</h3><p>每个测试方法之后需要执行</p>\n<h3 id=\"BeforeClass\"><a href=\"#BeforeClass\" class=\"headerlink\" title=\"@BeforeClass\"></a>@BeforeClass</h3><p>在当前类的第一个测试方法调用之前执行</p>\n<h3 id=\"AfterClass\"><a href=\"#AfterClass\" class=\"headerlink\" title=\"@AfterClass\"></a>@AfterClass</h3><p>在当前类的最后一个测试方法调用之后执行</p>\n<h3 id=\"BeforeTest\"><a href=\"#BeforeTest\" class=\"headerlink\" title=\"@BeforeTest\"></a>@BeforeTest</h3><p>在当前类的第一个测试方法调用之前执行</p>\n<h3 id=\"AfterTest\"><a href=\"#AfterTest\" class=\"headerlink\" title=\"@AfterTest\"></a>@AfterTest</h3><p>在测试之后需要执行的</p>\n<h3 id=\"BeforeSuite\"><a href=\"#BeforeSuite\" class=\"headerlink\" title=\"@BeforeSuite\"></a>@BeforeSuite</h3><p>在测试之前需要执行的</p>\n<h3 id=\"AfterSuite\"><a href=\"#AfterSuite\" class=\"headerlink\" title=\"@AfterSuite\"></a>@AfterSuite</h3><p>测试套件在执行之后需要执行的</p>\n<p>第二个demo：</p>\n<p>class1: 测试能否登录功能（这里选择谷歌账号）。</p>\n<p>class2： 测试能否获取个人信息。</p>\n<p>在这里，如果没有登录。是拿不到个人信息的。因为class2的运行会一直卡在登录页面（class2的<code>webDriver.get()</code>内参数是登录之后的主页url）。</p>\n<p>要解决这个问题，就需要将class1中的WebDriver设为public static变量，方便调用。但是问题来了。你执行class2的时候，class1不可能一起执行啊。</p>\n<pre><code class=\"java\">class1：\n    private static WebDrvier webDriver;\n\nclass2:\n    private WebDriver webDriver;\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = class1.webDriver;\n    &#125;\n    \n    ..\n</code></pre>\n<p>因此WebDriver就变成了空指针。这时候，就需要用到suite来管理这些类了。</p>\n<p>在TestNG中，最好一个类管理一个测试用例(具体还是看测试用例有多少），所有类（测试用例），则用suite管理。下面5.1.2会写道。</p>\n<h2 id=\"5-TestNG-XML文件\"><a href=\"#5-TestNG-XML文件\" class=\"headerlink\" title=\"5. TestNG XML文件\"></a>5. TestNG XML文件</h2><h3 id=\"1-1-TestNG-XML文件的作用\"><a href=\"#1-1-TestNG-XML文件的作用\" class=\"headerlink\" title=\"1.1 TestNG XML文件的作用\"></a>1.1 TestNG XML文件的作用</h3><p>XML是用来写配置的，TestNG的xml也不例外。 </p>\n<p>在我们之前写过的所有demo中，每个测试类，大抵都只有一两个测试方法，我们只需要手动执行它。</p>\n<p>但是，在项目中，我们通常会有几百上千个类和方法，这种情况下，我们如何去执行，执行哪些，以什么顺序去执行这些测试方法，就成了问题。</p>\n<p>通过编写TestNG XML 文件，我们就可以很好的解决这个问题。</p>\n<h3 id=\"1-1-1-安装TestNG插件\"><a href=\"#1-1-1-安装TestNG插件\" class=\"headerlink\" title=\"1.1.1 安装TestNG插件\"></a>1.1.1 安装TestNG插件</h3><p>idea -&gt; plugin -&gt; 搜索create testng xml</p>\n<h3 id=\"1-2-编写TestNG-XML\"><a href=\"#1-2-编写TestNG-XML\" class=\"headerlink\" title=\"1.2 编写TestNG XML\"></a>1.2 编写TestNG XML</h3><p>xml名字任意，xml文件数量任意。但是通常命名为testng.xml</p>\n<p>xml得放在resources里面</p>\n<blockquote>\n<p>Testng管理层级：</p>\n<p>suite-&gt;test-&gt;class-&gt;method</p>\n</blockquote>\n<ul>\n<li><p>testng.xml骨架</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;suite&gt;\n    &lt;test&gt;\n        &lt;classes&gt;\n            &lt;class&gt;\n                &lt;methods&gt;\n                    \n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;\n</code></pre>\n<p>当然，手写很麻烦，可以直接通过testng插件生成。</p>\n</li>\n</ul>\n<h3 id=\"1-3-XML-DEMO\"><a href=\"#1-3-XML-DEMO\" class=\"headerlink\" title=\"1.3 XML DEMO\"></a>1.3 XML DEMO</h3><p>改造一下findWebsite，创建两个类。一个findWebiste，查找并进入<a href=\"http://www.anicaaz.com.另一个类findblog,点击博客第一条./\">www.anicaaz.com.另一个类findBlog，点击博客第一条。</a></p>\n<p>FindWebsite改动</p>\n<p><img src=\"/../img/image-20230928213416192.png\" alt=\"image-20230928213416192\"></p>\n<pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\npublic class FindBlog &#123;\n\n    private WebDriver webDriver;\n\n\n    @BeforeClass\n    public void setWebDriver() &#123;\n        webDriver = FindWebsite.webDriver;\n    &#125;\n\n    @Test\n    public void findBlog() &#123;\n        webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div[1]/div/div[2]/a/h1&quot;)).click();\n        String text = webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div/h1&quot;)).getText();\n        Assert.assertEquals(text, &quot;速通TestNG&quot;);\n    &#125;\n\n    @AfterClass\n    public void closeWebDriver() &#123;\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;\n&lt;suite name=&quot;All Test Suite&quot;&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找网站&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindWebsite&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;searchAnicaa&quot;/&gt;\n                    &lt;include name=&quot;goToWebsite&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找博客首页第一篇博客&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindBlog&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;findBlog&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;\n</code></pre>\n<p><img src=\"/../img/image-20230928213811991.png\" alt=\"image-20230928213811991\"></p>\n<p>把Assert内容随便乱改点，就可以看到成功的报错了。</p>\n<p><img src=\"/../img/image-20230928213734939.png\" alt=\"image-20230928213734939\"></p>\n<h2 id=\"6-PO模式与TestNG\"><a href=\"#6-PO模式与TestNG\" class=\"headerlink\" title=\"6. PO模式与TestNG\"></a>6. PO模式与TestNG</h2><p>其实就是把页面当成一个对象来看。一个类，对应一个页面。</p>\n<p>PO： Page Object</p>\n<p>抽象对象：</p>\n<ol>\n<li>属性： url 元素（元素定位表达式）</li>\n<li>方法： 业务流程操作。</li>\n</ol>\n<p>高内聚: 页面属性放一块</p>\n<p>低耦合：不同页面通过webDriver来传递</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TestNG\"><a href=\"#TestNG\" class=\"headerlink\" title=\"TestNG\"></a>TestNG</h1><h2 id=\"1-TestNG官方文档：\"><a href=\"#1-TestNG官方文档：\" class=\"headerlink\" title=\"1. TestNG官方文档：\"></a>1. TestNG官方文档：</h2><blockquote>\n<p><a href=\"https://testng.org/doc/documentation-main.html\">https://testng.org/doc/documentation-main.html</a></p>\n</blockquote>\n<h2 id=\"2-什么是TestNG？\"><a href=\"#2-什么是TestNG？\" class=\"headerlink\" title=\"2. 什么是TestNG？\"></a>2. 什么是TestNG？</h2><blockquote>\n<p>TestNG 是一个测试框架。用于unit（单元测试）、integration（集成测试）、end to end（端到端测试）以及function testing（功能测试.</p>\n</blockquote>\n<ul>\n<li><p>NG: next generation</p>\n</li>\n<li><p>目前学习TestNG主要还是为了以下几点：</p>\n<ol>\n<li>批量进行测试用例管理和调度执行</li>\n<li>生成报告。</li>\n<li>结合PO设计模式进行Web自动化测试</li>\n</ol>\n</li>\n<li><p>博客： <a href=\"https://bbs.huaweicloud.com/blogs/300746\">https://bbs.huaweicloud.com/blogs/300746</a></p>\n</li>\n</ul>\n<h2 id=\"3-第一个Selenium-TestNG测试案例\"><a href=\"#3-第一个Selenium-TestNG测试案例\" class=\"headerlink\" title=\"3. 第一个Selenium + TestNG测试案例\"></a>3. 第一个Selenium + TestNG测试案例</h2><blockquote>\n<p>打开谷歌。在搜索栏填入信息，按下enter。</p>\n</blockquote>\n<p>其实写法和JUnit是完全一样的。</p>\n<pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FirstTestNGDemo &#123;\n\n    @Test\n    public void firstTest() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();;\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-1-默认测试报告\"><a href=\"#3-1-默认测试报告\" class=\"headerlink\" title=\"3.1 默认测试报告\"></a>3.1 默认测试报告</h3><p><img src=\"/../img/image-20230928082013863.png\" alt=\"image-20230928082013863\"></p>\n<p><img src=\"/../img/image-20230928082103488.png\" alt=\"image-20230928082103488\"></p>\n<p>然后就能看到这个文件夹。里面这个emailable-report.html就是报告。</p>\n<p><img src=\"/../img/image-20230928082117273.png\" alt=\"image-20230928082117273\"></p>\n<h2 id=\"小问题：WebDriver成员变量\"><a href=\"#小问题：WebDriver成员变量\" class=\"headerlink\" title=\"小问题：WebDriver成员变量\"></a>小问题：WebDriver成员变量</h2><p>我们的测试类不可能永远只写一个方法。当存在多个方法时，我们想高效地利用WebDriver，比如保存WebDriver的状态，这样各个method就能衔接起来。</p>\n<p>举个例子:</p>\n<p>我们要测试登录qq账号以及发消息给好友。那第一个method就是登录。如果没有全局变量，那在登录里我们就要创建WebDriver对象，给url。登录method写完了，当写发消息时，我们得重新创建对象，给对应的url。很麻烦。有人说为什么不把两个方法和在一起，那样就太乱了。一个类不可能永远只写一个代码，这时候就需要将WebDriver设为成员变量。当你登录成功，那WebDriver就是跳转到好友列表时候的状态。这样就不用重新创WebDriver了</p>\n<blockquote>\n<p>当然这是当前阶段的小问题。之后不可能这么些，因为这样还是很乱，封装的力度不够。</p>\n</blockquote>\n<h2 id=\"4-TestNG-常用注解\"><a href=\"#4-TestNG-常用注解\" class=\"headerlink\" title=\"4. TestNG 常用注解\"></a>4. TestNG 常用注解</h2><blockquote>\n<p>常用after&#x2F;before Suite、class。after&#x2F;before Test用的都算少了</p>\n</blockquote>\n<p>下面有这么多，其实都大差不差。</p>\n<p>@Before一般用于测试<strong>环境准备</strong></p>\n<p>@After一般用于<strong>测试环境清理</strong></p>\n<p>那么，我们想，当我们进行测试的时候，打开浏览器这个动作，其实跟测试内容的关系不是很大，是不是就是测试环境的准备？因此，我们可以用@BeforeClass，将其封装起来。</p>\n<pre><code>...\n\nprivate WebDriver webDriver;\n@BeforeClass\npublic void openBrowser() &#123;\n    //窗口、等待...etc..\n    webDriver.getUrl();\n&#125;\n</code></pre>\n<h3 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"@Test\"></a>@Test</h3><pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FindWebsite &#123;\n    private WebDriver webDriver;\n\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n    &#125;\n\n    //搜索www.anicaaz.com, 并判断第一条结果是否为“Kangwei Zhu&#39;s Blog: 首页”\n    @Test (priority = 1)\n    public void searchAnicaa() throws InterruptedException &#123;\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        System.out.println(webDriver.getTitle());\n        WebElement element = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;));\n        String text = element.getText();\n        Assert.assertEquals(text, &quot;Kangwei Zhu&#39;s Blog: 首页&quot;);\n    &#125;\n\n    //跳转到www.anicaaz.com\n    @Test (priority = 2)\n    public void goToWebsite() throws InterruptedException &#123;\n        System.out.println(webDriver.getCurrentUrl());\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;)).click();\n    &#125;\n\n    @AfterClass\n    public void quitBrowser() &#123;\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>在这个demo中，我们有两个<strong>连续</strong>的方法。搜索某网站时，肯定是先输入搜索内容，然后在从搜索结果里点击内容。但是，由于抢占问题，搜索结果这个步骤可能会优先执行，这样永远都是报错。因此，我们可以设置优先级。优先级默认值为0。优先级可以作用在类上，也可以作用在方法上。</p>\n<p>如果你的测试不仅仅只是测试能否访问网页，可能还有别的目的的话，记得用Assert。因为可能网页跑通了，testng就认为你通过测试了，但是你的功能其实是有问题的。</p>\n<p>此外，涉及到网页跳转的场景时，要注意别忘了隐式&#x2F;显示等待。因为网页加载需要时间。有时候可能脚本执行得比加载速度快，从而导致找不到元素。</p>\n<h3 id=\"BeforeMethod\"><a href=\"#BeforeMethod\" class=\"headerlink\" title=\"@BeforeMethod\"></a>@BeforeMethod</h3><p>每个测试方法之前需要执行</p>\n<h3 id=\"AfterMethod\"><a href=\"#AfterMethod\" class=\"headerlink\" title=\"@AfterMethod\"></a>@AfterMethod</h3><p>每个测试方法之后需要执行</p>\n<h3 id=\"BeforeClass\"><a href=\"#BeforeClass\" class=\"headerlink\" title=\"@BeforeClass\"></a>@BeforeClass</h3><p>在当前类的第一个测试方法调用之前执行</p>\n<h3 id=\"AfterClass\"><a href=\"#AfterClass\" class=\"headerlink\" title=\"@AfterClass\"></a>@AfterClass</h3><p>在当前类的最后一个测试方法调用之后执行</p>\n<h3 id=\"BeforeTest\"><a href=\"#BeforeTest\" class=\"headerlink\" title=\"@BeforeTest\"></a>@BeforeTest</h3><p>在当前类的第一个测试方法调用之前执行</p>\n<h3 id=\"AfterTest\"><a href=\"#AfterTest\" class=\"headerlink\" title=\"@AfterTest\"></a>@AfterTest</h3><p>在测试之后需要执行的</p>\n<h3 id=\"BeforeSuite\"><a href=\"#BeforeSuite\" class=\"headerlink\" title=\"@BeforeSuite\"></a>@BeforeSuite</h3><p>在测试之前需要执行的</p>\n<h3 id=\"AfterSuite\"><a href=\"#AfterSuite\" class=\"headerlink\" title=\"@AfterSuite\"></a>@AfterSuite</h3><p>测试套件在执行之后需要执行的</p>\n<p>第二个demo：</p>\n<p>class1: 测试能否登录功能（这里选择谷歌账号）。</p>\n<p>class2： 测试能否获取个人信息。</p>\n<p>在这里，如果没有登录。是拿不到个人信息的。因为class2的运行会一直卡在登录页面（class2的<code>webDriver.get()</code>内参数是登录之后的主页url）。</p>\n<p>要解决这个问题，就需要将class1中的WebDriver设为public static变量，方便调用。但是问题来了。你执行class2的时候，class1不可能一起执行啊。</p>\n<pre><code class=\"java\">class1：\n    private static WebDrvier webDriver;\n\nclass2:\n    private WebDriver webDriver;\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = class1.webDriver;\n    &#125;\n    \n    ..\n</code></pre>\n<p>因此WebDriver就变成了空指针。这时候，就需要用到suite来管理这些类了。</p>\n<p>在TestNG中，最好一个类管理一个测试用例(具体还是看测试用例有多少），所有类（测试用例），则用suite管理。下面5.1.2会写道。</p>\n<h2 id=\"5-TestNG-XML文件\"><a href=\"#5-TestNG-XML文件\" class=\"headerlink\" title=\"5. TestNG XML文件\"></a>5. TestNG XML文件</h2><h3 id=\"1-1-TestNG-XML文件的作用\"><a href=\"#1-1-TestNG-XML文件的作用\" class=\"headerlink\" title=\"1.1 TestNG XML文件的作用\"></a>1.1 TestNG XML文件的作用</h3><p>XML是用来写配置的，TestNG的xml也不例外。 </p>\n<p>在我们之前写过的所有demo中，每个测试类，大抵都只有一两个测试方法，我们只需要手动执行它。</p>\n<p>但是，在项目中，我们通常会有几百上千个类和方法，这种情况下，我们如何去执行，执行哪些，以什么顺序去执行这些测试方法，就成了问题。</p>\n<p>通过编写TestNG XML 文件，我们就可以很好的解决这个问题。</p>\n<h3 id=\"1-1-1-安装TestNG插件\"><a href=\"#1-1-1-安装TestNG插件\" class=\"headerlink\" title=\"1.1.1 安装TestNG插件\"></a>1.1.1 安装TestNG插件</h3><p>idea -&gt; plugin -&gt; 搜索create testng xml</p>\n<h3 id=\"1-2-编写TestNG-XML\"><a href=\"#1-2-编写TestNG-XML\" class=\"headerlink\" title=\"1.2 编写TestNG XML\"></a>1.2 编写TestNG XML</h3><p>xml名字任意，xml文件数量任意。但是通常命名为testng.xml</p>\n<p>xml得放在resources里面</p>\n<blockquote>\n<p>Testng管理层级：</p>\n<p>suite-&gt;test-&gt;class-&gt;method</p>\n</blockquote>\n<ul>\n<li><p>testng.xml骨架</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;suite&gt;\n    &lt;test&gt;\n        &lt;classes&gt;\n            &lt;class&gt;\n                &lt;methods&gt;\n                    \n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;\n</code></pre>\n<p>当然，手写很麻烦，可以直接通过testng插件生成。</p>\n</li>\n</ul>\n<h3 id=\"1-3-XML-DEMO\"><a href=\"#1-3-XML-DEMO\" class=\"headerlink\" title=\"1.3 XML DEMO\"></a>1.3 XML DEMO</h3><p>改造一下findWebsite，创建两个类。一个findWebiste，查找并进入<a href=\"http://www.anicaaz.com.另一个类findblog,点击博客第一条./\">www.anicaaz.com.另一个类findBlog，点击博客第一条。</a></p>\n<p>FindWebsite改动</p>\n<p><img src=\"/../img/image-20230928213416192.png\" alt=\"image-20230928213416192\"></p>\n<pre><code class=\"java\">import org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\npublic class FindBlog &#123;\n\n    private WebDriver webDriver;\n\n\n    @BeforeClass\n    public void setWebDriver() &#123;\n        webDriver = FindWebsite.webDriver;\n    &#125;\n\n    @Test\n    public void findBlog() &#123;\n        webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div[1]/div/div[2]/a/h1&quot;)).click();\n        String text = webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div/h1&quot;)).getText();\n        Assert.assertEquals(text, &quot;速通TestNG&quot;);\n    &#125;\n\n    @AfterClass\n    public void closeWebDriver() &#123;\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;\n&lt;suite name=&quot;All Test Suite&quot;&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找网站&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindWebsite&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;searchAnicaa&quot;/&gt;\n                    &lt;include name=&quot;goToWebsite&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找博客首页第一篇博客&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindBlog&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;findBlog&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;\n</code></pre>\n<p><img src=\"/../img/image-20230928213811991.png\" alt=\"image-20230928213811991\"></p>\n<p>把Assert内容随便乱改点，就可以看到成功的报错了。</p>\n<p><img src=\"/../img/image-20230928213734939.png\" alt=\"image-20230928213734939\"></p>\n<h2 id=\"6-PO模式与TestNG\"><a href=\"#6-PO模式与TestNG\" class=\"headerlink\" title=\"6. PO模式与TestNG\"></a>6. PO模式与TestNG</h2><p>其实就是把页面当成一个对象来看。一个类，对应一个页面。</p>\n<p>PO： Page Object</p>\n<p>抽象对象：</p>\n<ol>\n<li>属性： url 元素（元素定位表达式）</li>\n<li>方法： 业务流程操作。</li>\n</ol>\n<p>高内聚: 页面属性放一块</p>\n<p>低耦合：不同页面通过webDriver来传递</p>\n"},{"title":"标签","date":"2022-09-01T22:02:36.000Z","_content":"","source":"_posts/标签.md","raw":"---\ntitle: 标签\ndate: 2022-9-1 18:02:36\ntags:\n    - Spring\n    - SpringBoot\n    - Mybatis(Plus)\n    - Mysql\n    - Redis\n    - Rabbitmq\n    - Kafka\n    - Docker\n    - K8s\n    - xxl-job\n    - Javascript基础\n    - Vue2\n    - React.js\n    - Electron.js\n    - Flutter\n    - Selenium\n\ncategories:\n    - Java基础\n    - Javascript基础\n    - 后端开发\n    - 前端开发\n    - 软件测试\n    - OS\n    - 数据库\n    - 中间件\n    - 算法\n---\n","slug":"标签","published":1,"updated":"2023-11-08T23:11:26.285Z","_id":"cln44k4uo0007awhz1ecxe44t","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"连接远程数据库问题","date":"2023-09-22T10:35:48.000Z","_content":"\n> 连接远程数据库时，datagrip报错：[HY000][1130] null, message from server: \"Host 'pool-100-1-119-187.nwrknj.fios.verizon.net' is not a ........\n\n已知端口开放了。问题就只能处在数据库权限上。\n\n查看host和对应的用户\n\n```\nselect host,user from mysql.user\n```\n如果host是localhost的话，表明数据库只允许localhost访问，远程自然无法连接。\n\n```\nupdate user set host='% where user='root';\n```\n让root用户能够从任意host访问到数据库。\n举一反三，不同的用户，将root替换成其他用户名就可以。\n\n最后刷新权限，再次test connection\n```\nflush privileges;\n```\nSucceeded\nDBMS: MySQL (ver. 8.0.24)  Case sensitivity: plain=lower, delimited=lower Driver: MySQL Connector/J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)  Ping: 674 ms SSL: yes\n\n\n","source":"_posts/连接阿里云数据库问题.md","raw":"---\ntitle: 连接远程数据库问题\ndate: 2023-9-22 06:35:48\ntags:\n    - Mysql\ncategories:\n    - 数据库\n---\n\n> 连接远程数据库时，datagrip报错：[HY000][1130] null, message from server: \"Host 'pool-100-1-119-187.nwrknj.fios.verizon.net' is not a ........\n\n已知端口开放了。问题就只能处在数据库权限上。\n\n查看host和对应的用户\n\n```\nselect host,user from mysql.user\n```\n如果host是localhost的话，表明数据库只允许localhost访问，远程自然无法连接。\n\n```\nupdate user set host='% where user='root';\n```\n让root用户能够从任意host访问到数据库。\n举一反三，不同的用户，将root替换成其他用户名就可以。\n\n最后刷新权限，再次test connection\n```\nflush privileges;\n```\nSucceeded\nDBMS: MySQL (ver. 8.0.24)  Case sensitivity: plain=lower, delimited=lower Driver: MySQL Connector/J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)  Ping: 674 ms SSL: yes\n\n\n","slug":"连接阿里云数据库问题","published":1,"updated":"2023-11-08T23:11:26.285Z","_id":"cln44k4ur000bawhzbmaza1d4","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>连接远程数据库时，datagrip报错：[HY000][1130] null, message from server: “Host ‘pool-100-1-119-187.nwrknj.fios.verizon.net’ is not a ……..</p>\n</blockquote>\n<p>已知端口开放了。问题就只能处在数据库权限上。</p>\n<p>查看host和对应的用户</p>\n<pre><code>select host,user from mysql.user\n</code></pre>\n<p>如果host是localhost的话，表明数据库只允许localhost访问，远程自然无法连接。</p>\n<pre><code>update user set host=&#39;% where user=&#39;root&#39;;\n</code></pre>\n<p>让root用户能够从任意host访问到数据库。<br>举一反三，不同的用户，将root替换成其他用户名就可以。</p>\n<p>最后刷新权限，再次test connection</p>\n<pre><code>flush privileges;\n</code></pre>\n<p>Succeeded<br>DBMS: MySQL (ver. 8.0.24)  Case sensitivity: plain&#x3D;lower, delimited&#x3D;lower Driver: MySQL Connector&#x2F;J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)  Ping: 674 ms SSL: yes</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>连接远程数据库时，datagrip报错：[HY000][1130] null, message from server: “Host ‘pool-100-1-119-187.nwrknj.fios.verizon.net’ is not a ……..</p>\n</blockquote>\n<p>已知端口开放了。问题就只能处在数据库权限上。</p>\n<p>查看host和对应的用户</p>\n<pre><code>select host,user from mysql.user\n</code></pre>\n<p>如果host是localhost的话，表明数据库只允许localhost访问，远程自然无法连接。</p>\n<pre><code>update user set host=&#39;% where user=&#39;root&#39;;\n</code></pre>\n<p>让root用户能够从任意host访问到数据库。<br>举一反三，不同的用户，将root替换成其他用户名就可以。</p>\n<p>最后刷新权限，再次test connection</p>\n<pre><code>flush privileges;\n</code></pre>\n<p>Succeeded<br>DBMS: MySQL (ver. 8.0.24)  Case sensitivity: plain&#x3D;lower, delimited&#x3D;lower Driver: MySQL Connector&#x2F;J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)  Ping: 674 ms SSL: yes</p>\n"},{"title":"测试基础回顾","date":"2023-10-09T04:36:00.000Z","cover":"/img/cake.jpg","_content":"\n\n\n## 1. 主流测试技术\n\n### 1.1 功能测试\n\n> 验证程序的功能是否能满足需求\n\n### 1.2 自动化测试\n\n> 使用代码或工具代替手工，对项目进行测试\n\n### 1.3 接口测试\n\n> 测接口。\n\n### 1.4 性能测试\n\n> 模拟多人使用软件，查找服务器缺陷。\n\n## 2.测试分类\n\n### 2.1 按测试阶段划分\n\n> 单元、集成、系统、验收\n\n单元：针对源代码测试（开发自己做）\n\n集成：接口测试。针对模块之间访问进行测试。\n\n系统：对整个系统进行测试。（功能、兼容、文档等测试）\n\n验收：内测、公测。不同人群对项目提供反馈。\n\n\n\n### 2.2 按代码可见度划分\n\n#### 2.2.1 黑盒测试\n\n属于系统测试\n\n1. 源代码不可见\n2. UI可见\n\n#### 2.2.2 灰盒测试\n\n属于接口测试（集成测试）\n\n1. 部分源代码可见\n\n2. 功能不可见（只有纯接口）\n\n#### 2.2.3 白盒测试\n\n属于单元测试\n\n1. 源代码完全可见\n2. UI不可见\n\n## 3. 质量模型\n\n> 质量模型用于衡量一个优秀软件的维度。\n\n* 功能性\n* 性能：每秒请求数 <= 服务器硬件是否满足\n* 兼容性：多平台。浏览器、操作系统、分辨率、网络、应用之间\n  \n* 易用性：简洁、友好、流畅、美观\n* 可靠性：卡顿、服务器宕机、闪退\n* 安全：信息传输，存储。加密。\n* 可维护性\n* 可移植性\n\n## 4. 测试流程\n\n1. 需求评审\n   确保各部门需求理解一致\n2. 计划编写\n   测什么、谁来测、怎么测、\n3. 用例设计\n   验证项目是否符合需求的操作文档\n4. 用例执行\n   项目模块开发完成后，执行用例文档，实施测试\n5. 缺陷管理\n   对缺陷进行管理\n6. 测试报告\n   实施测试结果文档\n\n## 5. 测试用例\n\n> 用例：用户使用的案例。\n>\n> 测试用例：为测试项目而设计的执行文档\n\n### 5.1 测试用例的作用\n\n1. 防止漏测\n2. 实施测试的标准\n\n### 5.2 用例设计编写格式\n\n八大要素：用例编号，用例标题，项目/模块，优先级，前置条件，测试步骤，测试数据，预期结果\n\n* 用例编号: 项目_ 模块 _编号\n\n* 用例标题：预期结果（测试点）\n* 项目/模块：所属项目或模块\n* 优先级：表示用例的重要程度或影响力。从p0到p4。最高为p0\n  * 核心功能：用户、高频\n* 前置条件：要执行词条用力，有哪些前置操作\n  * 测试登录：先要打开登录页面，才能。。。\n* 测试步骤：描述操作步骤\n* 测试数据：操作的数据，没有的话可以为空\n* 预期结果：期望达到的结果\n\n\n\ndemo:\n\n![image-20231005073508368](../img/image-20231005073508368.png)\n\n#### 5.2.1 Excel下拉复制的同时使数字不会自增\n\n按住ctrl然后下拉\n\n## 6. 等价类划分法\n\n> 在所有的测试数据中，具有某种共同特种的数据集合进行划分。划分之后的结果分为两类：\n>\n> * 有效等价类：满足需求的数据集合\n>   * 需求：统计出生时性别为男孩的人数。则所有新生儿中男孩为有效\n> * 无效等价类：不满足需求的数据结合\n>   * 上面例子中的女孩。\n\n### 6.1 Demo：验证账号的合法性\n\n* 需求：账号长度需要是6~ 10位自然数\n\n步骤：\n\n1. 明确需求\n   * 账号长度需要是6~ 10位自然数\n2. 划分有效等价类\n   * 有效：八位\n   * 无效：三位、十二位\n3. 提取数据，编写用例\n   * 八位：12345678\n   * 三位：123\n   * 十二位：123456789012\n\n![image-20231005092614348](../img/image-20231005092614348.png)\n\n#### 6.1.1 根据类型完善\n\n![image-20231005093309025](../img/image-20231005093309025.png)\n\n> 需求最多也就可以被分成：长度、类型、规则\n\n### 6.2 Demo：电话号码\n\n要求：\n\n1. 区号：空或者是三位数字\n2. 前缀码：非\"0\"且非\"1\"开头的三位数字\n3. 后缀码：四位数字\n\n![image-20231005121023638](../img/image-20231005121023638.png)\n\n### 6.3 等价类适用场景\n\n需要有大量的数据测试输入，但是没法穷举测试的地方\n\n* 输入框\n* 下拉列表\n* 单选、复选框\n\n## 7. 边界值分析方法\n\n### 7.1  边界范围节点\n\n* 选择**正好等于**、**刚好大于**、**刚好小于**边界的值作为测试数据\n  * 上点： 边界**上**的点（正好等于)\n  * 离点： 距离上点距离最近的点（刚好大于**、**刚好小于)\n  * 内点： 范围内的点（一般取中间的）\n* 这样算下来。最多7条。（两个商店，四个离点，一个内点）\n* 注意：内点需要两条用例（正反）\n* Demo：等价类和边界值合一块写\n  * 要求：账号长度需要是6到10位自然数（6和10也可以）\n    ![image-20231008234542259](../img/image-20231008234542259.png)\n\n* 从这个例子不难看出。其实等价类的分析：长度、类型、规则，其实结合了边界值之后，**长度，规则**这两点就交给边界值分析了。比如对要求账号是6到10位，那么有效等价就是自然数，无效等价就是非自然数。而原先哪些长度，规则，就由边界值进行判定。\n\n### 7.2 优化\n\n**开内闭外**：开区间选内点，闭区间选外点\n\n开区间：边界点**没有等号**   （如大于0小于10）\n\n闭区间：边界上的点有等号（如大于等于0小于等于10)\n\n那么可以看到上面的案例中，因为6和10时包含的，那么属于双闭，选外点。那么内点7和9就不需要了。数量优化到5点。\n\n## 8. 判定表\n\n> 很多场景，用例存在**条件依赖**关系。比如欠费就停机。这时候就无法单一地去测了。\n\n* 等价类以及边界值更加关注**单个输入类条件**的测试\n* 并未考虑输入条件之间的组合，输入条件和输出结果之间的依赖关系。\n\n\n\n判定表：以表格的形式表达 多条件逻辑判断 的工具\n\n* 组成：\n  1. 条件桩：列出问题中的所有条件。次序是无关紧要的\n  2. 动作桩：列出问题中可能采取的操作。操作的顺序同样无关紧要\n  3. 条件项：条件的取值\n  4. 操作：条件叠加后的结果\n\n![image-20231009001757777](../img/image-20231009001757777.png)\n\n* 假设有n个条件，每个条件取值有m个，全部组合就有m的n次方种规格。当然，绝大多数的情况下，条件的取值有2个\n* 像上图这样把表格整理出来后，每一列都是一个用例。\n\n* 判定表一般适用于条件少于4个的情况，如果条件多于4个，就要用正交表了。\n\n## 9. 业务覆盖测试\n\n###  9.1 流程图\n\n> 业务用例是根据流程图来梳理的\n\n**开始和结尾**用椭圆。\n\n**中间**用**判断语句**连接。菱形\n\n**判断语句**连接结果。\n\n![image-20231009143738559](../img/image-20231009143738559.png)\n\n### 9.2 ATM Demo\n\n![image-20231009213653825](../img/image-20231009213653825.png)\n\n![image-20231009213702116](../img/image-20231009213702116.png)\n\n![image-20231009213724620](../img/image-20231009213724620.png)\n\n* 其实就是把退出的场景都测一遍。然后流程通过的场景测一遍。\n\n## 10. 错误推荐法\n\n> 当项目测试用例都执行完毕，且bug修复完成，项目尚未上线的情况下，在这段时间里可以 通过经验推测系统可能出现的问题，列出问题的清单，分析问题可能的原因。\n\n* 时间紧、任务量大 -> 根据已有经验找出易出错的模块重点测试。\n\n## 11. 缺陷\n\n> 软件在使用过程中存在的**任何问题**都叫软件的缺陷，简称bug。\n\n### 11.1 缺陷的判定标准\n\n* **少功能**：软件未实现需求说明书中明确要求的功能\n* **功能错误**：软件中出现了需求说明书中指明不应该出现的错误\n* **多功能**： 软件实现的功能超出了需求说明书中指明的范围\n* **隐性功能错误**： 软件未实现需求说明书中虽未明确指明，但应该实现的要求\n* **不易使用**：软件难以理解，不易使用，运行缓慢，用户体验不好。\n\n\n\n### 11.2 缺陷产生的原因\n\n从需求到发布是一个线性的过程。其中一个环节出错，都会导致缺陷\n\n* 阶段1. 需求阶段\n\n  需求描述不易理解，有歧义，错误\n\n* 阶段2. **设计阶段**\n\n  设计文档存在错误和缺陷\n\n* 阶段3. **编码阶段**\n\n  代码出现错误\n\n* 阶段4. **运行阶段**\n\n  软硬件系统本身故障导致软件缺陷\n\n\n\n### 11.3 缺陷的生命周期\n\n![image-20231009225919124](../img/image-20231009225919124.png)\n\n### 11.4 缺陷的核心内容\n\n* 缺陷标题\n* 缺陷预期结果\n* 缺陷产生的条件\n* 因缺陷得到的结果\n* 复现缺陷的过程\n* 缺陷的证据\n\n\n\n### 11.5 缺陷的提交要素\n\n![image-20231009232548604](../img/image-20231009232548604.png)\n\n\n\n## 11.6 软件缺陷类型\n\n* 功能错误\n* UI错误\n* 兼容性\n* 数据\n* 易用性\n* 改进\n* 架构\n\n\n\n### 11.7 缺陷的跟踪流程\n\n![image-20231010000541057](../img/image-20231010000541057.png)\n\n\n\n### 11.8 缺陷模板\n\n![image-20231010001511880](../img/image-20231010001511880.png)","source":"_posts/测试理论.md","raw":"---\ntitle: 测试基础回顾\ndate: 2023-10-9 00:36:00\ntags:\n- 软件测试\n\ncategories:\n- 软件测试\n\ncover: /img/cake.jpg\n---\n\n\n\n## 1. 主流测试技术\n\n### 1.1 功能测试\n\n> 验证程序的功能是否能满足需求\n\n### 1.2 自动化测试\n\n> 使用代码或工具代替手工，对项目进行测试\n\n### 1.3 接口测试\n\n> 测接口。\n\n### 1.4 性能测试\n\n> 模拟多人使用软件，查找服务器缺陷。\n\n## 2.测试分类\n\n### 2.1 按测试阶段划分\n\n> 单元、集成、系统、验收\n\n单元：针对源代码测试（开发自己做）\n\n集成：接口测试。针对模块之间访问进行测试。\n\n系统：对整个系统进行测试。（功能、兼容、文档等测试）\n\n验收：内测、公测。不同人群对项目提供反馈。\n\n\n\n### 2.2 按代码可见度划分\n\n#### 2.2.1 黑盒测试\n\n属于系统测试\n\n1. 源代码不可见\n2. UI可见\n\n#### 2.2.2 灰盒测试\n\n属于接口测试（集成测试）\n\n1. 部分源代码可见\n\n2. 功能不可见（只有纯接口）\n\n#### 2.2.3 白盒测试\n\n属于单元测试\n\n1. 源代码完全可见\n2. UI不可见\n\n## 3. 质量模型\n\n> 质量模型用于衡量一个优秀软件的维度。\n\n* 功能性\n* 性能：每秒请求数 <= 服务器硬件是否满足\n* 兼容性：多平台。浏览器、操作系统、分辨率、网络、应用之间\n  \n* 易用性：简洁、友好、流畅、美观\n* 可靠性：卡顿、服务器宕机、闪退\n* 安全：信息传输，存储。加密。\n* 可维护性\n* 可移植性\n\n## 4. 测试流程\n\n1. 需求评审\n   确保各部门需求理解一致\n2. 计划编写\n   测什么、谁来测、怎么测、\n3. 用例设计\n   验证项目是否符合需求的操作文档\n4. 用例执行\n   项目模块开发完成后，执行用例文档，实施测试\n5. 缺陷管理\n   对缺陷进行管理\n6. 测试报告\n   实施测试结果文档\n\n## 5. 测试用例\n\n> 用例：用户使用的案例。\n>\n> 测试用例：为测试项目而设计的执行文档\n\n### 5.1 测试用例的作用\n\n1. 防止漏测\n2. 实施测试的标准\n\n### 5.2 用例设计编写格式\n\n八大要素：用例编号，用例标题，项目/模块，优先级，前置条件，测试步骤，测试数据，预期结果\n\n* 用例编号: 项目_ 模块 _编号\n\n* 用例标题：预期结果（测试点）\n* 项目/模块：所属项目或模块\n* 优先级：表示用例的重要程度或影响力。从p0到p4。最高为p0\n  * 核心功能：用户、高频\n* 前置条件：要执行词条用力，有哪些前置操作\n  * 测试登录：先要打开登录页面，才能。。。\n* 测试步骤：描述操作步骤\n* 测试数据：操作的数据，没有的话可以为空\n* 预期结果：期望达到的结果\n\n\n\ndemo:\n\n![image-20231005073508368](../img/image-20231005073508368.png)\n\n#### 5.2.1 Excel下拉复制的同时使数字不会自增\n\n按住ctrl然后下拉\n\n## 6. 等价类划分法\n\n> 在所有的测试数据中，具有某种共同特种的数据集合进行划分。划分之后的结果分为两类：\n>\n> * 有效等价类：满足需求的数据集合\n>   * 需求：统计出生时性别为男孩的人数。则所有新生儿中男孩为有效\n> * 无效等价类：不满足需求的数据结合\n>   * 上面例子中的女孩。\n\n### 6.1 Demo：验证账号的合法性\n\n* 需求：账号长度需要是6~ 10位自然数\n\n步骤：\n\n1. 明确需求\n   * 账号长度需要是6~ 10位自然数\n2. 划分有效等价类\n   * 有效：八位\n   * 无效：三位、十二位\n3. 提取数据，编写用例\n   * 八位：12345678\n   * 三位：123\n   * 十二位：123456789012\n\n![image-20231005092614348](../img/image-20231005092614348.png)\n\n#### 6.1.1 根据类型完善\n\n![image-20231005093309025](../img/image-20231005093309025.png)\n\n> 需求最多也就可以被分成：长度、类型、规则\n\n### 6.2 Demo：电话号码\n\n要求：\n\n1. 区号：空或者是三位数字\n2. 前缀码：非\"0\"且非\"1\"开头的三位数字\n3. 后缀码：四位数字\n\n![image-20231005121023638](../img/image-20231005121023638.png)\n\n### 6.3 等价类适用场景\n\n需要有大量的数据测试输入，但是没法穷举测试的地方\n\n* 输入框\n* 下拉列表\n* 单选、复选框\n\n## 7. 边界值分析方法\n\n### 7.1  边界范围节点\n\n* 选择**正好等于**、**刚好大于**、**刚好小于**边界的值作为测试数据\n  * 上点： 边界**上**的点（正好等于)\n  * 离点： 距离上点距离最近的点（刚好大于**、**刚好小于)\n  * 内点： 范围内的点（一般取中间的）\n* 这样算下来。最多7条。（两个商店，四个离点，一个内点）\n* 注意：内点需要两条用例（正反）\n* Demo：等价类和边界值合一块写\n  * 要求：账号长度需要是6到10位自然数（6和10也可以）\n    ![image-20231008234542259](../img/image-20231008234542259.png)\n\n* 从这个例子不难看出。其实等价类的分析：长度、类型、规则，其实结合了边界值之后，**长度，规则**这两点就交给边界值分析了。比如对要求账号是6到10位，那么有效等价就是自然数，无效等价就是非自然数。而原先哪些长度，规则，就由边界值进行判定。\n\n### 7.2 优化\n\n**开内闭外**：开区间选内点，闭区间选外点\n\n开区间：边界点**没有等号**   （如大于0小于10）\n\n闭区间：边界上的点有等号（如大于等于0小于等于10)\n\n那么可以看到上面的案例中，因为6和10时包含的，那么属于双闭，选外点。那么内点7和9就不需要了。数量优化到5点。\n\n## 8. 判定表\n\n> 很多场景，用例存在**条件依赖**关系。比如欠费就停机。这时候就无法单一地去测了。\n\n* 等价类以及边界值更加关注**单个输入类条件**的测试\n* 并未考虑输入条件之间的组合，输入条件和输出结果之间的依赖关系。\n\n\n\n判定表：以表格的形式表达 多条件逻辑判断 的工具\n\n* 组成：\n  1. 条件桩：列出问题中的所有条件。次序是无关紧要的\n  2. 动作桩：列出问题中可能采取的操作。操作的顺序同样无关紧要\n  3. 条件项：条件的取值\n  4. 操作：条件叠加后的结果\n\n![image-20231009001757777](../img/image-20231009001757777.png)\n\n* 假设有n个条件，每个条件取值有m个，全部组合就有m的n次方种规格。当然，绝大多数的情况下，条件的取值有2个\n* 像上图这样把表格整理出来后，每一列都是一个用例。\n\n* 判定表一般适用于条件少于4个的情况，如果条件多于4个，就要用正交表了。\n\n## 9. 业务覆盖测试\n\n###  9.1 流程图\n\n> 业务用例是根据流程图来梳理的\n\n**开始和结尾**用椭圆。\n\n**中间**用**判断语句**连接。菱形\n\n**判断语句**连接结果。\n\n![image-20231009143738559](../img/image-20231009143738559.png)\n\n### 9.2 ATM Demo\n\n![image-20231009213653825](../img/image-20231009213653825.png)\n\n![image-20231009213702116](../img/image-20231009213702116.png)\n\n![image-20231009213724620](../img/image-20231009213724620.png)\n\n* 其实就是把退出的场景都测一遍。然后流程通过的场景测一遍。\n\n## 10. 错误推荐法\n\n> 当项目测试用例都执行完毕，且bug修复完成，项目尚未上线的情况下，在这段时间里可以 通过经验推测系统可能出现的问题，列出问题的清单，分析问题可能的原因。\n\n* 时间紧、任务量大 -> 根据已有经验找出易出错的模块重点测试。\n\n## 11. 缺陷\n\n> 软件在使用过程中存在的**任何问题**都叫软件的缺陷，简称bug。\n\n### 11.1 缺陷的判定标准\n\n* **少功能**：软件未实现需求说明书中明确要求的功能\n* **功能错误**：软件中出现了需求说明书中指明不应该出现的错误\n* **多功能**： 软件实现的功能超出了需求说明书中指明的范围\n* **隐性功能错误**： 软件未实现需求说明书中虽未明确指明，但应该实现的要求\n* **不易使用**：软件难以理解，不易使用，运行缓慢，用户体验不好。\n\n\n\n### 11.2 缺陷产生的原因\n\n从需求到发布是一个线性的过程。其中一个环节出错，都会导致缺陷\n\n* 阶段1. 需求阶段\n\n  需求描述不易理解，有歧义，错误\n\n* 阶段2. **设计阶段**\n\n  设计文档存在错误和缺陷\n\n* 阶段3. **编码阶段**\n\n  代码出现错误\n\n* 阶段4. **运行阶段**\n\n  软硬件系统本身故障导致软件缺陷\n\n\n\n### 11.3 缺陷的生命周期\n\n![image-20231009225919124](../img/image-20231009225919124.png)\n\n### 11.4 缺陷的核心内容\n\n* 缺陷标题\n* 缺陷预期结果\n* 缺陷产生的条件\n* 因缺陷得到的结果\n* 复现缺陷的过程\n* 缺陷的证据\n\n\n\n### 11.5 缺陷的提交要素\n\n![image-20231009232548604](../img/image-20231009232548604.png)\n\n\n\n## 11.6 软件缺陷类型\n\n* 功能错误\n* UI错误\n* 兼容性\n* 数据\n* 易用性\n* 改进\n* 架构\n\n\n\n### 11.7 缺陷的跟踪流程\n\n![image-20231010000541057](../img/image-20231010000541057.png)\n\n\n\n### 11.8 缺陷模板\n\n![image-20231010001511880](../img/image-20231010001511880.png)","slug":"测试理论","published":1,"updated":"2023-11-08T23:11:26.285Z","_id":"clnier4pp0000i8hzh2cw7i8q","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-主流测试技术\"><a href=\"#1-主流测试技术\" class=\"headerlink\" title=\"1. 主流测试技术\"></a>1. 主流测试技术</h2><h3 id=\"1-1-功能测试\"><a href=\"#1-1-功能测试\" class=\"headerlink\" title=\"1.1 功能测试\"></a>1.1 功能测试</h3><blockquote>\n<p>验证程序的功能是否能满足需求</p>\n</blockquote>\n<h3 id=\"1-2-自动化测试\"><a href=\"#1-2-自动化测试\" class=\"headerlink\" title=\"1.2 自动化测试\"></a>1.2 自动化测试</h3><blockquote>\n<p>使用代码或工具代替手工，对项目进行测试</p>\n</blockquote>\n<h3 id=\"1-3-接口测试\"><a href=\"#1-3-接口测试\" class=\"headerlink\" title=\"1.3 接口测试\"></a>1.3 接口测试</h3><blockquote>\n<p>测接口。</p>\n</blockquote>\n<h3 id=\"1-4-性能测试\"><a href=\"#1-4-性能测试\" class=\"headerlink\" title=\"1.4 性能测试\"></a>1.4 性能测试</h3><blockquote>\n<p>模拟多人使用软件，查找服务器缺陷。</p>\n</blockquote>\n<h2 id=\"2-测试分类\"><a href=\"#2-测试分类\" class=\"headerlink\" title=\"2.测试分类\"></a>2.测试分类</h2><h3 id=\"2-1-按测试阶段划分\"><a href=\"#2-1-按测试阶段划分\" class=\"headerlink\" title=\"2.1 按测试阶段划分\"></a>2.1 按测试阶段划分</h3><blockquote>\n<p>单元、集成、系统、验收</p>\n</blockquote>\n<p>单元：针对源代码测试（开发自己做）</p>\n<p>集成：接口测试。针对模块之间访问进行测试。</p>\n<p>系统：对整个系统进行测试。（功能、兼容、文档等测试）</p>\n<p>验收：内测、公测。不同人群对项目提供反馈。</p>\n<h3 id=\"2-2-按代码可见度划分\"><a href=\"#2-2-按代码可见度划分\" class=\"headerlink\" title=\"2.2 按代码可见度划分\"></a>2.2 按代码可见度划分</h3><h4 id=\"2-2-1-黑盒测试\"><a href=\"#2-2-1-黑盒测试\" class=\"headerlink\" title=\"2.2.1 黑盒测试\"></a>2.2.1 黑盒测试</h4><p>属于系统测试</p>\n<ol>\n<li>源代码不可见</li>\n<li>UI可见</li>\n</ol>\n<h4 id=\"2-2-2-灰盒测试\"><a href=\"#2-2-2-灰盒测试\" class=\"headerlink\" title=\"2.2.2 灰盒测试\"></a>2.2.2 灰盒测试</h4><p>属于接口测试（集成测试）</p>\n<ol>\n<li><p>部分源代码可见</p>\n</li>\n<li><p>功能不可见（只有纯接口）</p>\n</li>\n</ol>\n<h4 id=\"2-2-3-白盒测试\"><a href=\"#2-2-3-白盒测试\" class=\"headerlink\" title=\"2.2.3 白盒测试\"></a>2.2.3 白盒测试</h4><p>属于单元测试</p>\n<ol>\n<li>源代码完全可见</li>\n<li>UI不可见</li>\n</ol>\n<h2 id=\"3-质量模型\"><a href=\"#3-质量模型\" class=\"headerlink\" title=\"3. 质量模型\"></a>3. 质量模型</h2><blockquote>\n<p>质量模型用于衡量一个优秀软件的维度。</p>\n</blockquote>\n<ul>\n<li><p>功能性</p>\n</li>\n<li><p>性能：每秒请求数 &lt;&#x3D; 服务器硬件是否满足</p>\n</li>\n<li><p>兼容性：多平台。浏览器、操作系统、分辨率、网络、应用之间</p>\n</li>\n<li><p>易用性：简洁、友好、流畅、美观</p>\n</li>\n<li><p>可靠性：卡顿、服务器宕机、闪退</p>\n</li>\n<li><p>安全：信息传输，存储。加密。</p>\n</li>\n<li><p>可维护性</p>\n</li>\n<li><p>可移植性</p>\n</li>\n</ul>\n<h2 id=\"4-测试流程\"><a href=\"#4-测试流程\" class=\"headerlink\" title=\"4. 测试流程\"></a>4. 测试流程</h2><ol>\n<li>需求评审<br>确保各部门需求理解一致</li>\n<li>计划编写<br>测什么、谁来测、怎么测、</li>\n<li>用例设计<br>验证项目是否符合需求的操作文档</li>\n<li>用例执行<br>项目模块开发完成后，执行用例文档，实施测试</li>\n<li>缺陷管理<br>对缺陷进行管理</li>\n<li>测试报告<br>实施测试结果文档</li>\n</ol>\n<h2 id=\"5-测试用例\"><a href=\"#5-测试用例\" class=\"headerlink\" title=\"5. 测试用例\"></a>5. 测试用例</h2><blockquote>\n<p>用例：用户使用的案例。</p>\n<p>测试用例：为测试项目而设计的执行文档</p>\n</blockquote>\n<h3 id=\"5-1-测试用例的作用\"><a href=\"#5-1-测试用例的作用\" class=\"headerlink\" title=\"5.1 测试用例的作用\"></a>5.1 测试用例的作用</h3><ol>\n<li>防止漏测</li>\n<li>实施测试的标准</li>\n</ol>\n<h3 id=\"5-2-用例设计编写格式\"><a href=\"#5-2-用例设计编写格式\" class=\"headerlink\" title=\"5.2 用例设计编写格式\"></a>5.2 用例设计编写格式</h3><p>八大要素：用例编号，用例标题，项目&#x2F;模块，优先级，前置条件，测试步骤，测试数据，预期结果</p>\n<ul>\n<li><p>用例编号: 项目_ 模块 _编号</p>\n</li>\n<li><p>用例标题：预期结果（测试点）</p>\n</li>\n<li><p>项目&#x2F;模块：所属项目或模块</p>\n</li>\n<li><p>优先级：表示用例的重要程度或影响力。从p0到p4。最高为p0</p>\n<ul>\n<li>核心功能：用户、高频</li>\n</ul>\n</li>\n<li><p>前置条件：要执行词条用力，有哪些前置操作</p>\n<ul>\n<li>测试登录：先要打开登录页面，才能。。。</li>\n</ul>\n</li>\n<li><p>测试步骤：描述操作步骤</p>\n</li>\n<li><p>测试数据：操作的数据，没有的话可以为空</p>\n</li>\n<li><p>预期结果：期望达到的结果</p>\n</li>\n</ul>\n<p>demo:</p>\n<p><img src=\"/../img/image-20231005073508368.png\" alt=\"image-20231005073508368\"></p>\n<h4 id=\"5-2-1-Excel下拉复制的同时使数字不会自增\"><a href=\"#5-2-1-Excel下拉复制的同时使数字不会自增\" class=\"headerlink\" title=\"5.2.1 Excel下拉复制的同时使数字不会自增\"></a>5.2.1 Excel下拉复制的同时使数字不会自增</h4><p>按住ctrl然后下拉</p>\n<h2 id=\"6-等价类划分法\"><a href=\"#6-等价类划分法\" class=\"headerlink\" title=\"6. 等价类划分法\"></a>6. 等价类划分法</h2><blockquote>\n<p>在所有的测试数据中，具有某种共同特种的数据集合进行划分。划分之后的结果分为两类：</p>\n<ul>\n<li>有效等价类：满足需求的数据集合<ul>\n<li>需求：统计出生时性别为男孩的人数。则所有新生儿中男孩为有效</li>\n</ul>\n</li>\n<li>无效等价类：不满足需求的数据结合<ul>\n<li>上面例子中的女孩。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"6-1-Demo：验证账号的合法性\"><a href=\"#6-1-Demo：验证账号的合法性\" class=\"headerlink\" title=\"6.1 Demo：验证账号的合法性\"></a>6.1 Demo：验证账号的合法性</h3><ul>\n<li>需求：账号长度需要是6~ 10位自然数</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>明确需求<ul>\n<li>账号长度需要是6~ 10位自然数</li>\n</ul>\n</li>\n<li>划分有效等价类<ul>\n<li>有效：八位</li>\n<li>无效：三位、十二位</li>\n</ul>\n</li>\n<li>提取数据，编写用例<ul>\n<li>八位：12345678</li>\n<li>三位：123</li>\n<li>十二位：123456789012</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/../img/image-20231005092614348.png\" alt=\"image-20231005092614348\"></p>\n<h4 id=\"6-1-1-根据类型完善\"><a href=\"#6-1-1-根据类型完善\" class=\"headerlink\" title=\"6.1.1 根据类型完善\"></a>6.1.1 根据类型完善</h4><p><img src=\"/../img/image-20231005093309025.png\" alt=\"image-20231005093309025\"></p>\n<blockquote>\n<p>需求最多也就可以被分成：长度、类型、规则</p>\n</blockquote>\n<h3 id=\"6-2-Demo：电话号码\"><a href=\"#6-2-Demo：电话号码\" class=\"headerlink\" title=\"6.2 Demo：电话号码\"></a>6.2 Demo：电话号码</h3><p>要求：</p>\n<ol>\n<li>区号：空或者是三位数字</li>\n<li>前缀码：非”0”且非”1”开头的三位数字</li>\n<li>后缀码：四位数字</li>\n</ol>\n<p><img src=\"/../img/image-20231005121023638.png\" alt=\"image-20231005121023638\"></p>\n<h3 id=\"6-3-等价类适用场景\"><a href=\"#6-3-等价类适用场景\" class=\"headerlink\" title=\"6.3 等价类适用场景\"></a>6.3 等价类适用场景</h3><p>需要有大量的数据测试输入，但是没法穷举测试的地方</p>\n<ul>\n<li>输入框</li>\n<li>下拉列表</li>\n<li>单选、复选框</li>\n</ul>\n<h2 id=\"7-边界值分析方法\"><a href=\"#7-边界值分析方法\" class=\"headerlink\" title=\"7. 边界值分析方法\"></a>7. 边界值分析方法</h2><h3 id=\"7-1-边界范围节点\"><a href=\"#7-1-边界范围节点\" class=\"headerlink\" title=\"7.1  边界范围节点\"></a>7.1  边界范围节点</h3><ul>\n<li><p>选择<strong>正好等于</strong>、<strong>刚好大于</strong>、<strong>刚好小于</strong>边界的值作为测试数据</p>\n<ul>\n<li>上点： 边界<strong>上</strong>的点（正好等于)</li>\n<li>离点： 距离上点距离最近的点（刚好大于<strong>、</strong>刚好小于)</li>\n<li>内点： 范围内的点（一般取中间的）</li>\n</ul>\n</li>\n<li><p>这样算下来。最多7条。（两个商店，四个离点，一个内点）</p>\n</li>\n<li><p>注意：内点需要两条用例（正反）</p>\n</li>\n<li><p>Demo：等价类和边界值合一块写</p>\n<ul>\n<li>要求：账号长度需要是6到10位自然数（6和10也可以）<br><img src=\"/../img/image-20231008234542259.png\" alt=\"image-20231008234542259\"></li>\n</ul>\n</li>\n<li><p>从这个例子不难看出。其实等价类的分析：长度、类型、规则，其实结合了边界值之后，<strong>长度，规则</strong>这两点就交给边界值分析了。比如对要求账号是6到10位，那么有效等价就是自然数，无效等价就是非自然数。而原先哪些长度，规则，就由边界值进行判定。</p>\n</li>\n</ul>\n<h3 id=\"7-2-优化\"><a href=\"#7-2-优化\" class=\"headerlink\" title=\"7.2 优化\"></a>7.2 优化</h3><p><strong>开内闭外</strong>：开区间选内点，闭区间选外点</p>\n<p>开区间：边界点<strong>没有等号</strong>   （如大于0小于10）</p>\n<p>闭区间：边界上的点有等号（如大于等于0小于等于10)</p>\n<p>那么可以看到上面的案例中，因为6和10时包含的，那么属于双闭，选外点。那么内点7和9就不需要了。数量优化到5点。</p>\n<h2 id=\"8-判定表\"><a href=\"#8-判定表\" class=\"headerlink\" title=\"8. 判定表\"></a>8. 判定表</h2><blockquote>\n<p>很多场景，用例存在<strong>条件依赖</strong>关系。比如欠费就停机。这时候就无法单一地去测了。</p>\n</blockquote>\n<ul>\n<li>等价类以及边界值更加关注<strong>单个输入类条件</strong>的测试</li>\n<li>并未考虑输入条件之间的组合，输入条件和输出结果之间的依赖关系。</li>\n</ul>\n<p>判定表：以表格的形式表达 多条件逻辑判断 的工具</p>\n<ul>\n<li>组成：<ol>\n<li>条件桩：列出问题中的所有条件。次序是无关紧要的</li>\n<li>动作桩：列出问题中可能采取的操作。操作的顺序同样无关紧要</li>\n<li>条件项：条件的取值</li>\n<li>操作：条件叠加后的结果</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"/../img/image-20231009001757777.png\" alt=\"image-20231009001757777\"></p>\n<ul>\n<li><p>假设有n个条件，每个条件取值有m个，全部组合就有m的n次方种规格。当然，绝大多数的情况下，条件的取值有2个</p>\n</li>\n<li><p>像上图这样把表格整理出来后，每一列都是一个用例。</p>\n</li>\n<li><p>判定表一般适用于条件少于4个的情况，如果条件多于4个，就要用正交表了。</p>\n</li>\n</ul>\n<h2 id=\"9-业务覆盖测试\"><a href=\"#9-业务覆盖测试\" class=\"headerlink\" title=\"9. 业务覆盖测试\"></a>9. 业务覆盖测试</h2><h3 id=\"9-1-流程图\"><a href=\"#9-1-流程图\" class=\"headerlink\" title=\"9.1 流程图\"></a>9.1 流程图</h3><blockquote>\n<p>业务用例是根据流程图来梳理的</p>\n</blockquote>\n<p><strong>开始和结尾</strong>用椭圆。</p>\n<p><strong>中间</strong>用<strong>判断语句</strong>连接。菱形</p>\n<p><strong>判断语句</strong>连接结果。</p>\n<p><img src=\"/../img/image-20231009143738559.png\" alt=\"image-20231009143738559\"></p>\n<h3 id=\"9-2-ATM-Demo\"><a href=\"#9-2-ATM-Demo\" class=\"headerlink\" title=\"9.2 ATM Demo\"></a>9.2 ATM Demo</h3><p><img src=\"/../img/image-20231009213653825.png\" alt=\"image-20231009213653825\"></p>\n<p><img src=\"/../img/image-20231009213702116.png\" alt=\"image-20231009213702116\"></p>\n<p><img src=\"/../img/image-20231009213724620.png\" alt=\"image-20231009213724620\"></p>\n<ul>\n<li>其实就是把退出的场景都测一遍。然后流程通过的场景测一遍。</li>\n</ul>\n<h2 id=\"10-错误推荐法\"><a href=\"#10-错误推荐法\" class=\"headerlink\" title=\"10. 错误推荐法\"></a>10. 错误推荐法</h2><blockquote>\n<p>当项目测试用例都执行完毕，且bug修复完成，项目尚未上线的情况下，在这段时间里可以 通过经验推测系统可能出现的问题，列出问题的清单，分析问题可能的原因。</p>\n</blockquote>\n<ul>\n<li>时间紧、任务量大 -&gt; 根据已有经验找出易出错的模块重点测试。</li>\n</ul>\n<h2 id=\"11-缺陷\"><a href=\"#11-缺陷\" class=\"headerlink\" title=\"11. 缺陷\"></a>11. 缺陷</h2><blockquote>\n<p>软件在使用过程中存在的<strong>任何问题</strong>都叫软件的缺陷，简称bug。</p>\n</blockquote>\n<h3 id=\"11-1-缺陷的判定标准\"><a href=\"#11-1-缺陷的判定标准\" class=\"headerlink\" title=\"11.1 缺陷的判定标准\"></a>11.1 缺陷的判定标准</h3><ul>\n<li><strong>少功能</strong>：软件未实现需求说明书中明确要求的功能</li>\n<li><strong>功能错误</strong>：软件中出现了需求说明书中指明不应该出现的错误</li>\n<li><strong>多功能</strong>： 软件实现的功能超出了需求说明书中指明的范围</li>\n<li><strong>隐性功能错误</strong>： 软件未实现需求说明书中虽未明确指明，但应该实现的要求</li>\n<li><strong>不易使用</strong>：软件难以理解，不易使用，运行缓慢，用户体验不好。</li>\n</ul>\n<h3 id=\"11-2-缺陷产生的原因\"><a href=\"#11-2-缺陷产生的原因\" class=\"headerlink\" title=\"11.2 缺陷产生的原因\"></a>11.2 缺陷产生的原因</h3><p>从需求到发布是一个线性的过程。其中一个环节出错，都会导致缺陷</p>\n<ul>\n<li><p>阶段1. 需求阶段</p>\n<p>需求描述不易理解，有歧义，错误</p>\n</li>\n<li><p>阶段2. <strong>设计阶段</strong></p>\n<p>设计文档存在错误和缺陷</p>\n</li>\n<li><p>阶段3. <strong>编码阶段</strong></p>\n<p>代码出现错误</p>\n</li>\n<li><p>阶段4. <strong>运行阶段</strong></p>\n<p>软硬件系统本身故障导致软件缺陷</p>\n</li>\n</ul>\n<h3 id=\"11-3-缺陷的生命周期\"><a href=\"#11-3-缺陷的生命周期\" class=\"headerlink\" title=\"11.3 缺陷的生命周期\"></a>11.3 缺陷的生命周期</h3><p><img src=\"/../img/image-20231009225919124.png\" alt=\"image-20231009225919124\"></p>\n<h3 id=\"11-4-缺陷的核心内容\"><a href=\"#11-4-缺陷的核心内容\" class=\"headerlink\" title=\"11.4 缺陷的核心内容\"></a>11.4 缺陷的核心内容</h3><ul>\n<li>缺陷标题</li>\n<li>缺陷预期结果</li>\n<li>缺陷产生的条件</li>\n<li>因缺陷得到的结果</li>\n<li>复现缺陷的过程</li>\n<li>缺陷的证据</li>\n</ul>\n<h3 id=\"11-5-缺陷的提交要素\"><a href=\"#11-5-缺陷的提交要素\" class=\"headerlink\" title=\"11.5 缺陷的提交要素\"></a>11.5 缺陷的提交要素</h3><p><img src=\"/../img/image-20231009232548604.png\" alt=\"image-20231009232548604\"></p>\n<h2 id=\"11-6-软件缺陷类型\"><a href=\"#11-6-软件缺陷类型\" class=\"headerlink\" title=\"11.6 软件缺陷类型\"></a>11.6 软件缺陷类型</h2><ul>\n<li>功能错误</li>\n<li>UI错误</li>\n<li>兼容性</li>\n<li>数据</li>\n<li>易用性</li>\n<li>改进</li>\n<li>架构</li>\n</ul>\n<h3 id=\"11-7-缺陷的跟踪流程\"><a href=\"#11-7-缺陷的跟踪流程\" class=\"headerlink\" title=\"11.7 缺陷的跟踪流程\"></a>11.7 缺陷的跟踪流程</h3><p><img src=\"/../img/image-20231010000541057.png\" alt=\"image-20231010000541057\"></p>\n<h3 id=\"11-8-缺陷模板\"><a href=\"#11-8-缺陷模板\" class=\"headerlink\" title=\"11.8 缺陷模板\"></a>11.8 缺陷模板</h3><p><img src=\"/../img/image-20231010001511880.png\" alt=\"image-20231010001511880\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-主流测试技术\"><a href=\"#1-主流测试技术\" class=\"headerlink\" title=\"1. 主流测试技术\"></a>1. 主流测试技术</h2><h3 id=\"1-1-功能测试\"><a href=\"#1-1-功能测试\" class=\"headerlink\" title=\"1.1 功能测试\"></a>1.1 功能测试</h3><blockquote>\n<p>验证程序的功能是否能满足需求</p>\n</blockquote>\n<h3 id=\"1-2-自动化测试\"><a href=\"#1-2-自动化测试\" class=\"headerlink\" title=\"1.2 自动化测试\"></a>1.2 自动化测试</h3><blockquote>\n<p>使用代码或工具代替手工，对项目进行测试</p>\n</blockquote>\n<h3 id=\"1-3-接口测试\"><a href=\"#1-3-接口测试\" class=\"headerlink\" title=\"1.3 接口测试\"></a>1.3 接口测试</h3><blockquote>\n<p>测接口。</p>\n</blockquote>\n<h3 id=\"1-4-性能测试\"><a href=\"#1-4-性能测试\" class=\"headerlink\" title=\"1.4 性能测试\"></a>1.4 性能测试</h3><blockquote>\n<p>模拟多人使用软件，查找服务器缺陷。</p>\n</blockquote>\n<h2 id=\"2-测试分类\"><a href=\"#2-测试分类\" class=\"headerlink\" title=\"2.测试分类\"></a>2.测试分类</h2><h3 id=\"2-1-按测试阶段划分\"><a href=\"#2-1-按测试阶段划分\" class=\"headerlink\" title=\"2.1 按测试阶段划分\"></a>2.1 按测试阶段划分</h3><blockquote>\n<p>单元、集成、系统、验收</p>\n</blockquote>\n<p>单元：针对源代码测试（开发自己做）</p>\n<p>集成：接口测试。针对模块之间访问进行测试。</p>\n<p>系统：对整个系统进行测试。（功能、兼容、文档等测试）</p>\n<p>验收：内测、公测。不同人群对项目提供反馈。</p>\n<h3 id=\"2-2-按代码可见度划分\"><a href=\"#2-2-按代码可见度划分\" class=\"headerlink\" title=\"2.2 按代码可见度划分\"></a>2.2 按代码可见度划分</h3><h4 id=\"2-2-1-黑盒测试\"><a href=\"#2-2-1-黑盒测试\" class=\"headerlink\" title=\"2.2.1 黑盒测试\"></a>2.2.1 黑盒测试</h4><p>属于系统测试</p>\n<ol>\n<li>源代码不可见</li>\n<li>UI可见</li>\n</ol>\n<h4 id=\"2-2-2-灰盒测试\"><a href=\"#2-2-2-灰盒测试\" class=\"headerlink\" title=\"2.2.2 灰盒测试\"></a>2.2.2 灰盒测试</h4><p>属于接口测试（集成测试）</p>\n<ol>\n<li><p>部分源代码可见</p>\n</li>\n<li><p>功能不可见（只有纯接口）</p>\n</li>\n</ol>\n<h4 id=\"2-2-3-白盒测试\"><a href=\"#2-2-3-白盒测试\" class=\"headerlink\" title=\"2.2.3 白盒测试\"></a>2.2.3 白盒测试</h4><p>属于单元测试</p>\n<ol>\n<li>源代码完全可见</li>\n<li>UI不可见</li>\n</ol>\n<h2 id=\"3-质量模型\"><a href=\"#3-质量模型\" class=\"headerlink\" title=\"3. 质量模型\"></a>3. 质量模型</h2><blockquote>\n<p>质量模型用于衡量一个优秀软件的维度。</p>\n</blockquote>\n<ul>\n<li><p>功能性</p>\n</li>\n<li><p>性能：每秒请求数 &lt;&#x3D; 服务器硬件是否满足</p>\n</li>\n<li><p>兼容性：多平台。浏览器、操作系统、分辨率、网络、应用之间</p>\n</li>\n<li><p>易用性：简洁、友好、流畅、美观</p>\n</li>\n<li><p>可靠性：卡顿、服务器宕机、闪退</p>\n</li>\n<li><p>安全：信息传输，存储。加密。</p>\n</li>\n<li><p>可维护性</p>\n</li>\n<li><p>可移植性</p>\n</li>\n</ul>\n<h2 id=\"4-测试流程\"><a href=\"#4-测试流程\" class=\"headerlink\" title=\"4. 测试流程\"></a>4. 测试流程</h2><ol>\n<li>需求评审<br>确保各部门需求理解一致</li>\n<li>计划编写<br>测什么、谁来测、怎么测、</li>\n<li>用例设计<br>验证项目是否符合需求的操作文档</li>\n<li>用例执行<br>项目模块开发完成后，执行用例文档，实施测试</li>\n<li>缺陷管理<br>对缺陷进行管理</li>\n<li>测试报告<br>实施测试结果文档</li>\n</ol>\n<h2 id=\"5-测试用例\"><a href=\"#5-测试用例\" class=\"headerlink\" title=\"5. 测试用例\"></a>5. 测试用例</h2><blockquote>\n<p>用例：用户使用的案例。</p>\n<p>测试用例：为测试项目而设计的执行文档</p>\n</blockquote>\n<h3 id=\"5-1-测试用例的作用\"><a href=\"#5-1-测试用例的作用\" class=\"headerlink\" title=\"5.1 测试用例的作用\"></a>5.1 测试用例的作用</h3><ol>\n<li>防止漏测</li>\n<li>实施测试的标准</li>\n</ol>\n<h3 id=\"5-2-用例设计编写格式\"><a href=\"#5-2-用例设计编写格式\" class=\"headerlink\" title=\"5.2 用例设计编写格式\"></a>5.2 用例设计编写格式</h3><p>八大要素：用例编号，用例标题，项目&#x2F;模块，优先级，前置条件，测试步骤，测试数据，预期结果</p>\n<ul>\n<li><p>用例编号: 项目_ 模块 _编号</p>\n</li>\n<li><p>用例标题：预期结果（测试点）</p>\n</li>\n<li><p>项目&#x2F;模块：所属项目或模块</p>\n</li>\n<li><p>优先级：表示用例的重要程度或影响力。从p0到p4。最高为p0</p>\n<ul>\n<li>核心功能：用户、高频</li>\n</ul>\n</li>\n<li><p>前置条件：要执行词条用力，有哪些前置操作</p>\n<ul>\n<li>测试登录：先要打开登录页面，才能。。。</li>\n</ul>\n</li>\n<li><p>测试步骤：描述操作步骤</p>\n</li>\n<li><p>测试数据：操作的数据，没有的话可以为空</p>\n</li>\n<li><p>预期结果：期望达到的结果</p>\n</li>\n</ul>\n<p>demo:</p>\n<p><img src=\"/../img/image-20231005073508368.png\" alt=\"image-20231005073508368\"></p>\n<h4 id=\"5-2-1-Excel下拉复制的同时使数字不会自增\"><a href=\"#5-2-1-Excel下拉复制的同时使数字不会自增\" class=\"headerlink\" title=\"5.2.1 Excel下拉复制的同时使数字不会自增\"></a>5.2.1 Excel下拉复制的同时使数字不会自增</h4><p>按住ctrl然后下拉</p>\n<h2 id=\"6-等价类划分法\"><a href=\"#6-等价类划分法\" class=\"headerlink\" title=\"6. 等价类划分法\"></a>6. 等价类划分法</h2><blockquote>\n<p>在所有的测试数据中，具有某种共同特种的数据集合进行划分。划分之后的结果分为两类：</p>\n<ul>\n<li>有效等价类：满足需求的数据集合<ul>\n<li>需求：统计出生时性别为男孩的人数。则所有新生儿中男孩为有效</li>\n</ul>\n</li>\n<li>无效等价类：不满足需求的数据结合<ul>\n<li>上面例子中的女孩。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"6-1-Demo：验证账号的合法性\"><a href=\"#6-1-Demo：验证账号的合法性\" class=\"headerlink\" title=\"6.1 Demo：验证账号的合法性\"></a>6.1 Demo：验证账号的合法性</h3><ul>\n<li>需求：账号长度需要是6~ 10位自然数</li>\n</ul>\n<p>步骤：</p>\n<ol>\n<li>明确需求<ul>\n<li>账号长度需要是6~ 10位自然数</li>\n</ul>\n</li>\n<li>划分有效等价类<ul>\n<li>有效：八位</li>\n<li>无效：三位、十二位</li>\n</ul>\n</li>\n<li>提取数据，编写用例<ul>\n<li>八位：12345678</li>\n<li>三位：123</li>\n<li>十二位：123456789012</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/../img/image-20231005092614348.png\" alt=\"image-20231005092614348\"></p>\n<h4 id=\"6-1-1-根据类型完善\"><a href=\"#6-1-1-根据类型完善\" class=\"headerlink\" title=\"6.1.1 根据类型完善\"></a>6.1.1 根据类型完善</h4><p><img src=\"/../img/image-20231005093309025.png\" alt=\"image-20231005093309025\"></p>\n<blockquote>\n<p>需求最多也就可以被分成：长度、类型、规则</p>\n</blockquote>\n<h3 id=\"6-2-Demo：电话号码\"><a href=\"#6-2-Demo：电话号码\" class=\"headerlink\" title=\"6.2 Demo：电话号码\"></a>6.2 Demo：电话号码</h3><p>要求：</p>\n<ol>\n<li>区号：空或者是三位数字</li>\n<li>前缀码：非”0”且非”1”开头的三位数字</li>\n<li>后缀码：四位数字</li>\n</ol>\n<p><img src=\"/../img/image-20231005121023638.png\" alt=\"image-20231005121023638\"></p>\n<h3 id=\"6-3-等价类适用场景\"><a href=\"#6-3-等价类适用场景\" class=\"headerlink\" title=\"6.3 等价类适用场景\"></a>6.3 等价类适用场景</h3><p>需要有大量的数据测试输入，但是没法穷举测试的地方</p>\n<ul>\n<li>输入框</li>\n<li>下拉列表</li>\n<li>单选、复选框</li>\n</ul>\n<h2 id=\"7-边界值分析方法\"><a href=\"#7-边界值分析方法\" class=\"headerlink\" title=\"7. 边界值分析方法\"></a>7. 边界值分析方法</h2><h3 id=\"7-1-边界范围节点\"><a href=\"#7-1-边界范围节点\" class=\"headerlink\" title=\"7.1  边界范围节点\"></a>7.1  边界范围节点</h3><ul>\n<li><p>选择<strong>正好等于</strong>、<strong>刚好大于</strong>、<strong>刚好小于</strong>边界的值作为测试数据</p>\n<ul>\n<li>上点： 边界<strong>上</strong>的点（正好等于)</li>\n<li>离点： 距离上点距离最近的点（刚好大于<strong>、</strong>刚好小于)</li>\n<li>内点： 范围内的点（一般取中间的）</li>\n</ul>\n</li>\n<li><p>这样算下来。最多7条。（两个商店，四个离点，一个内点）</p>\n</li>\n<li><p>注意：内点需要两条用例（正反）</p>\n</li>\n<li><p>Demo：等价类和边界值合一块写</p>\n<ul>\n<li>要求：账号长度需要是6到10位自然数（6和10也可以）<br><img src=\"/../img/image-20231008234542259.png\" alt=\"image-20231008234542259\"></li>\n</ul>\n</li>\n<li><p>从这个例子不难看出。其实等价类的分析：长度、类型、规则，其实结合了边界值之后，<strong>长度，规则</strong>这两点就交给边界值分析了。比如对要求账号是6到10位，那么有效等价就是自然数，无效等价就是非自然数。而原先哪些长度，规则，就由边界值进行判定。</p>\n</li>\n</ul>\n<h3 id=\"7-2-优化\"><a href=\"#7-2-优化\" class=\"headerlink\" title=\"7.2 优化\"></a>7.2 优化</h3><p><strong>开内闭外</strong>：开区间选内点，闭区间选外点</p>\n<p>开区间：边界点<strong>没有等号</strong>   （如大于0小于10）</p>\n<p>闭区间：边界上的点有等号（如大于等于0小于等于10)</p>\n<p>那么可以看到上面的案例中，因为6和10时包含的，那么属于双闭，选外点。那么内点7和9就不需要了。数量优化到5点。</p>\n<h2 id=\"8-判定表\"><a href=\"#8-判定表\" class=\"headerlink\" title=\"8. 判定表\"></a>8. 判定表</h2><blockquote>\n<p>很多场景，用例存在<strong>条件依赖</strong>关系。比如欠费就停机。这时候就无法单一地去测了。</p>\n</blockquote>\n<ul>\n<li>等价类以及边界值更加关注<strong>单个输入类条件</strong>的测试</li>\n<li>并未考虑输入条件之间的组合，输入条件和输出结果之间的依赖关系。</li>\n</ul>\n<p>判定表：以表格的形式表达 多条件逻辑判断 的工具</p>\n<ul>\n<li>组成：<ol>\n<li>条件桩：列出问题中的所有条件。次序是无关紧要的</li>\n<li>动作桩：列出问题中可能采取的操作。操作的顺序同样无关紧要</li>\n<li>条件项：条件的取值</li>\n<li>操作：条件叠加后的结果</li>\n</ol>\n</li>\n</ul>\n<p><img src=\"/../img/image-20231009001757777.png\" alt=\"image-20231009001757777\"></p>\n<ul>\n<li><p>假设有n个条件，每个条件取值有m个，全部组合就有m的n次方种规格。当然，绝大多数的情况下，条件的取值有2个</p>\n</li>\n<li><p>像上图这样把表格整理出来后，每一列都是一个用例。</p>\n</li>\n<li><p>判定表一般适用于条件少于4个的情况，如果条件多于4个，就要用正交表了。</p>\n</li>\n</ul>\n<h2 id=\"9-业务覆盖测试\"><a href=\"#9-业务覆盖测试\" class=\"headerlink\" title=\"9. 业务覆盖测试\"></a>9. 业务覆盖测试</h2><h3 id=\"9-1-流程图\"><a href=\"#9-1-流程图\" class=\"headerlink\" title=\"9.1 流程图\"></a>9.1 流程图</h3><blockquote>\n<p>业务用例是根据流程图来梳理的</p>\n</blockquote>\n<p><strong>开始和结尾</strong>用椭圆。</p>\n<p><strong>中间</strong>用<strong>判断语句</strong>连接。菱形</p>\n<p><strong>判断语句</strong>连接结果。</p>\n<p><img src=\"/../img/image-20231009143738559.png\" alt=\"image-20231009143738559\"></p>\n<h3 id=\"9-2-ATM-Demo\"><a href=\"#9-2-ATM-Demo\" class=\"headerlink\" title=\"9.2 ATM Demo\"></a>9.2 ATM Demo</h3><p><img src=\"/../img/image-20231009213653825.png\" alt=\"image-20231009213653825\"></p>\n<p><img src=\"/../img/image-20231009213702116.png\" alt=\"image-20231009213702116\"></p>\n<p><img src=\"/../img/image-20231009213724620.png\" alt=\"image-20231009213724620\"></p>\n<ul>\n<li>其实就是把退出的场景都测一遍。然后流程通过的场景测一遍。</li>\n</ul>\n<h2 id=\"10-错误推荐法\"><a href=\"#10-错误推荐法\" class=\"headerlink\" title=\"10. 错误推荐法\"></a>10. 错误推荐法</h2><blockquote>\n<p>当项目测试用例都执行完毕，且bug修复完成，项目尚未上线的情况下，在这段时间里可以 通过经验推测系统可能出现的问题，列出问题的清单，分析问题可能的原因。</p>\n</blockquote>\n<ul>\n<li>时间紧、任务量大 -&gt; 根据已有经验找出易出错的模块重点测试。</li>\n</ul>\n<h2 id=\"11-缺陷\"><a href=\"#11-缺陷\" class=\"headerlink\" title=\"11. 缺陷\"></a>11. 缺陷</h2><blockquote>\n<p>软件在使用过程中存在的<strong>任何问题</strong>都叫软件的缺陷，简称bug。</p>\n</blockquote>\n<h3 id=\"11-1-缺陷的判定标准\"><a href=\"#11-1-缺陷的判定标准\" class=\"headerlink\" title=\"11.1 缺陷的判定标准\"></a>11.1 缺陷的判定标准</h3><ul>\n<li><strong>少功能</strong>：软件未实现需求说明书中明确要求的功能</li>\n<li><strong>功能错误</strong>：软件中出现了需求说明书中指明不应该出现的错误</li>\n<li><strong>多功能</strong>： 软件实现的功能超出了需求说明书中指明的范围</li>\n<li><strong>隐性功能错误</strong>： 软件未实现需求说明书中虽未明确指明，但应该实现的要求</li>\n<li><strong>不易使用</strong>：软件难以理解，不易使用，运行缓慢，用户体验不好。</li>\n</ul>\n<h3 id=\"11-2-缺陷产生的原因\"><a href=\"#11-2-缺陷产生的原因\" class=\"headerlink\" title=\"11.2 缺陷产生的原因\"></a>11.2 缺陷产生的原因</h3><p>从需求到发布是一个线性的过程。其中一个环节出错，都会导致缺陷</p>\n<ul>\n<li><p>阶段1. 需求阶段</p>\n<p>需求描述不易理解，有歧义，错误</p>\n</li>\n<li><p>阶段2. <strong>设计阶段</strong></p>\n<p>设计文档存在错误和缺陷</p>\n</li>\n<li><p>阶段3. <strong>编码阶段</strong></p>\n<p>代码出现错误</p>\n</li>\n<li><p>阶段4. <strong>运行阶段</strong></p>\n<p>软硬件系统本身故障导致软件缺陷</p>\n</li>\n</ul>\n<h3 id=\"11-3-缺陷的生命周期\"><a href=\"#11-3-缺陷的生命周期\" class=\"headerlink\" title=\"11.3 缺陷的生命周期\"></a>11.3 缺陷的生命周期</h3><p><img src=\"/../img/image-20231009225919124.png\" alt=\"image-20231009225919124\"></p>\n<h3 id=\"11-4-缺陷的核心内容\"><a href=\"#11-4-缺陷的核心内容\" class=\"headerlink\" title=\"11.4 缺陷的核心内容\"></a>11.4 缺陷的核心内容</h3><ul>\n<li>缺陷标题</li>\n<li>缺陷预期结果</li>\n<li>缺陷产生的条件</li>\n<li>因缺陷得到的结果</li>\n<li>复现缺陷的过程</li>\n<li>缺陷的证据</li>\n</ul>\n<h3 id=\"11-5-缺陷的提交要素\"><a href=\"#11-5-缺陷的提交要素\" class=\"headerlink\" title=\"11.5 缺陷的提交要素\"></a>11.5 缺陷的提交要素</h3><p><img src=\"/../img/image-20231009232548604.png\" alt=\"image-20231009232548604\"></p>\n<h2 id=\"11-6-软件缺陷类型\"><a href=\"#11-6-软件缺陷类型\" class=\"headerlink\" title=\"11.6 软件缺陷类型\"></a>11.6 软件缺陷类型</h2><ul>\n<li>功能错误</li>\n<li>UI错误</li>\n<li>兼容性</li>\n<li>数据</li>\n<li>易用性</li>\n<li>改进</li>\n<li>架构</li>\n</ul>\n<h3 id=\"11-7-缺陷的跟踪流程\"><a href=\"#11-7-缺陷的跟踪流程\" class=\"headerlink\" title=\"11.7 缺陷的跟踪流程\"></a>11.7 缺陷的跟踪流程</h3><p><img src=\"/../img/image-20231010000541057.png\" alt=\"image-20231010000541057\"></p>\n<h3 id=\"11-8-缺陷模板\"><a href=\"#11-8-缺陷模板\" class=\"headerlink\" title=\"11.8 缺陷模板\"></a>11.8 缺陷模板</h3><p><img src=\"/../img/image-20231010001511880.png\" alt=\"image-20231010001511880\"></p>\n"},{"title":"接口测试","date":"2023-02-12T14:34:49.000Z","cover":"/img/rice.jpg","_content":"## 1. 回顾\n\n### 1.1 URL\n\n**URL**： 统一资源定位符\n\n**格式**： 协议://hostname:port/path?参数=值&参数2=值\n\n**默认端口号**可以不写\n\nhttp:80\n\nhttps:443\n\n### 1.2 HTTP / HTTPS\n\n超文本传输协议。基于响应和请求的应用层协议\n\n规定了客户端和服务器之间信息的传递规范。\n\n组成：\n\n* HTTP请求定义了请求数据格式\n* HTTP响应定义了响应数据格式\n\n#### 1.2.1 HTTP 请求行\n\n位于请求数据的第一行。表明了请求方式，访问的资源，协议版本\n\n格式：[请求方法] [url] [协议/协议版本]\n\n常用请求方法：\n\n1. POST 在服务器新建一个资源\n2. GET 从服务器获取资源\n3. DELETE 从服务器删除资源\n4. PUT 在服务器更新资源\n\n#### 1.2.2 HTTP 请求头 \n\n> Request-header\n\n位于请求数据的**第二行到空白行之间**。作用是通知服务器客户端的请求信息。请求头部由**键值对**组成。每行一对。\n\n常见的参数：\n\nHost、User-Agent、Content-Type\n\nContent-Type用于表明**请求体**的数据类型，通常有：\n\n* text/html\n* image/jpeg\n* application/json\n* application/x-www-form-urlencoded\n* mutipart/form-data\n\n#### 1.2.3 HTTP 请求体\n\n> Request-body\n>\n> body-parameters\n\n请求体就是请求下面的空白行下面的内容。常配合的请求头有上面讲的Content-Type，标明请求体的类型。还有Content-Length，标明请求体的长度。\n\n* 请求报文可以没有请求体\n\n#### 1.2.4 HTTP 响应 - 状态行\n\n处于响应数据第一行。用于描述服务器处理结果\n\n格式：【协议版本号】【状态码】【状态消息】\n\n状态码：三位数字\n\n* 1xx: 指示信息\n* 2xx: 成功\n* 3xx: 重定向\n* 4xx: 客户端错误\n* 5xx: 服务端错误\n\n#### 1.2.5 HTTP 响应 - 响应头\n\n和请求头的位置一样。用于描述客户端想要的一些附加信息。同样由键值对组成\n\n#### 1.2.6 HTTP 响应 - 响应体\n\n和请求体位置一样。数据类型类似。是服务器返回的数据实体。\n\n## 2. Charles\n\n> 下载地址：https://www.charlesproxy.com/download/\n>\n> 激活：https://www.zzzmode.com/mytools/charles/\n\n### 2.1 什么是Charles\n\nCharles，是一个基于**HTTP协议**的代理服务器。通过成为电脑或者是浏览器的代理，从而**截取请求和请求结果**，以达到抓包分析的目的。\n\n### 2.2 Charles 工作流程\n\nCharles的工作流程，其实就是在主机和互联网之间，加一个代理服务器。主机发送请求的时候，先发到charles上，由charles转发给服务器。接受时候同理。\n\n### 2.3 Charles功能\n\n* 支持HTTP和HTTPS代理\n* 支持**流量控制**（弱网环境）\n* 支持接口**并发**请求\n* 支持**重发网络请求**\n* 支持断点调试（构建异常的测试场景）\n\n### 2.4 补票\n\n## 3. 接口规范\n\n### 3.1 传统接口风格\n\nURL体现了业务增删改查操作。\n\nhttp://localhost:80/user/getAllUsers\n\nhttps://localhost:80/deleteUser?id=1\n\n这种就是传统的接口\n\n### 3.2 RESTful接口风格\n\nURL中只**定义了需要操作的对象**。\n\nhttps://localhost:80/app/users/1 : 操作user集合的中编号为1的对象。\n\n* 请求API的URL用来定位**资源**（也就是对象）。\n* 通过HTTP请求方式，来对资源进行增删改查操作。\n  * 查：GET\n  * 增：POST\n  * 改：PUT\n  * 删：DELETE\n\n* 状态码遵循HTTP状态码协议。\n\n## 4. 业务流程 vs 单个模块\n\n拿到一个项目后，**先测试**业务流程，确保**核心功能**正常。\n\n### 4.1 如何设计业务流程测试用例\n\n1. 根据流程图，找业务路径\n2. 根据业务路径分析对应的接口请求\n3. 将业务路径转化为接口测试用例\n\n* 找出现问题的点。正常通过的只用测一次（一路走到底）\n\n因此，对于下面这个新增合同业务，我们可以设计出以下用例：\n\n![image-20231012013204347](../img/image-20231012013204347.png)\n\n1. 合同新增成功：登录（成功）-> 添加课程（成功）-> 上传合同（成功）-> 新增合同（成功\n2. 合同新增失败（登录失败）\n3. 合同新增失败 （添加课程失败）：登陆（成功）\n4. 合同新增失败 （上传合同失败）：登录（成功）-> 添加课程（成功）\n5. 合同新增失败 （新增合同失败）：登录（成功）-> 添加课程（成功）-> 上传合同（成功）\n\n## 5. 接口文档\n\n> 接口API文档一般由后端开发编写，用于描述接口信息。\n>\n> ![image-20231012015303012](../img/image-20231012015303012.png)\n\n对于接口测试来讲，主要就是分析接口文档中的三点：\n\n1.  接口之间的依赖关系\n2.  接口请求（URL，请求方法，请求头，请求参数类型，请求参数）\n3.  接口响应（状态码，响应信息）\n\n\n\n* 基本就是跟着接口文档，在测试用例里面复制黏贴就行。接口文档里没写的，测试用例里用“/”占位。\n\n![image-20231012020112675](../img/image-20231012020112675.png)\n\n## 6. Postman \n> 一款接口调试工具\n\n### 6.1 Demo:验证码接口\n\n**URL**: http://kdtx-test.itheima.net/api/captchaImage\n\n* 设置请求方式 (GET)\n* 输入接口地址 (...)\n* 点击发送请求\n* 查看响应结果\n\n### 6.2 Demo: 登录接口\n\n**URL**: http://kdtx-test.itheima.net/api/login 方法： POST\n\n**请求头**： Content-Type： application/json\n\n**请求体**： {\"username\":\"admin\", \"password\":\"HM_2023_test\",\"code\":\"2\",\"uuid\":\"验证码接口中uuid请求结果\"}\n\n* 设置请求方式 (GET)\n* 输入接口地址 (...)\n* 点击发送请求\n* 查看响应结果\n\n---\n\n**问题**： 每次使用登录接口，都需要**手动**复制验证码接口的返回结果，很麻烦\n\nPostman为我们提供了一个**公共容器**，用于保存相关联的数据。\n\n### 6.3 环境变量\n\n![image-20231012150414097](../img/image-20231012150414097.png)\n\n\n\n#### 6.3.1 通过javascript操作响应json，并存入环境变量\n\nPostman**内置Test**，可以运行Javascript。通过这一点，可以动态地获取并保存环境变量\n\n\n\n##### 6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\n\n![image-20231012152302176](../img/image-20231012152302176.png)\n\n![image-20231012152314404](../img/image-20231012152314404.png)\n\n\n\n##### 6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。\n\n![image-20231012175222772](../img/image-20231012175222772.png)\n\n![image-20231012175230820](../img/image-20231012175230820.png)\n\n\n\n### 6.4 处理mutipart/form-data数据\n\n接口可能会这样子写\n\n![image-20231013020924815](../img/image-20231013020924815.png)\n\n这时候请求体类型就得是form-data类型了。Key看文档，file看文档文件路径。\n\n![image-20231013021007971](../img/image-20231013021007971.png)\n\n这里上传接口又依赖登录接口请求成功后，返回的token。因此，需要在登录接口中将token存入环境变量\n\n![image-20231013021122908](../img/image-20231013021122908.png)\n\n并在上传接口的Request-Headers，添加Authorization：{{token}}\n\n\n\n### 6.5 Postman中的Request Param\n\n![image-20231013224552169](../img/image-20231013224552169.png)\n\n\n\n### 6.6 批量执行\n\n> 这些合同查询、上传、新增操作，都依赖于登录时候提供的token进行鉴权。问题是，用户登录是会过期的。我们不可能每次要去进行操作，都手动把每个接口的流程走一遍，因此，postman提供了批量执行测试用例。\n\n![image-20231013230802520](../img/image-20231013230802520.png)\n\n\n\n## 7. 设计接口用例\n\n对于 **单接口测试**，设计思路通常分为两类： **正向测试**和**逆向（反向）测试**\n\n### 7.1 正向测试\n\n包含： \n\n* 必填参数 P2\n* 全部参数 p2\n\n### 7.2 逆向测试\n\n包含：\n\n* 参数数据为空 p3\n* 参数类型不符 p3\n* 参数长度不符 p3\n* 业务规则不符 p3\n\n正向测试的优先级**永远高于**逆向测试\n\n逆向测试可以理解成**对正向测试里的参数的对立面进行测试**\n\ne.g. 登录接口测试用例\n\n![image-20231014014917998](../img/image-20231014014917998.png)\n\n\n\n### 7.3 Postman按模块管理测试用例\n\n![image-20231014020213977](../img/image-20231014020213977.png)\n\n按照上面的箭头，先在Collection中创建folder，然后再folder中创建对应接口的request测试用例。\n\n下面是对于**登录接口**的**用户名**设计的**三个**正向和反向测试用例\n\n![image-20231014020042107](../img/image-20231014020042107.png)\n\n\n\n#### 补票：Postman断言\n\n> Postman提供了test()方法，用于自动地检测response中的结果是否与预期结果一致。\n\n常用断言包括：\n\n* 响应状态码(Status code)\n\n  ![image-20231014020902573](../img/image-20231014020902573.png)\n\n  **直接点击对应snippet就会自动再Tests编辑区域生成 **\n\n* 响应包含指定字符串 (Contains string)\n\n* JSON断言（JSON value check)\n\n  写完之后发送下，如果符合预期结果的话，应该是绿色。\n\n  \n\n![image-20231014022802984](../img/image-20231014022802984.png)\n\n#### 补票：Postman参数化\n\n> 从上面的断言例子可以看出。如果对同一接口进行正反向测试时候，每次测试都需要将Tests内的代码或者是headers、body中的值进行复制黏贴。很麻烦。因此，postman提供了参数化，可以直接准备好的数据文件中，读取数据\n\n步骤：\n\n1. 准备数据文件\n\n2. 引用数据文件数据\n\n   headers、body：{{key}}\n\n   代码：data.key\n\n3. 在**批量执行**的页面，select file选择数据文件。\n\n\n\nJSON数据格式：\n\n```json\n[\n    {\"username\":\"admin\", \"password\":\"HM_2023_test\", \"status\":\"200\", \"contain_message\":\"作成功\", \"msg\": \"操作成功\"},\n    {\"username\":\"\", \"password\":\"HM_2023_test\", \"status\":\"500\", \"contain_message\":\"作成功\", \"msg\": \"用户不存在/密码错误\"},\n    {\"username\":\"admin1\", \"password\":\"HM_2023_test\", \"status\":\"500\", \"contain_message\":\"作成功\", \"msg\": \"用户不存在/密码错误\"}\n]\n```\n\n![image-20231014034148547](../img/image-20231014034148547.png)\n\n注意，在编写json数据时，务必看好接口文档里的参数类型。如果是string类型则不要忘了双引号。如果是数字类型则不用双引号。\n\n这里，如果将\"status\"设为String类型的\"200\"，则会导致测试用例无法通过。\n\n如图：\n\n![image-20231014034455018](../img/image-20231014034455018.png)\n\n![image-20231014034510599](../img/image-20231014034510599.png)\n\n\n\n> 下面的用例，有时间可以往postman里填下，练练手。重要的还是看怎么设计用例。填数据没难度。\n\n#### 7.3.1 Demo: 课程添加接口的用例设计\n\n![image-20231014040059430](../img/image-20231014040059430.png)\n\n因为这个接口依赖于登录成功后返回的token，因此，正向中的两个用例需要补充一下说明：是在登录成功的前提下,进行.....。同理，逆向中，还需要添加一条测试用例：![image-20231014040254573](../img/image-20231014040254573.png)\n\n\n\n\n\n#### 7.3.2 课程查询接口的用例设计\n\n![image-20231014054102698](../img/image-20231014054102698.png)\n\n> 对应的用例文档\n\n![image-20231014054644739](../img/image-20231014054644739.png)\n\n![image-20231014054559197](../img/image-20231014054559197.png)\n\n\n\n#### 7.3.3 课程修改接口用例设计\n\n![image-20231014055926821](../img/image-20231014055926821.png)\n\n![image-20231014060539030](../img/image-20231014060539030.png)\n\n\n\n#### 7.3.4 课程删除接口测试用例设计\n\n![image-20231014061221536](../img/image-20231014061221536.png)\n\n![image-20231014061610452](../img/image-20231014061610452.png)\n\n这里的id是**路径参数**\n\n##### 7.3.4.1 路径参数\n\n> PathVariable\n\nURL中**末尾一级**的参数\n\n如： http://kdtx-test.itheima.net/api/clues/course/111\n\n在Postman中有两种方式添加Path Variable。第一种就是**直接在url中添加**，第二种是**url末尾加**```:id```\n\n![image-20231014061840143](../img/image-20231014061840143.png)\n\n\n\n以上内容为接口测试的基础理论与样例。下面是使用TestNG\n\n------\n\n","source":"_posts/接口自动化.md","raw":"---\ntitle: 接口测试\ndate: 2023-2-12 09:34:49\ntags:\n    - 软件测试\n\ncategories:\n    - 软件测试    \n\ncover: /img/rice.jpg\n---\n## 1. 回顾\n\n### 1.1 URL\n\n**URL**： 统一资源定位符\n\n**格式**： 协议://hostname:port/path?参数=值&参数2=值\n\n**默认端口号**可以不写\n\nhttp:80\n\nhttps:443\n\n### 1.2 HTTP / HTTPS\n\n超文本传输协议。基于响应和请求的应用层协议\n\n规定了客户端和服务器之间信息的传递规范。\n\n组成：\n\n* HTTP请求定义了请求数据格式\n* HTTP响应定义了响应数据格式\n\n#### 1.2.1 HTTP 请求行\n\n位于请求数据的第一行。表明了请求方式，访问的资源，协议版本\n\n格式：[请求方法] [url] [协议/协议版本]\n\n常用请求方法：\n\n1. POST 在服务器新建一个资源\n2. GET 从服务器获取资源\n3. DELETE 从服务器删除资源\n4. PUT 在服务器更新资源\n\n#### 1.2.2 HTTP 请求头 \n\n> Request-header\n\n位于请求数据的**第二行到空白行之间**。作用是通知服务器客户端的请求信息。请求头部由**键值对**组成。每行一对。\n\n常见的参数：\n\nHost、User-Agent、Content-Type\n\nContent-Type用于表明**请求体**的数据类型，通常有：\n\n* text/html\n* image/jpeg\n* application/json\n* application/x-www-form-urlencoded\n* mutipart/form-data\n\n#### 1.2.3 HTTP 请求体\n\n> Request-body\n>\n> body-parameters\n\n请求体就是请求下面的空白行下面的内容。常配合的请求头有上面讲的Content-Type，标明请求体的类型。还有Content-Length，标明请求体的长度。\n\n* 请求报文可以没有请求体\n\n#### 1.2.4 HTTP 响应 - 状态行\n\n处于响应数据第一行。用于描述服务器处理结果\n\n格式：【协议版本号】【状态码】【状态消息】\n\n状态码：三位数字\n\n* 1xx: 指示信息\n* 2xx: 成功\n* 3xx: 重定向\n* 4xx: 客户端错误\n* 5xx: 服务端错误\n\n#### 1.2.5 HTTP 响应 - 响应头\n\n和请求头的位置一样。用于描述客户端想要的一些附加信息。同样由键值对组成\n\n#### 1.2.6 HTTP 响应 - 响应体\n\n和请求体位置一样。数据类型类似。是服务器返回的数据实体。\n\n## 2. Charles\n\n> 下载地址：https://www.charlesproxy.com/download/\n>\n> 激活：https://www.zzzmode.com/mytools/charles/\n\n### 2.1 什么是Charles\n\nCharles，是一个基于**HTTP协议**的代理服务器。通过成为电脑或者是浏览器的代理，从而**截取请求和请求结果**，以达到抓包分析的目的。\n\n### 2.2 Charles 工作流程\n\nCharles的工作流程，其实就是在主机和互联网之间，加一个代理服务器。主机发送请求的时候，先发到charles上，由charles转发给服务器。接受时候同理。\n\n### 2.3 Charles功能\n\n* 支持HTTP和HTTPS代理\n* 支持**流量控制**（弱网环境）\n* 支持接口**并发**请求\n* 支持**重发网络请求**\n* 支持断点调试（构建异常的测试场景）\n\n### 2.4 补票\n\n## 3. 接口规范\n\n### 3.1 传统接口风格\n\nURL体现了业务增删改查操作。\n\nhttp://localhost:80/user/getAllUsers\n\nhttps://localhost:80/deleteUser?id=1\n\n这种就是传统的接口\n\n### 3.2 RESTful接口风格\n\nURL中只**定义了需要操作的对象**。\n\nhttps://localhost:80/app/users/1 : 操作user集合的中编号为1的对象。\n\n* 请求API的URL用来定位**资源**（也就是对象）。\n* 通过HTTP请求方式，来对资源进行增删改查操作。\n  * 查：GET\n  * 增：POST\n  * 改：PUT\n  * 删：DELETE\n\n* 状态码遵循HTTP状态码协议。\n\n## 4. 业务流程 vs 单个模块\n\n拿到一个项目后，**先测试**业务流程，确保**核心功能**正常。\n\n### 4.1 如何设计业务流程测试用例\n\n1. 根据流程图，找业务路径\n2. 根据业务路径分析对应的接口请求\n3. 将业务路径转化为接口测试用例\n\n* 找出现问题的点。正常通过的只用测一次（一路走到底）\n\n因此，对于下面这个新增合同业务，我们可以设计出以下用例：\n\n![image-20231012013204347](../img/image-20231012013204347.png)\n\n1. 合同新增成功：登录（成功）-> 添加课程（成功）-> 上传合同（成功）-> 新增合同（成功\n2. 合同新增失败（登录失败）\n3. 合同新增失败 （添加课程失败）：登陆（成功）\n4. 合同新增失败 （上传合同失败）：登录（成功）-> 添加课程（成功）\n5. 合同新增失败 （新增合同失败）：登录（成功）-> 添加课程（成功）-> 上传合同（成功）\n\n## 5. 接口文档\n\n> 接口API文档一般由后端开发编写，用于描述接口信息。\n>\n> ![image-20231012015303012](../img/image-20231012015303012.png)\n\n对于接口测试来讲，主要就是分析接口文档中的三点：\n\n1.  接口之间的依赖关系\n2.  接口请求（URL，请求方法，请求头，请求参数类型，请求参数）\n3.  接口响应（状态码，响应信息）\n\n\n\n* 基本就是跟着接口文档，在测试用例里面复制黏贴就行。接口文档里没写的，测试用例里用“/”占位。\n\n![image-20231012020112675](../img/image-20231012020112675.png)\n\n## 6. Postman \n> 一款接口调试工具\n\n### 6.1 Demo:验证码接口\n\n**URL**: http://kdtx-test.itheima.net/api/captchaImage\n\n* 设置请求方式 (GET)\n* 输入接口地址 (...)\n* 点击发送请求\n* 查看响应结果\n\n### 6.2 Demo: 登录接口\n\n**URL**: http://kdtx-test.itheima.net/api/login 方法： POST\n\n**请求头**： Content-Type： application/json\n\n**请求体**： {\"username\":\"admin\", \"password\":\"HM_2023_test\",\"code\":\"2\",\"uuid\":\"验证码接口中uuid请求结果\"}\n\n* 设置请求方式 (GET)\n* 输入接口地址 (...)\n* 点击发送请求\n* 查看响应结果\n\n---\n\n**问题**： 每次使用登录接口，都需要**手动**复制验证码接口的返回结果，很麻烦\n\nPostman为我们提供了一个**公共容器**，用于保存相关联的数据。\n\n### 6.3 环境变量\n\n![image-20231012150414097](../img/image-20231012150414097.png)\n\n\n\n#### 6.3.1 通过javascript操作响应json，并存入环境变量\n\nPostman**内置Test**，可以运行Javascript。通过这一点，可以动态地获取并保存环境变量\n\n\n\n##### 6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\n\n![image-20231012152302176](../img/image-20231012152302176.png)\n\n![image-20231012152314404](../img/image-20231012152314404.png)\n\n\n\n##### 6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。\n\n![image-20231012175222772](../img/image-20231012175222772.png)\n\n![image-20231012175230820](../img/image-20231012175230820.png)\n\n\n\n### 6.4 处理mutipart/form-data数据\n\n接口可能会这样子写\n\n![image-20231013020924815](../img/image-20231013020924815.png)\n\n这时候请求体类型就得是form-data类型了。Key看文档，file看文档文件路径。\n\n![image-20231013021007971](../img/image-20231013021007971.png)\n\n这里上传接口又依赖登录接口请求成功后，返回的token。因此，需要在登录接口中将token存入环境变量\n\n![image-20231013021122908](../img/image-20231013021122908.png)\n\n并在上传接口的Request-Headers，添加Authorization：{{token}}\n\n\n\n### 6.5 Postman中的Request Param\n\n![image-20231013224552169](../img/image-20231013224552169.png)\n\n\n\n### 6.6 批量执行\n\n> 这些合同查询、上传、新增操作，都依赖于登录时候提供的token进行鉴权。问题是，用户登录是会过期的。我们不可能每次要去进行操作，都手动把每个接口的流程走一遍，因此，postman提供了批量执行测试用例。\n\n![image-20231013230802520](../img/image-20231013230802520.png)\n\n\n\n## 7. 设计接口用例\n\n对于 **单接口测试**，设计思路通常分为两类： **正向测试**和**逆向（反向）测试**\n\n### 7.1 正向测试\n\n包含： \n\n* 必填参数 P2\n* 全部参数 p2\n\n### 7.2 逆向测试\n\n包含：\n\n* 参数数据为空 p3\n* 参数类型不符 p3\n* 参数长度不符 p3\n* 业务规则不符 p3\n\n正向测试的优先级**永远高于**逆向测试\n\n逆向测试可以理解成**对正向测试里的参数的对立面进行测试**\n\ne.g. 登录接口测试用例\n\n![image-20231014014917998](../img/image-20231014014917998.png)\n\n\n\n### 7.3 Postman按模块管理测试用例\n\n![image-20231014020213977](../img/image-20231014020213977.png)\n\n按照上面的箭头，先在Collection中创建folder，然后再folder中创建对应接口的request测试用例。\n\n下面是对于**登录接口**的**用户名**设计的**三个**正向和反向测试用例\n\n![image-20231014020042107](../img/image-20231014020042107.png)\n\n\n\n#### 补票：Postman断言\n\n> Postman提供了test()方法，用于自动地检测response中的结果是否与预期结果一致。\n\n常用断言包括：\n\n* 响应状态码(Status code)\n\n  ![image-20231014020902573](../img/image-20231014020902573.png)\n\n  **直接点击对应snippet就会自动再Tests编辑区域生成 **\n\n* 响应包含指定字符串 (Contains string)\n\n* JSON断言（JSON value check)\n\n  写完之后发送下，如果符合预期结果的话，应该是绿色。\n\n  \n\n![image-20231014022802984](../img/image-20231014022802984.png)\n\n#### 补票：Postman参数化\n\n> 从上面的断言例子可以看出。如果对同一接口进行正反向测试时候，每次测试都需要将Tests内的代码或者是headers、body中的值进行复制黏贴。很麻烦。因此，postman提供了参数化，可以直接准备好的数据文件中，读取数据\n\n步骤：\n\n1. 准备数据文件\n\n2. 引用数据文件数据\n\n   headers、body：{{key}}\n\n   代码：data.key\n\n3. 在**批量执行**的页面，select file选择数据文件。\n\n\n\nJSON数据格式：\n\n```json\n[\n    {\"username\":\"admin\", \"password\":\"HM_2023_test\", \"status\":\"200\", \"contain_message\":\"作成功\", \"msg\": \"操作成功\"},\n    {\"username\":\"\", \"password\":\"HM_2023_test\", \"status\":\"500\", \"contain_message\":\"作成功\", \"msg\": \"用户不存在/密码错误\"},\n    {\"username\":\"admin1\", \"password\":\"HM_2023_test\", \"status\":\"500\", \"contain_message\":\"作成功\", \"msg\": \"用户不存在/密码错误\"}\n]\n```\n\n![image-20231014034148547](../img/image-20231014034148547.png)\n\n注意，在编写json数据时，务必看好接口文档里的参数类型。如果是string类型则不要忘了双引号。如果是数字类型则不用双引号。\n\n这里，如果将\"status\"设为String类型的\"200\"，则会导致测试用例无法通过。\n\n如图：\n\n![image-20231014034455018](../img/image-20231014034455018.png)\n\n![image-20231014034510599](../img/image-20231014034510599.png)\n\n\n\n> 下面的用例，有时间可以往postman里填下，练练手。重要的还是看怎么设计用例。填数据没难度。\n\n#### 7.3.1 Demo: 课程添加接口的用例设计\n\n![image-20231014040059430](../img/image-20231014040059430.png)\n\n因为这个接口依赖于登录成功后返回的token，因此，正向中的两个用例需要补充一下说明：是在登录成功的前提下,进行.....。同理，逆向中，还需要添加一条测试用例：![image-20231014040254573](../img/image-20231014040254573.png)\n\n\n\n\n\n#### 7.3.2 课程查询接口的用例设计\n\n![image-20231014054102698](../img/image-20231014054102698.png)\n\n> 对应的用例文档\n\n![image-20231014054644739](../img/image-20231014054644739.png)\n\n![image-20231014054559197](../img/image-20231014054559197.png)\n\n\n\n#### 7.3.3 课程修改接口用例设计\n\n![image-20231014055926821](../img/image-20231014055926821.png)\n\n![image-20231014060539030](../img/image-20231014060539030.png)\n\n\n\n#### 7.3.4 课程删除接口测试用例设计\n\n![image-20231014061221536](../img/image-20231014061221536.png)\n\n![image-20231014061610452](../img/image-20231014061610452.png)\n\n这里的id是**路径参数**\n\n##### 7.3.4.1 路径参数\n\n> PathVariable\n\nURL中**末尾一级**的参数\n\n如： http://kdtx-test.itheima.net/api/clues/course/111\n\n在Postman中有两种方式添加Path Variable。第一种就是**直接在url中添加**，第二种是**url末尾加**```:id```\n\n![image-20231014061840143](../img/image-20231014061840143.png)\n\n\n\n以上内容为接口测试的基础理论与样例。下面是使用TestNG\n\n------\n\n","slug":"接口自动化","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"clnmsn9i40000yohz2w6h1823","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-回顾\"><a href=\"#1-回顾\" class=\"headerlink\" title=\"1. 回顾\"></a>1. 回顾</h2><h3 id=\"1-1-URL\"><a href=\"#1-1-URL\" class=\"headerlink\" title=\"1.1 URL\"></a>1.1 URL</h3><p><strong>URL</strong>： 统一资源定位符</p>\n<p><strong>格式</strong>： 协议:&#x2F;&#x2F;hostname:port&#x2F;path?参数&#x3D;值&amp;参数2&#x3D;值</p>\n<p><strong>默认端口号</strong>可以不写</p>\n<p>http:80</p>\n<p>https:443</p>\n<h3 id=\"1-2-HTTP-HTTPS\"><a href=\"#1-2-HTTP-HTTPS\" class=\"headerlink\" title=\"1.2 HTTP &#x2F; HTTPS\"></a>1.2 HTTP &#x2F; HTTPS</h3><p>超文本传输协议。基于响应和请求的应用层协议</p>\n<p>规定了客户端和服务器之间信息的传递规范。</p>\n<p>组成：</p>\n<ul>\n<li>HTTP请求定义了请求数据格式</li>\n<li>HTTP响应定义了响应数据格式</li>\n</ul>\n<h4 id=\"1-2-1-HTTP-请求行\"><a href=\"#1-2-1-HTTP-请求行\" class=\"headerlink\" title=\"1.2.1 HTTP 请求行\"></a>1.2.1 HTTP 请求行</h4><p>位于请求数据的第一行。表明了请求方式，访问的资源，协议版本</p>\n<p>格式：[请求方法] [url] [协议&#x2F;协议版本]</p>\n<p>常用请求方法：</p>\n<ol>\n<li>POST 在服务器新建一个资源</li>\n<li>GET 从服务器获取资源</li>\n<li>DELETE 从服务器删除资源</li>\n<li>PUT 在服务器更新资源</li>\n</ol>\n<h4 id=\"1-2-2-HTTP-请求头\"><a href=\"#1-2-2-HTTP-请求头\" class=\"headerlink\" title=\"1.2.2 HTTP 请求头\"></a>1.2.2 HTTP 请求头</h4><blockquote>\n<p>Request-header</p>\n</blockquote>\n<p>位于请求数据的<strong>第二行到空白行之间</strong>。作用是通知服务器客户端的请求信息。请求头部由<strong>键值对</strong>组成。每行一对。</p>\n<p>常见的参数：</p>\n<p>Host、User-Agent、Content-Type</p>\n<p>Content-Type用于表明<strong>请求体</strong>的数据类型，通常有：</p>\n<ul>\n<li>text&#x2F;html</li>\n<li>image&#x2F;jpeg</li>\n<li>application&#x2F;json</li>\n<li>application&#x2F;x-www-form-urlencoded</li>\n<li>mutipart&#x2F;form-data</li>\n</ul>\n<h4 id=\"1-2-3-HTTP-请求体\"><a href=\"#1-2-3-HTTP-请求体\" class=\"headerlink\" title=\"1.2.3 HTTP 请求体\"></a>1.2.3 HTTP 请求体</h4><blockquote>\n<p>Request-body</p>\n<p>body-parameters</p>\n</blockquote>\n<p>请求体就是请求下面的空白行下面的内容。常配合的请求头有上面讲的Content-Type，标明请求体的类型。还有Content-Length，标明请求体的长度。</p>\n<ul>\n<li>请求报文可以没有请求体</li>\n</ul>\n<h4 id=\"1-2-4-HTTP-响应-状态行\"><a href=\"#1-2-4-HTTP-响应-状态行\" class=\"headerlink\" title=\"1.2.4 HTTP 响应 - 状态行\"></a>1.2.4 HTTP 响应 - 状态行</h4><p>处于响应数据第一行。用于描述服务器处理结果</p>\n<p>格式：【协议版本号】【状态码】【状态消息】</p>\n<p>状态码：三位数字</p>\n<ul>\n<li>1xx: 指示信息</li>\n<li>2xx: 成功</li>\n<li>3xx: 重定向</li>\n<li>4xx: 客户端错误</li>\n<li>5xx: 服务端错误</li>\n</ul>\n<h4 id=\"1-2-5-HTTP-响应-响应头\"><a href=\"#1-2-5-HTTP-响应-响应头\" class=\"headerlink\" title=\"1.2.5 HTTP 响应 - 响应头\"></a>1.2.5 HTTP 响应 - 响应头</h4><p>和请求头的位置一样。用于描述客户端想要的一些附加信息。同样由键值对组成</p>\n<h4 id=\"1-2-6-HTTP-响应-响应体\"><a href=\"#1-2-6-HTTP-响应-响应体\" class=\"headerlink\" title=\"1.2.6 HTTP 响应 - 响应体\"></a>1.2.6 HTTP 响应 - 响应体</h4><p>和请求体位置一样。数据类型类似。是服务器返回的数据实体。</p>\n<h2 id=\"2-Charles\"><a href=\"#2-Charles\" class=\"headerlink\" title=\"2. Charles\"></a>2. Charles</h2><blockquote>\n<p>下载地址：<a href=\"https://www.charlesproxy.com/download/\">https://www.charlesproxy.com/download/</a></p>\n<p>激活：<a href=\"https://www.zzzmode.com/mytools/charles/\">https://www.zzzmode.com/mytools/charles/</a></p>\n</blockquote>\n<h3 id=\"2-1-什么是Charles\"><a href=\"#2-1-什么是Charles\" class=\"headerlink\" title=\"2.1 什么是Charles\"></a>2.1 什么是Charles</h3><p>Charles，是一个基于<strong>HTTP协议</strong>的代理服务器。通过成为电脑或者是浏览器的代理，从而<strong>截取请求和请求结果</strong>，以达到抓包分析的目的。</p>\n<h3 id=\"2-2-Charles-工作流程\"><a href=\"#2-2-Charles-工作流程\" class=\"headerlink\" title=\"2.2 Charles 工作流程\"></a>2.2 Charles 工作流程</h3><p>Charles的工作流程，其实就是在主机和互联网之间，加一个代理服务器。主机发送请求的时候，先发到charles上，由charles转发给服务器。接受时候同理。</p>\n<h3 id=\"2-3-Charles功能\"><a href=\"#2-3-Charles功能\" class=\"headerlink\" title=\"2.3 Charles功能\"></a>2.3 Charles功能</h3><ul>\n<li>支持HTTP和HTTPS代理</li>\n<li>支持<strong>流量控制</strong>（弱网环境）</li>\n<li>支持接口<strong>并发</strong>请求</li>\n<li>支持<strong>重发网络请求</strong></li>\n<li>支持断点调试（构建异常的测试场景）</li>\n</ul>\n<h3 id=\"2-4-补票\"><a href=\"#2-4-补票\" class=\"headerlink\" title=\"2.4 补票\"></a>2.4 补票</h3><h2 id=\"3-接口规范\"><a href=\"#3-接口规范\" class=\"headerlink\" title=\"3. 接口规范\"></a>3. 接口规范</h2><h3 id=\"3-1-传统接口风格\"><a href=\"#3-1-传统接口风格\" class=\"headerlink\" title=\"3.1 传统接口风格\"></a>3.1 传统接口风格</h3><p>URL体现了业务增删改查操作。</p>\n<p><a href=\"http://localhost/user/getAllUsers\">http://localhost:80/user/getAllUsers</a></p>\n<p><a href=\"https://localhost:80/deleteUser?id=1\">https://localhost:80/deleteUser?id=1</a></p>\n<p>这种就是传统的接口</p>\n<h3 id=\"3-2-RESTful接口风格\"><a href=\"#3-2-RESTful接口风格\" class=\"headerlink\" title=\"3.2 RESTful接口风格\"></a>3.2 RESTful接口风格</h3><p>URL中只<strong>定义了需要操作的对象</strong>。</p>\n<p><a href=\"https://localhost:80/app/users/1\">https://localhost:80/app/users/1</a> : 操作user集合的中编号为1的对象。</p>\n<ul>\n<li><p>请求API的URL用来定位<strong>资源</strong>（也就是对象）。</p>\n</li>\n<li><p>通过HTTP请求方式，来对资源进行增删改查操作。</p>\n<ul>\n<li>查：GET</li>\n<li>增：POST</li>\n<li>改：PUT</li>\n<li>删：DELETE</li>\n</ul>\n</li>\n<li><p>状态码遵循HTTP状态码协议。</p>\n</li>\n</ul>\n<h2 id=\"4-业务流程-vs-单个模块\"><a href=\"#4-业务流程-vs-单个模块\" class=\"headerlink\" title=\"4. 业务流程 vs 单个模块\"></a>4. 业务流程 vs 单个模块</h2><p>拿到一个项目后，<strong>先测试</strong>业务流程，确保<strong>核心功能</strong>正常。</p>\n<h3 id=\"4-1-如何设计业务流程测试用例\"><a href=\"#4-1-如何设计业务流程测试用例\" class=\"headerlink\" title=\"4.1 如何设计业务流程测试用例\"></a>4.1 如何设计业务流程测试用例</h3><ol>\n<li>根据流程图，找业务路径</li>\n<li>根据业务路径分析对应的接口请求</li>\n<li>将业务路径转化为接口测试用例</li>\n</ol>\n<ul>\n<li>找出现问题的点。正常通过的只用测一次（一路走到底）</li>\n</ul>\n<p>因此，对于下面这个新增合同业务，我们可以设计出以下用例：</p>\n<p><img src=\"/../img/image-20231012013204347.png\" alt=\"image-20231012013204347\"></p>\n<ol>\n<li>合同新增成功：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）-&gt; 新增合同（成功</li>\n<li>合同新增失败（登录失败）</li>\n<li>合同新增失败 （添加课程失败）：登陆（成功）</li>\n<li>合同新增失败 （上传合同失败）：登录（成功）-&gt; 添加课程（成功）</li>\n<li>合同新增失败 （新增合同失败）：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）</li>\n</ol>\n<h2 id=\"5-接口文档\"><a href=\"#5-接口文档\" class=\"headerlink\" title=\"5. 接口文档\"></a>5. 接口文档</h2><blockquote>\n<p>接口API文档一般由后端开发编写，用于描述接口信息。</p>\n<p><img src=\"/../img/image-20231012015303012.png\" alt=\"image-20231012015303012\"></p>\n</blockquote>\n<p>对于接口测试来讲，主要就是分析接口文档中的三点：</p>\n<ol>\n<li>接口之间的依赖关系</li>\n<li>接口请求（URL，请求方法，请求头，请求参数类型，请求参数）</li>\n<li>接口响应（状态码，响应信息）</li>\n</ol>\n<ul>\n<li>基本就是跟着接口文档，在测试用例里面复制黏贴就行。接口文档里没写的，测试用例里用“&#x2F;”占位。</li>\n</ul>\n<p><img src=\"/../img/image-20231012020112675.png\" alt=\"image-20231012020112675\"></p>\n<h2 id=\"6-Postman\"><a href=\"#6-Postman\" class=\"headerlink\" title=\"6. Postman\"></a>6. Postman</h2><blockquote>\n<p>一款接口调试工具</p>\n</blockquote>\n<h3 id=\"6-1-Demo-验证码接口\"><a href=\"#6-1-Demo-验证码接口\" class=\"headerlink\" title=\"6.1 Demo:验证码接口\"></a>6.1 Demo:验证码接口</h3><p><strong>URL</strong>: <a href=\"http://kdtx-test.itheima.net/api/captchaImage\">http://kdtx-test.itheima.net/api/captchaImage</a></p>\n<ul>\n<li>设置请求方式 (GET)</li>\n<li>输入接口地址 (…)</li>\n<li>点击发送请求</li>\n<li>查看响应结果</li>\n</ul>\n<h3 id=\"6-2-Demo-登录接口\"><a href=\"#6-2-Demo-登录接口\" class=\"headerlink\" title=\"6.2 Demo: 登录接口\"></a>6.2 Demo: 登录接口</h3><p><strong>URL</strong>: <a href=\"http://kdtx-test.itheima.net/api/login\">http://kdtx-test.itheima.net/api/login</a> 方法： POST</p>\n<p><strong>请求头</strong>： Content-Type： application&#x2F;json</p>\n<p><strong>请求体</strong>： {“username”:”admin”, “password”:”HM_2023_test”,”code”:”2”,”uuid”:”验证码接口中uuid请求结果”}</p>\n<ul>\n<li>设置请求方式 (GET)</li>\n<li>输入接口地址 (…)</li>\n<li>点击发送请求</li>\n<li>查看响应结果</li>\n</ul>\n<hr>\n<p><strong>问题</strong>： 每次使用登录接口，都需要<strong>手动</strong>复制验证码接口的返回结果，很麻烦</p>\n<p>Postman为我们提供了一个<strong>公共容器</strong>，用于保存相关联的数据。</p>\n<h3 id=\"6-3-环境变量\"><a href=\"#6-3-环境变量\" class=\"headerlink\" title=\"6.3 环境变量\"></a>6.3 环境变量</h3><p><img src=\"/../img/image-20231012150414097.png\" alt=\"image-20231012150414097\"></p>\n<h4 id=\"6-3-1-通过javascript操作响应json，并存入环境变量\"><a href=\"#6-3-1-通过javascript操作响应json，并存入环境变量\" class=\"headerlink\" title=\"6.3.1 通过javascript操作响应json，并存入环境变量\"></a>6.3.1 通过javascript操作响应json，并存入环境变量</h4><p>Postman<strong>内置Test</strong>，可以运行Javascript。通过这一点，可以动态地获取并保存环境变量</p>\n<h5 id=\"6-3-1-1-Demo1-将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\"><a href=\"#6-3-1-1-Demo1-将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\" class=\"headerlink\" title=\"6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\"></a>6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中</h5><p><img src=\"/../img/image-20231012152302176.png\" alt=\"image-20231012152302176\"></p>\n<p><img src=\"/../img/image-20231012152314404.png\" alt=\"image-20231012152314404\"></p>\n<h5 id=\"6-3-1-1-Demo-将登录成功后的token存入环境变量，并在添加课程时候填入-RequestHeader中。\"><a href=\"#6-3-1-1-Demo-将登录成功后的token存入环境变量，并在添加课程时候填入-RequestHeader中。\" class=\"headerlink\" title=\"6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。\"></a>6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。</h5><p><img src=\"/../img/image-20231012175222772.png\" alt=\"image-20231012175222772\"></p>\n<p><img src=\"/../img/image-20231012175230820.png\" alt=\"image-20231012175230820\"></p>\n<h3 id=\"6-4-处理mutipart-form-data数据\"><a href=\"#6-4-处理mutipart-form-data数据\" class=\"headerlink\" title=\"6.4 处理mutipart&#x2F;form-data数据\"></a>6.4 处理mutipart&#x2F;form-data数据</h3><p>接口可能会这样子写</p>\n<p><img src=\"/../img/image-20231013020924815.png\" alt=\"image-20231013020924815\"></p>\n<p>这时候请求体类型就得是form-data类型了。Key看文档，file看文档文件路径。</p>\n<p><img src=\"/../img/image-20231013021007971.png\" alt=\"image-20231013021007971\"></p>\n<p>这里上传接口又依赖登录接口请求成功后，返回的token。因此，需要在登录接口中将token存入环境变量</p>\n<p><img src=\"/../img/image-20231013021122908.png\" alt=\"image-20231013021122908\"></p>\n<p>并在上传接口的Request-Headers，添加Authorization：</p>\n<h3 id=\"6-5-Postman中的Request-Param\"><a href=\"#6-5-Postman中的Request-Param\" class=\"headerlink\" title=\"6.5 Postman中的Request Param\"></a>6.5 Postman中的Request Param</h3><p><img src=\"/../img/image-20231013224552169.png\" alt=\"image-20231013224552169\"></p>\n<h3 id=\"6-6-批量执行\"><a href=\"#6-6-批量执行\" class=\"headerlink\" title=\"6.6 批量执行\"></a>6.6 批量执行</h3><blockquote>\n<p>这些合同查询、上传、新增操作，都依赖于登录时候提供的token进行鉴权。问题是，用户登录是会过期的。我们不可能每次要去进行操作，都手动把每个接口的流程走一遍，因此，postman提供了批量执行测试用例。</p>\n</blockquote>\n<p><img src=\"/../img/image-20231013230802520.png\" alt=\"image-20231013230802520\"></p>\n<h2 id=\"7-设计接口用例\"><a href=\"#7-设计接口用例\" class=\"headerlink\" title=\"7. 设计接口用例\"></a>7. 设计接口用例</h2><p>对于 <strong>单接口测试</strong>，设计思路通常分为两类： <strong>正向测试</strong>和<strong>逆向（反向）测试</strong></p>\n<h3 id=\"7-1-正向测试\"><a href=\"#7-1-正向测试\" class=\"headerlink\" title=\"7.1 正向测试\"></a>7.1 正向测试</h3><p>包含： </p>\n<ul>\n<li>必填参数 P2</li>\n<li>全部参数 p2</li>\n</ul>\n<h3 id=\"7-2-逆向测试\"><a href=\"#7-2-逆向测试\" class=\"headerlink\" title=\"7.2 逆向测试\"></a>7.2 逆向测试</h3><p>包含：</p>\n<ul>\n<li>参数数据为空 p3</li>\n<li>参数类型不符 p3</li>\n<li>参数长度不符 p3</li>\n<li>业务规则不符 p3</li>\n</ul>\n<p>正向测试的优先级<strong>永远高于</strong>逆向测试</p>\n<p>逆向测试可以理解成<strong>对正向测试里的参数的对立面进行测试</strong></p>\n<p>e.g. 登录接口测试用例</p>\n<p><img src=\"/../img/image-20231014014917998.png\" alt=\"image-20231014014917998\"></p>\n<h3 id=\"7-3-Postman按模块管理测试用例\"><a href=\"#7-3-Postman按模块管理测试用例\" class=\"headerlink\" title=\"7.3 Postman按模块管理测试用例\"></a>7.3 Postman按模块管理测试用例</h3><p><img src=\"/../img/image-20231014020213977.png\" alt=\"image-20231014020213977\"></p>\n<p>按照上面的箭头，先在Collection中创建folder，然后再folder中创建对应接口的request测试用例。</p>\n<p>下面是对于<strong>登录接口</strong>的<strong>用户名</strong>设计的<strong>三个</strong>正向和反向测试用例</p>\n<p><img src=\"/../img/image-20231014020042107.png\" alt=\"image-20231014020042107\"></p>\n<h4 id=\"补票：Postman断言\"><a href=\"#补票：Postman断言\" class=\"headerlink\" title=\"补票：Postman断言\"></a>补票：Postman断言</h4><blockquote>\n<p>Postman提供了test()方法，用于自动地检测response中的结果是否与预期结果一致。</p>\n</blockquote>\n<p>常用断言包括：</p>\n<ul>\n<li><p>响应状态码(Status code)</p>\n<p><img src=\"/../img/image-20231014020902573.png\" alt=\"image-20231014020902573\"></p>\n<p>**直接点击对应snippet就会自动再Tests编辑区域生成 **</p>\n</li>\n<li><p>响应包含指定字符串 (Contains string)</p>\n</li>\n<li><p>JSON断言（JSON value check)</p>\n<p>写完之后发送下，如果符合预期结果的话，应该是绿色。</p>\n</li>\n</ul>\n<p><img src=\"/../img/image-20231014022802984.png\" alt=\"image-20231014022802984\"></p>\n<h4 id=\"补票：Postman参数化\"><a href=\"#补票：Postman参数化\" class=\"headerlink\" title=\"补票：Postman参数化\"></a>补票：Postman参数化</h4><blockquote>\n<p>从上面的断言例子可以看出。如果对同一接口进行正反向测试时候，每次测试都需要将Tests内的代码或者是headers、body中的值进行复制黏贴。很麻烦。因此，postman提供了参数化，可以直接准备好的数据文件中，读取数据</p>\n</blockquote>\n<p>步骤：</p>\n<ol>\n<li><p>准备数据文件</p>\n</li>\n<li><p>引用数据文件数据</p>\n<p>headers、body：</p>\n<p>代码：data.key</p>\n</li>\n<li><p>在<strong>批量执行</strong>的页面，select file选择数据文件。</p>\n</li>\n</ol>\n<p>JSON数据格式：</p>\n<pre><code class=\"json\">[\n    &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;200&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;操作成功&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;admin1&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;\n]\n</code></pre>\n<p><img src=\"/../img/image-20231014034148547.png\" alt=\"image-20231014034148547\"></p>\n<p>注意，在编写json数据时，务必看好接口文档里的参数类型。如果是string类型则不要忘了双引号。如果是数字类型则不用双引号。</p>\n<p>这里，如果将”status”设为String类型的”200”，则会导致测试用例无法通过。</p>\n<p>如图：</p>\n<p><img src=\"/../img/image-20231014034455018.png\" alt=\"image-20231014034455018\"></p>\n<p><img src=\"/../img/image-20231014034510599.png\" alt=\"image-20231014034510599\"></p>\n<blockquote>\n<p>下面的用例，有时间可以往postman里填下，练练手。重要的还是看怎么设计用例。填数据没难度。</p>\n</blockquote>\n<h4 id=\"7-3-1-Demo-课程添加接口的用例设计\"><a href=\"#7-3-1-Demo-课程添加接口的用例设计\" class=\"headerlink\" title=\"7.3.1 Demo: 课程添加接口的用例设计\"></a>7.3.1 Demo: 课程添加接口的用例设计</h4><p><img src=\"/../img/image-20231014040059430.png\" alt=\"image-20231014040059430\"></p>\n<p>因为这个接口依赖于登录成功后返回的token，因此，正向中的两个用例需要补充一下说明：是在登录成功的前提下,进行…..。同理，逆向中，还需要添加一条测试用例：<img src=\"/../img/image-20231014040254573.png\" alt=\"image-20231014040254573\"></p>\n<h4 id=\"7-3-2-课程查询接口的用例设计\"><a href=\"#7-3-2-课程查询接口的用例设计\" class=\"headerlink\" title=\"7.3.2 课程查询接口的用例设计\"></a>7.3.2 课程查询接口的用例设计</h4><p><img src=\"/../img/image-20231014054102698.png\" alt=\"image-20231014054102698\"></p>\n<blockquote>\n<p>对应的用例文档</p>\n</blockquote>\n<p><img src=\"/../img/image-20231014054644739.png\" alt=\"image-20231014054644739\"></p>\n<p><img src=\"/../img/image-20231014054559197.png\" alt=\"image-20231014054559197\"></p>\n<h4 id=\"7-3-3-课程修改接口用例设计\"><a href=\"#7-3-3-课程修改接口用例设计\" class=\"headerlink\" title=\"7.3.3 课程修改接口用例设计\"></a>7.3.3 课程修改接口用例设计</h4><p><img src=\"/../img/image-20231014055926821.png\" alt=\"image-20231014055926821\"></p>\n<p><img src=\"/../img/image-20231014060539030.png\" alt=\"image-20231014060539030\"></p>\n<h4 id=\"7-3-4-课程删除接口测试用例设计\"><a href=\"#7-3-4-课程删除接口测试用例设计\" class=\"headerlink\" title=\"7.3.4 课程删除接口测试用例设计\"></a>7.3.4 课程删除接口测试用例设计</h4><p><img src=\"/../img/image-20231014061221536.png\" alt=\"image-20231014061221536\"></p>\n<p><img src=\"/../img/image-20231014061610452.png\" alt=\"image-20231014061610452\"></p>\n<p>这里的id是<strong>路径参数</strong></p>\n<h5 id=\"7-3-4-1-路径参数\"><a href=\"#7-3-4-1-路径参数\" class=\"headerlink\" title=\"7.3.4.1 路径参数\"></a>7.3.4.1 路径参数</h5><blockquote>\n<p>PathVariable</p>\n</blockquote>\n<p>URL中<strong>末尾一级</strong>的参数</p>\n<p>如： <a href=\"http://kdtx-test.itheima.net/api/clues/course/111\">http://kdtx-test.itheima.net/api/clues/course/111</a></p>\n<p>在Postman中有两种方式添加Path Variable。第一种就是<strong>直接在url中添加</strong>，第二种是<strong>url末尾加</strong><code>:id</code></p>\n<p><img src=\"/../img/image-20231014061840143.png\" alt=\"image-20231014061840143\"></p>\n<p>以上内容为接口测试的基础理论与样例。下面是使用TestNG</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-回顾\"><a href=\"#1-回顾\" class=\"headerlink\" title=\"1. 回顾\"></a>1. 回顾</h2><h3 id=\"1-1-URL\"><a href=\"#1-1-URL\" class=\"headerlink\" title=\"1.1 URL\"></a>1.1 URL</h3><p><strong>URL</strong>： 统一资源定位符</p>\n<p><strong>格式</strong>： 协议:&#x2F;&#x2F;hostname:port&#x2F;path?参数&#x3D;值&amp;参数2&#x3D;值</p>\n<p><strong>默认端口号</strong>可以不写</p>\n<p>http:80</p>\n<p>https:443</p>\n<h3 id=\"1-2-HTTP-HTTPS\"><a href=\"#1-2-HTTP-HTTPS\" class=\"headerlink\" title=\"1.2 HTTP &#x2F; HTTPS\"></a>1.2 HTTP &#x2F; HTTPS</h3><p>超文本传输协议。基于响应和请求的应用层协议</p>\n<p>规定了客户端和服务器之间信息的传递规范。</p>\n<p>组成：</p>\n<ul>\n<li>HTTP请求定义了请求数据格式</li>\n<li>HTTP响应定义了响应数据格式</li>\n</ul>\n<h4 id=\"1-2-1-HTTP-请求行\"><a href=\"#1-2-1-HTTP-请求行\" class=\"headerlink\" title=\"1.2.1 HTTP 请求行\"></a>1.2.1 HTTP 请求行</h4><p>位于请求数据的第一行。表明了请求方式，访问的资源，协议版本</p>\n<p>格式：[请求方法] [url] [协议&#x2F;协议版本]</p>\n<p>常用请求方法：</p>\n<ol>\n<li>POST 在服务器新建一个资源</li>\n<li>GET 从服务器获取资源</li>\n<li>DELETE 从服务器删除资源</li>\n<li>PUT 在服务器更新资源</li>\n</ol>\n<h4 id=\"1-2-2-HTTP-请求头\"><a href=\"#1-2-2-HTTP-请求头\" class=\"headerlink\" title=\"1.2.2 HTTP 请求头\"></a>1.2.2 HTTP 请求头</h4><blockquote>\n<p>Request-header</p>\n</blockquote>\n<p>位于请求数据的<strong>第二行到空白行之间</strong>。作用是通知服务器客户端的请求信息。请求头部由<strong>键值对</strong>组成。每行一对。</p>\n<p>常见的参数：</p>\n<p>Host、User-Agent、Content-Type</p>\n<p>Content-Type用于表明<strong>请求体</strong>的数据类型，通常有：</p>\n<ul>\n<li>text&#x2F;html</li>\n<li>image&#x2F;jpeg</li>\n<li>application&#x2F;json</li>\n<li>application&#x2F;x-www-form-urlencoded</li>\n<li>mutipart&#x2F;form-data</li>\n</ul>\n<h4 id=\"1-2-3-HTTP-请求体\"><a href=\"#1-2-3-HTTP-请求体\" class=\"headerlink\" title=\"1.2.3 HTTP 请求体\"></a>1.2.3 HTTP 请求体</h4><blockquote>\n<p>Request-body</p>\n<p>body-parameters</p>\n</blockquote>\n<p>请求体就是请求下面的空白行下面的内容。常配合的请求头有上面讲的Content-Type，标明请求体的类型。还有Content-Length，标明请求体的长度。</p>\n<ul>\n<li>请求报文可以没有请求体</li>\n</ul>\n<h4 id=\"1-2-4-HTTP-响应-状态行\"><a href=\"#1-2-4-HTTP-响应-状态行\" class=\"headerlink\" title=\"1.2.4 HTTP 响应 - 状态行\"></a>1.2.4 HTTP 响应 - 状态行</h4><p>处于响应数据第一行。用于描述服务器处理结果</p>\n<p>格式：【协议版本号】【状态码】【状态消息】</p>\n<p>状态码：三位数字</p>\n<ul>\n<li>1xx: 指示信息</li>\n<li>2xx: 成功</li>\n<li>3xx: 重定向</li>\n<li>4xx: 客户端错误</li>\n<li>5xx: 服务端错误</li>\n</ul>\n<h4 id=\"1-2-5-HTTP-响应-响应头\"><a href=\"#1-2-5-HTTP-响应-响应头\" class=\"headerlink\" title=\"1.2.5 HTTP 响应 - 响应头\"></a>1.2.5 HTTP 响应 - 响应头</h4><p>和请求头的位置一样。用于描述客户端想要的一些附加信息。同样由键值对组成</p>\n<h4 id=\"1-2-6-HTTP-响应-响应体\"><a href=\"#1-2-6-HTTP-响应-响应体\" class=\"headerlink\" title=\"1.2.6 HTTP 响应 - 响应体\"></a>1.2.6 HTTP 响应 - 响应体</h4><p>和请求体位置一样。数据类型类似。是服务器返回的数据实体。</p>\n<h2 id=\"2-Charles\"><a href=\"#2-Charles\" class=\"headerlink\" title=\"2. Charles\"></a>2. Charles</h2><blockquote>\n<p>下载地址：<a href=\"https://www.charlesproxy.com/download/\">https://www.charlesproxy.com/download/</a></p>\n<p>激活：<a href=\"https://www.zzzmode.com/mytools/charles/\">https://www.zzzmode.com/mytools/charles/</a></p>\n</blockquote>\n<h3 id=\"2-1-什么是Charles\"><a href=\"#2-1-什么是Charles\" class=\"headerlink\" title=\"2.1 什么是Charles\"></a>2.1 什么是Charles</h3><p>Charles，是一个基于<strong>HTTP协议</strong>的代理服务器。通过成为电脑或者是浏览器的代理，从而<strong>截取请求和请求结果</strong>，以达到抓包分析的目的。</p>\n<h3 id=\"2-2-Charles-工作流程\"><a href=\"#2-2-Charles-工作流程\" class=\"headerlink\" title=\"2.2 Charles 工作流程\"></a>2.2 Charles 工作流程</h3><p>Charles的工作流程，其实就是在主机和互联网之间，加一个代理服务器。主机发送请求的时候，先发到charles上，由charles转发给服务器。接受时候同理。</p>\n<h3 id=\"2-3-Charles功能\"><a href=\"#2-3-Charles功能\" class=\"headerlink\" title=\"2.3 Charles功能\"></a>2.3 Charles功能</h3><ul>\n<li>支持HTTP和HTTPS代理</li>\n<li>支持<strong>流量控制</strong>（弱网环境）</li>\n<li>支持接口<strong>并发</strong>请求</li>\n<li>支持<strong>重发网络请求</strong></li>\n<li>支持断点调试（构建异常的测试场景）</li>\n</ul>\n<h3 id=\"2-4-补票\"><a href=\"#2-4-补票\" class=\"headerlink\" title=\"2.4 补票\"></a>2.4 补票</h3><h2 id=\"3-接口规范\"><a href=\"#3-接口规范\" class=\"headerlink\" title=\"3. 接口规范\"></a>3. 接口规范</h2><h3 id=\"3-1-传统接口风格\"><a href=\"#3-1-传统接口风格\" class=\"headerlink\" title=\"3.1 传统接口风格\"></a>3.1 传统接口风格</h3><p>URL体现了业务增删改查操作。</p>\n<p><a href=\"http://localhost/user/getAllUsers\">http://localhost:80/user/getAllUsers</a></p>\n<p><a href=\"https://localhost:80/deleteUser?id=1\">https://localhost:80/deleteUser?id=1</a></p>\n<p>这种就是传统的接口</p>\n<h3 id=\"3-2-RESTful接口风格\"><a href=\"#3-2-RESTful接口风格\" class=\"headerlink\" title=\"3.2 RESTful接口风格\"></a>3.2 RESTful接口风格</h3><p>URL中只<strong>定义了需要操作的对象</strong>。</p>\n<p><a href=\"https://localhost:80/app/users/1\">https://localhost:80/app/users/1</a> : 操作user集合的中编号为1的对象。</p>\n<ul>\n<li><p>请求API的URL用来定位<strong>资源</strong>（也就是对象）。</p>\n</li>\n<li><p>通过HTTP请求方式，来对资源进行增删改查操作。</p>\n<ul>\n<li>查：GET</li>\n<li>增：POST</li>\n<li>改：PUT</li>\n<li>删：DELETE</li>\n</ul>\n</li>\n<li><p>状态码遵循HTTP状态码协议。</p>\n</li>\n</ul>\n<h2 id=\"4-业务流程-vs-单个模块\"><a href=\"#4-业务流程-vs-单个模块\" class=\"headerlink\" title=\"4. 业务流程 vs 单个模块\"></a>4. 业务流程 vs 单个模块</h2><p>拿到一个项目后，<strong>先测试</strong>业务流程，确保<strong>核心功能</strong>正常。</p>\n<h3 id=\"4-1-如何设计业务流程测试用例\"><a href=\"#4-1-如何设计业务流程测试用例\" class=\"headerlink\" title=\"4.1 如何设计业务流程测试用例\"></a>4.1 如何设计业务流程测试用例</h3><ol>\n<li>根据流程图，找业务路径</li>\n<li>根据业务路径分析对应的接口请求</li>\n<li>将业务路径转化为接口测试用例</li>\n</ol>\n<ul>\n<li>找出现问题的点。正常通过的只用测一次（一路走到底）</li>\n</ul>\n<p>因此，对于下面这个新增合同业务，我们可以设计出以下用例：</p>\n<p><img src=\"/../img/image-20231012013204347.png\" alt=\"image-20231012013204347\"></p>\n<ol>\n<li>合同新增成功：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）-&gt; 新增合同（成功</li>\n<li>合同新增失败（登录失败）</li>\n<li>合同新增失败 （添加课程失败）：登陆（成功）</li>\n<li>合同新增失败 （上传合同失败）：登录（成功）-&gt; 添加课程（成功）</li>\n<li>合同新增失败 （新增合同失败）：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）</li>\n</ol>\n<h2 id=\"5-接口文档\"><a href=\"#5-接口文档\" class=\"headerlink\" title=\"5. 接口文档\"></a>5. 接口文档</h2><blockquote>\n<p>接口API文档一般由后端开发编写，用于描述接口信息。</p>\n<p><img src=\"/../img/image-20231012015303012.png\" alt=\"image-20231012015303012\"></p>\n</blockquote>\n<p>对于接口测试来讲，主要就是分析接口文档中的三点：</p>\n<ol>\n<li>接口之间的依赖关系</li>\n<li>接口请求（URL，请求方法，请求头，请求参数类型，请求参数）</li>\n<li>接口响应（状态码，响应信息）</li>\n</ol>\n<ul>\n<li>基本就是跟着接口文档，在测试用例里面复制黏贴就行。接口文档里没写的，测试用例里用“&#x2F;”占位。</li>\n</ul>\n<p><img src=\"/../img/image-20231012020112675.png\" alt=\"image-20231012020112675\"></p>\n<h2 id=\"6-Postman\"><a href=\"#6-Postman\" class=\"headerlink\" title=\"6. Postman\"></a>6. Postman</h2><blockquote>\n<p>一款接口调试工具</p>\n</blockquote>\n<h3 id=\"6-1-Demo-验证码接口\"><a href=\"#6-1-Demo-验证码接口\" class=\"headerlink\" title=\"6.1 Demo:验证码接口\"></a>6.1 Demo:验证码接口</h3><p><strong>URL</strong>: <a href=\"http://kdtx-test.itheima.net/api/captchaImage\">http://kdtx-test.itheima.net/api/captchaImage</a></p>\n<ul>\n<li>设置请求方式 (GET)</li>\n<li>输入接口地址 (…)</li>\n<li>点击发送请求</li>\n<li>查看响应结果</li>\n</ul>\n<h3 id=\"6-2-Demo-登录接口\"><a href=\"#6-2-Demo-登录接口\" class=\"headerlink\" title=\"6.2 Demo: 登录接口\"></a>6.2 Demo: 登录接口</h3><p><strong>URL</strong>: <a href=\"http://kdtx-test.itheima.net/api/login\">http://kdtx-test.itheima.net/api/login</a> 方法： POST</p>\n<p><strong>请求头</strong>： Content-Type： application&#x2F;json</p>\n<p><strong>请求体</strong>： {“username”:”admin”, “password”:”HM_2023_test”,”code”:”2”,”uuid”:”验证码接口中uuid请求结果”}</p>\n<ul>\n<li>设置请求方式 (GET)</li>\n<li>输入接口地址 (…)</li>\n<li>点击发送请求</li>\n<li>查看响应结果</li>\n</ul>\n<hr>\n<p><strong>问题</strong>： 每次使用登录接口，都需要<strong>手动</strong>复制验证码接口的返回结果，很麻烦</p>\n<p>Postman为我们提供了一个<strong>公共容器</strong>，用于保存相关联的数据。</p>\n<h3 id=\"6-3-环境变量\"><a href=\"#6-3-环境变量\" class=\"headerlink\" title=\"6.3 环境变量\"></a>6.3 环境变量</h3><p><img src=\"/../img/image-20231012150414097.png\" alt=\"image-20231012150414097\"></p>\n<h4 id=\"6-3-1-通过javascript操作响应json，并存入环境变量\"><a href=\"#6-3-1-通过javascript操作响应json，并存入环境变量\" class=\"headerlink\" title=\"6.3.1 通过javascript操作响应json，并存入环境变量\"></a>6.3.1 通过javascript操作响应json，并存入环境变量</h4><p>Postman<strong>内置Test</strong>，可以运行Javascript。通过这一点，可以动态地获取并保存环境变量</p>\n<h5 id=\"6-3-1-1-Demo1-将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\"><a href=\"#6-3-1-1-Demo1-将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\" class=\"headerlink\" title=\"6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\"></a>6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中</h5><p><img src=\"/../img/image-20231012152302176.png\" alt=\"image-20231012152302176\"></p>\n<p><img src=\"/../img/image-20231012152314404.png\" alt=\"image-20231012152314404\"></p>\n<h5 id=\"6-3-1-1-Demo-将登录成功后的token存入环境变量，并在添加课程时候填入-RequestHeader中。\"><a href=\"#6-3-1-1-Demo-将登录成功后的token存入环境变量，并在添加课程时候填入-RequestHeader中。\" class=\"headerlink\" title=\"6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。\"></a>6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。</h5><p><img src=\"/../img/image-20231012175222772.png\" alt=\"image-20231012175222772\"></p>\n<p><img src=\"/../img/image-20231012175230820.png\" alt=\"image-20231012175230820\"></p>\n<h3 id=\"6-4-处理mutipart-form-data数据\"><a href=\"#6-4-处理mutipart-form-data数据\" class=\"headerlink\" title=\"6.4 处理mutipart&#x2F;form-data数据\"></a>6.4 处理mutipart&#x2F;form-data数据</h3><p>接口可能会这样子写</p>\n<p><img src=\"/../img/image-20231013020924815.png\" alt=\"image-20231013020924815\"></p>\n<p>这时候请求体类型就得是form-data类型了。Key看文档，file看文档文件路径。</p>\n<p><img src=\"/../img/image-20231013021007971.png\" alt=\"image-20231013021007971\"></p>\n<p>这里上传接口又依赖登录接口请求成功后，返回的token。因此，需要在登录接口中将token存入环境变量</p>\n<p><img src=\"/../img/image-20231013021122908.png\" alt=\"image-20231013021122908\"></p>\n<p>并在上传接口的Request-Headers，添加Authorization：</p>\n<h3 id=\"6-5-Postman中的Request-Param\"><a href=\"#6-5-Postman中的Request-Param\" class=\"headerlink\" title=\"6.5 Postman中的Request Param\"></a>6.5 Postman中的Request Param</h3><p><img src=\"/../img/image-20231013224552169.png\" alt=\"image-20231013224552169\"></p>\n<h3 id=\"6-6-批量执行\"><a href=\"#6-6-批量执行\" class=\"headerlink\" title=\"6.6 批量执行\"></a>6.6 批量执行</h3><blockquote>\n<p>这些合同查询、上传、新增操作，都依赖于登录时候提供的token进行鉴权。问题是，用户登录是会过期的。我们不可能每次要去进行操作，都手动把每个接口的流程走一遍，因此，postman提供了批量执行测试用例。</p>\n</blockquote>\n<p><img src=\"/../img/image-20231013230802520.png\" alt=\"image-20231013230802520\"></p>\n<h2 id=\"7-设计接口用例\"><a href=\"#7-设计接口用例\" class=\"headerlink\" title=\"7. 设计接口用例\"></a>7. 设计接口用例</h2><p>对于 <strong>单接口测试</strong>，设计思路通常分为两类： <strong>正向测试</strong>和<strong>逆向（反向）测试</strong></p>\n<h3 id=\"7-1-正向测试\"><a href=\"#7-1-正向测试\" class=\"headerlink\" title=\"7.1 正向测试\"></a>7.1 正向测试</h3><p>包含： </p>\n<ul>\n<li>必填参数 P2</li>\n<li>全部参数 p2</li>\n</ul>\n<h3 id=\"7-2-逆向测试\"><a href=\"#7-2-逆向测试\" class=\"headerlink\" title=\"7.2 逆向测试\"></a>7.2 逆向测试</h3><p>包含：</p>\n<ul>\n<li>参数数据为空 p3</li>\n<li>参数类型不符 p3</li>\n<li>参数长度不符 p3</li>\n<li>业务规则不符 p3</li>\n</ul>\n<p>正向测试的优先级<strong>永远高于</strong>逆向测试</p>\n<p>逆向测试可以理解成<strong>对正向测试里的参数的对立面进行测试</strong></p>\n<p>e.g. 登录接口测试用例</p>\n<p><img src=\"/../img/image-20231014014917998.png\" alt=\"image-20231014014917998\"></p>\n<h3 id=\"7-3-Postman按模块管理测试用例\"><a href=\"#7-3-Postman按模块管理测试用例\" class=\"headerlink\" title=\"7.3 Postman按模块管理测试用例\"></a>7.3 Postman按模块管理测试用例</h3><p><img src=\"/../img/image-20231014020213977.png\" alt=\"image-20231014020213977\"></p>\n<p>按照上面的箭头，先在Collection中创建folder，然后再folder中创建对应接口的request测试用例。</p>\n<p>下面是对于<strong>登录接口</strong>的<strong>用户名</strong>设计的<strong>三个</strong>正向和反向测试用例</p>\n<p><img src=\"/../img/image-20231014020042107.png\" alt=\"image-20231014020042107\"></p>\n<h4 id=\"补票：Postman断言\"><a href=\"#补票：Postman断言\" class=\"headerlink\" title=\"补票：Postman断言\"></a>补票：Postman断言</h4><blockquote>\n<p>Postman提供了test()方法，用于自动地检测response中的结果是否与预期结果一致。</p>\n</blockquote>\n<p>常用断言包括：</p>\n<ul>\n<li><p>响应状态码(Status code)</p>\n<p><img src=\"/../img/image-20231014020902573.png\" alt=\"image-20231014020902573\"></p>\n<p>**直接点击对应snippet就会自动再Tests编辑区域生成 **</p>\n</li>\n<li><p>响应包含指定字符串 (Contains string)</p>\n</li>\n<li><p>JSON断言（JSON value check)</p>\n<p>写完之后发送下，如果符合预期结果的话，应该是绿色。</p>\n</li>\n</ul>\n<p><img src=\"/../img/image-20231014022802984.png\" alt=\"image-20231014022802984\"></p>\n<h4 id=\"补票：Postman参数化\"><a href=\"#补票：Postman参数化\" class=\"headerlink\" title=\"补票：Postman参数化\"></a>补票：Postman参数化</h4><blockquote>\n<p>从上面的断言例子可以看出。如果对同一接口进行正反向测试时候，每次测试都需要将Tests内的代码或者是headers、body中的值进行复制黏贴。很麻烦。因此，postman提供了参数化，可以直接准备好的数据文件中，读取数据</p>\n</blockquote>\n<p>步骤：</p>\n<ol>\n<li><p>准备数据文件</p>\n</li>\n<li><p>引用数据文件数据</p>\n<p>headers、body：</p>\n<p>代码：data.key</p>\n</li>\n<li><p>在<strong>批量执行</strong>的页面，select file选择数据文件。</p>\n</li>\n</ol>\n<p>JSON数据格式：</p>\n<pre><code class=\"json\">[\n    &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;200&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;操作成功&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;admin1&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;\n]\n</code></pre>\n<p><img src=\"/../img/image-20231014034148547.png\" alt=\"image-20231014034148547\"></p>\n<p>注意，在编写json数据时，务必看好接口文档里的参数类型。如果是string类型则不要忘了双引号。如果是数字类型则不用双引号。</p>\n<p>这里，如果将”status”设为String类型的”200”，则会导致测试用例无法通过。</p>\n<p>如图：</p>\n<p><img src=\"/../img/image-20231014034455018.png\" alt=\"image-20231014034455018\"></p>\n<p><img src=\"/../img/image-20231014034510599.png\" alt=\"image-20231014034510599\"></p>\n<blockquote>\n<p>下面的用例，有时间可以往postman里填下，练练手。重要的还是看怎么设计用例。填数据没难度。</p>\n</blockquote>\n<h4 id=\"7-3-1-Demo-课程添加接口的用例设计\"><a href=\"#7-3-1-Demo-课程添加接口的用例设计\" class=\"headerlink\" title=\"7.3.1 Demo: 课程添加接口的用例设计\"></a>7.3.1 Demo: 课程添加接口的用例设计</h4><p><img src=\"/../img/image-20231014040059430.png\" alt=\"image-20231014040059430\"></p>\n<p>因为这个接口依赖于登录成功后返回的token，因此，正向中的两个用例需要补充一下说明：是在登录成功的前提下,进行…..。同理，逆向中，还需要添加一条测试用例：<img src=\"/../img/image-20231014040254573.png\" alt=\"image-20231014040254573\"></p>\n<h4 id=\"7-3-2-课程查询接口的用例设计\"><a href=\"#7-3-2-课程查询接口的用例设计\" class=\"headerlink\" title=\"7.3.2 课程查询接口的用例设计\"></a>7.3.2 课程查询接口的用例设计</h4><p><img src=\"/../img/image-20231014054102698.png\" alt=\"image-20231014054102698\"></p>\n<blockquote>\n<p>对应的用例文档</p>\n</blockquote>\n<p><img src=\"/../img/image-20231014054644739.png\" alt=\"image-20231014054644739\"></p>\n<p><img src=\"/../img/image-20231014054559197.png\" alt=\"image-20231014054559197\"></p>\n<h4 id=\"7-3-3-课程修改接口用例设计\"><a href=\"#7-3-3-课程修改接口用例设计\" class=\"headerlink\" title=\"7.3.3 课程修改接口用例设计\"></a>7.3.3 课程修改接口用例设计</h4><p><img src=\"/../img/image-20231014055926821.png\" alt=\"image-20231014055926821\"></p>\n<p><img src=\"/../img/image-20231014060539030.png\" alt=\"image-20231014060539030\"></p>\n<h4 id=\"7-3-4-课程删除接口测试用例设计\"><a href=\"#7-3-4-课程删除接口测试用例设计\" class=\"headerlink\" title=\"7.3.4 课程删除接口测试用例设计\"></a>7.3.4 课程删除接口测试用例设计</h4><p><img src=\"/../img/image-20231014061221536.png\" alt=\"image-20231014061221536\"></p>\n<p><img src=\"/../img/image-20231014061610452.png\" alt=\"image-20231014061610452\"></p>\n<p>这里的id是<strong>路径参数</strong></p>\n<h5 id=\"7-3-4-1-路径参数\"><a href=\"#7-3-4-1-路径参数\" class=\"headerlink\" title=\"7.3.4.1 路径参数\"></a>7.3.4.1 路径参数</h5><blockquote>\n<p>PathVariable</p>\n</blockquote>\n<p>URL中<strong>末尾一级</strong>的参数</p>\n<p>如： <a href=\"http://kdtx-test.itheima.net/api/clues/course/111\">http://kdtx-test.itheima.net/api/clues/course/111</a></p>\n<p>在Postman中有两种方式添加Path Variable。第一种就是<strong>直接在url中添加</strong>，第二种是<strong>url末尾加</strong><code>:id</code></p>\n<p><img src=\"/../img/image-20231014061840143.png\" alt=\"image-20231014061840143\"></p>\n<p>以上内容为接口测试的基础理论与样例。下面是使用TestNG</p>\n<hr>\n"},{"title":"函数式编程","date":"2023-10-12T06:23:00.000Z","_content":"\n## 1.概述\nLambda是JDK8中的一个**语法糖**。可以对匿名内部类的写法进行简化。是函数式编程思想的体现。\n类型可以推导->省略类型\n方法可以推导->省略方法\n\n## 2.基本格式\n(参数列表) -> 代码\n\n## 3. 实例\n之前在多线程的学习中提到过，线程Thread的创建方式比较知名的有三种：**实现Thread、 new Thread(new Runnable())、实现Callable接口**. \n在第二种方法: 实现Runnable接口时，我们可以用一个**匿名内部类**，来创建实现Runnable接口的对象。\n```java\nThread thread = new Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"匿名内部类\");\n    }\n})\nthread.start();\n```\n通过Lambda，我们可以简化代码成：\n```java\nnew Thread(()->System.out.println(\"匿名内部类\")).start;\n```\n\n","source":"_posts/Lambda表达式.md","raw":"---\ntitle: 函数式编程\ndate: 2023-10-12 02:23:00\ntags:\n    - Java基础  \n    - Java\n    - Lambda表达式\n\ncategories:\n    - Java基础\n---\n\n## 1.概述\nLambda是JDK8中的一个**语法糖**。可以对匿名内部类的写法进行简化。是函数式编程思想的体现。\n类型可以推导->省略类型\n方法可以推导->省略方法\n\n## 2.基本格式\n(参数列表) -> 代码\n\n## 3. 实例\n之前在多线程的学习中提到过，线程Thread的创建方式比较知名的有三种：**实现Thread、 new Thread(new Runnable())、实现Callable接口**. \n在第二种方法: 实现Runnable接口时，我们可以用一个**匿名内部类**，来创建实现Runnable接口的对象。\n```java\nThread thread = new Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"匿名内部类\");\n    }\n})\nthread.start();\n```\n通过Lambda，我们可以简化代码成：\n```java\nnew Thread(()->System.out.println(\"匿名内部类\")).start;\n```\n\n","slug":"Lambda表达式","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"clnmsn9ib0003yohz9qoj4rtb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><p>Lambda是JDK8中的一个<strong>语法糖</strong>。可以对匿名内部类的写法进行简化。是函数式编程思想的体现。<br>类型可以推导-&gt;省略类型<br>方法可以推导-&gt;省略方法</p>\n<h2 id=\"2-基本格式\"><a href=\"#2-基本格式\" class=\"headerlink\" title=\"2.基本格式\"></a>2.基本格式</h2><p>(参数列表) -&gt; 代码</p>\n<h2 id=\"3-实例\"><a href=\"#3-实例\" class=\"headerlink\" title=\"3. 实例\"></a>3. 实例</h2><p>之前在多线程的学习中提到过，线程Thread的创建方式比较知名的有三种：<strong>实现Thread、 new Thread(new Runnable())、实现Callable接口</strong>.<br>在第二种方法: 实现Runnable接口时，我们可以用一个<strong>匿名内部类</strong>，来创建实现Runnable接口的对象。</p>\n<pre><code class=\"java\">Thread thread = new Thread(new Runnable() &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;匿名内部类&quot;);\n    &#125;\n&#125;)\nthread.start();\n</code></pre>\n<p>通过Lambda，我们可以简化代码成：</p>\n<pre><code class=\"java\">new Thread(()-&gt;System.out.println(&quot;匿名内部类&quot;)).start;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h2><p>Lambda是JDK8中的一个<strong>语法糖</strong>。可以对匿名内部类的写法进行简化。是函数式编程思想的体现。<br>类型可以推导-&gt;省略类型<br>方法可以推导-&gt;省略方法</p>\n<h2 id=\"2-基本格式\"><a href=\"#2-基本格式\" class=\"headerlink\" title=\"2.基本格式\"></a>2.基本格式</h2><p>(参数列表) -&gt; 代码</p>\n<h2 id=\"3-实例\"><a href=\"#3-实例\" class=\"headerlink\" title=\"3. 实例\"></a>3. 实例</h2><p>之前在多线程的学习中提到过，线程Thread的创建方式比较知名的有三种：<strong>实现Thread、 new Thread(new Runnable())、实现Callable接口</strong>.<br>在第二种方法: 实现Runnable接口时，我们可以用一个<strong>匿名内部类</strong>，来创建实现Runnable接口的对象。</p>\n<pre><code class=\"java\">Thread thread = new Thread(new Runnable() &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;匿名内部类&quot;);\n    &#125;\n&#125;)\nthread.start();\n</code></pre>\n<p>通过Lambda，我们可以简化代码成：</p>\n<pre><code class=\"java\">new Thread(()-&gt;System.out.println(&quot;匿名内部类&quot;)).start;\n</code></pre>\n"},{"title":"vscode偏好设置","date":"2022-08-12T04:00:00.000Z","_content":"\n## 1. 禁用输入括号后自动补全 \n\n> 每次写方法/函数的时候，当弹出自动补全提示窗口时，恰好你又按了一下\"( )\", vscode就会自动为你补全。\n>\n> 但是事实上你只是想输入括号，而不是输入那个方法。\n>\n> 对此，我们可以在设置中禁用```**acceptSuggestionOnCommitCharacter```这一选项。","source":"_posts/vscode一些小问题.md","raw":"---\ntitle: vscode偏好设置\ndate: 2022-08-12 00:00:00\n---\n\n## 1. 禁用输入括号后自动补全 \n\n> 每次写方法/函数的时候，当弹出自动补全提示窗口时，恰好你又按了一下\"( )\", vscode就会自动为你补全。\n>\n> 但是事实上你只是想输入括号，而不是输入那个方法。\n>\n> 对此，我们可以在设置中禁用```**acceptSuggestionOnCommitCharacter```这一选项。","slug":"vscode一些小问题","published":1,"updated":"2023-11-08T23:48:51.831Z","_id":"clochs9y20002nkhz2wnq40gl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-禁用输入括号后自动补全\"><a href=\"#1-禁用输入括号后自动补全\" class=\"headerlink\" title=\"1. 禁用输入括号后自动补全\"></a>1. 禁用输入括号后自动补全</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>每次写方法&#x2F;函数的时候，当弹出自动补全提示窗口时，恰好你又按了一下”( )”, vscode就会自动为你补全。</p>\n<p>但是事实上你只是想输入括号，而不是输入那个方法。</p>\n<p>对此，我们可以在设置中禁用<code>**acceptSuggestionOnCommitCharacter</code>这一选项。</p></blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-禁用输入括号后自动补全\"><a href=\"#1-禁用输入括号后自动补全\" class=\"headerlink\" title=\"1. 禁用输入括号后自动补全\"></a>1. 禁用输入括号后自动补全</h2><blockquote>\n<p>每次写方法&#x2F;函数的时候，当弹出自动补全提示窗口时，恰好你又按了一下”( )”, vscode就会自动为你补全。</p>\n<p>但是事实上你只是想输入括号，而不是输入那个方法。</p>\n<p>对此，我们可以在设置中禁用<code>**acceptSuggestionOnCommitCharacter</code>这一选项。</p>\n</blockquote>\n"},{"title":"Operting System Design -- CS416 Midterm 篇","date":"2023-10-29T05:11:23.000Z","_content":"\n# 1. 为什么要学习OSD？\n> OS forms the foundation of modern computing\n\n1. **Abstractions**: Modern Software 是如何使用 Hardware的？\n\n2. **Resource Management**： 如何去做 resource isolation？\n\n3. 如何在兼顾**实现以上两点的同时**，确保 **High Performace** ?\n\n在这门课上，主要通过两种方式来学习OS\n\n* 1. Conceptual Learning\n* 2. Intensive Programming\n\n在笔记的书写中，很多时候并不能很好、贴切的翻译一些英文句子和词汇，所以就直接使用了来自课件、书上的原话。\n\n# 2. OS 导论\nOS, 是一个抽象（abstract）和 管理（manage）硬件资源的 **软件**\n从高到低排序： 用户 -> 应用程序 -> 操作系统 -> 硬件\n\n本章将是这门课内容的导论。section 2以后的章节将对对于各个主题，进行更深层次的讨论和总结。\n\n## 2.1 硬件\n\nOS管理的硬件主要有\n\n1. memory： 基本实体都是DRAM,  对应OS中的Memory，使用malloc()作为memory controller, 来分配内存\n2. Disk：对应OS中的File System, 通过SATA传输，使用read()/write() 进行控制\n3. Nework Adapter: 对应OS中的网络模块， 使用send()/recv() 进行传输\n\n\n## 2.2 OS提供了什么？\n\n1. **Software library (abstraction)** between applications and hardware to make the hardware easier to use\n    * Simple, uniform view of diverse hardware devices\n\n2. **Mechanisms and policies for resource management**, to provision and isolate hardware across many applications\n    * Effective multi-tenant（多租户） and multi-application systems\n\n## 2.3 Abstrction\n\n### 2.3.1 现代操作系统通常为哪些资源提供哪些抽象?\n> CPU：进程/线程\n> 内存：地址空间\n> 存储：文件\n\n### 2.3.2 操作系统提供抽象的好处？\n> 允许应用程序重用公共资源\n> 让不同的设备看起来相同 （内存、主板、硬盘）\n> 提供更高级别或更有用的功能\n\n### 2.3.3 挑战\n1. What are the correct abstractions?\n2. How much of the hardware capabilities should be exposed?\n\n## 2.4 System Calls\n* 系统调用允许用户告诉操作系统在硬件上执行什么操作\n* 操作系统提供标准软件接口 （API）\n* 典型的操作系统会导出几百个系统调用\n* 运行程序、访问内存、访问硬件设备......\n\n## 2.5 Resource Management\n> Want fair and efficient use of hardware across applications\n\n### 2.5.1 Advantages of OS providing resource management:\n1. Protect applications from one another\n2. Provide efficient access to resources (cost, time, energy)\n3. Provide fair access to resources\n\n### 2.5.2 Challenges\n1. What are the correct **mechanisms**?\n2. What are the correct **policies**?\n\n## 2.6 Virtualization\n> Make each application believe it has each hardware resource to itself\n> 这门课主要关注：CPU和Memory\n\n### 2.6.1 Virtualizing CPU\n* 系统有大量的虚拟CPU： 将一个物理CPU转换为实际上无穷多数量的CPU。允许很多程序同时执行\n* 可以理解成，当我们在命令行同时执行多个c文件的时候，这时候就可以看成是多个程序同时执行，并实际上使用同一个cpu，但是这些c文件，他们认为自己独占cpu。\n\n### 2.6.2 Virtualizing Memory\n* 物理内存其实是一个byte数组\n* 一个程序将自身所有的数据结构存放在内存中\n* 读取内存 （load）: \n    * 指定一个能够访问数据的地址\n* 写入内存 （store）：\n    * 指定要写入特定地址的数据\n\n虚拟化内存涉及到的一些Mechanism：\n1. Virtual-to-Physical Memory Mapping\n2. Page-Fault\n\nDemo1： 用c分配内存\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[1]) {\n    int a = 0;\n    printf(\"%d\\n\", a);//0\n    //aa指针指向a的地址\n    int *aa = &a; \n    //加了*是指针，对应一个数据的地址。那么指针加上指针，就是再次得到值。\n    *aa += 1;\n    printf(\"%x\\n\", aa);//a16738d4\n    printf(\"%d\\n\", a);//1\n\n    //创建p指针，分配内存。\n    int *p = malloc(sizeof(int));\n    //复制给该片区域\n    *p = 100;\n    printf(\"address of p: %x\\n\", p); //fbf156b0\n    printf(\"value stored in p: %d\\n\", *p);//100\n    printf(\"address of p: %x\\n\", &(*p));//fbf156b0\n}\n```\n\n每个进程都有自己的私有虚拟内存空间（private virtual memory space），OS则会映射这些address space到物理内存中\n* 对一个正在运行的程序的内存引用，不会影响到其他程序的address space。\n* 物理内存是一个由OS管理的共享资源\n\n\n## 2.7 Concurrency\n> Concurrency（并发）： Events are occurring simultaneously and may interact with one another\nOS必须能够处理并发事件\n\n比较简单的处理方式： 直接隔离他们，阻止他们交互，从而达到Hide Concurrency的效果。\n但是，这样子指标不治本。因为很多时候有些任务，就是需要进程间交互才能执行的。这时候，才是真正想办法来处理了。\n常见做法有：\n1. 为进程提供抽象（锁(lock)、信号（semaphores）、条件变量(condition variables)、共享内存(shared memory)、关键部分(critical sections)）\n2. 如果用了锁，则需要确保进程不会死锁\n3. 让交互线程(interaction threads)必须协调对共享数据(shared data)的访问\n\n多线程Demo：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvolatile int counter = 0;\nint loop;\nchar *name;\n\nvoid *worker() {\n    for (int i = 0; i < loop; i++) {\n        counter++;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    loop = atoi(argv[1]);\n    pthread_t p1, p2;\n    printf(\"initial value: %d\\n\", counter);\n    pthread_create(&p1, NULL, worker, NULL);\n    pthread_create(&p2, NULL, worker, NULL);\n    pthread_join(p1, NULL);\n    pthread_join(p2, NULL);\n    printf(\"Final value: %d\\n\", counter); // 20.\n}\n```\n\n可以试着执行之下上面代码。试着改变参数大小。可以发现，如果参数比较小（100~1000），那么最终结果就是参数值*2. 但是，当参数变大后，结果就不对了。\n\n```shell\n./mte 10\ninitial value: 0\nFinal value: 20\n\n./mte 1000\ninitial value: 0\nFinal value: 2000\n\n./mte 10000\ninitial value: 0\nFinal value: 14692\n\n./mte 1000000\ninitial value: 0\nFinal value: 1007083\n```\n\n这是因为并发的情况并没有处理好。p1和p2这两个线程同时执行，并且同时对一个counter进行增加操作。数字小的时候，p1或p2执行的很快，因此并不会出现**p2更新了数字，p1读了旧的数字并将该数字更新到了和p2更新后同样值的情况**。参考数据库的脏读。\n\n有点抽象，举个例子：\n```\np2:  读出counter: 10000  然后+ 1 = 10001\np1： 读出counter: 10000  然后+ 1 = 10001;\n```\n那这样就等于白操作了。\n\n## 2.8 Persistence\n> Persistence: Access information permanently\n\n* 信息的寿命比任何一个线程都要长\n* 机器出现未预期的**重启、断电**。这时候就体现出持久化的重要性了\n\n持久化需要：\n1. 确保出现unexpected failure的时候，信息能够正确的存储\n2. 提供Abstraction使得进程不知道数据是如何存储的\n3. 因为磁盘IO很慢，我们需要对持久化进行优化\n\n### 2.8.1 OS 在持久化过程中做了什么？\n1. 搞清楚新的数据在disk的那一块存放\n2. 向底层（underlying）存储设备（storage device）发出I/O 请求\n3. 文件系统（FileSystem）在IO期间处理崩溃\n\n### 2.8.2 两种持久化策略：\n1. Journaling\n    * 日志文件系统： 一种文件系统，在将这些更改提交到主文件系统之前，使用日志记录对文件系统的更改\n    * 运行流程：\n        * 对文件系统的更改首先记录在日志中\n        * 更改成功写入日志后，将其提交到主文件系统\n        * 当系统出现崩溃或故障时，可以通过重放日志来恢复文件系统。日志中记录的任何不完整或不一致的操作都可以完成或撤消，以维护文件系统的完整性。\n        * 崩溃后恢复速度更快\n        * 数据完整性得到保证\n    * 例子： ext3、ext4\n\n2. Copy on write\n    * 写入时不直接对原位置的数据进行修改，而是写入新的位置\n    * 原数据将一直保存，直到写入完成\n    * 运行流程：\n        1. 当需要读取数据时，首先从当前位置读取数据\n        2. 在新位置制作数据的副本\n        3. 对副本进行修改\n        4. 最后将只想原数据的指针更新指向新数据的副本\n    * 优点：\n        1. 简化了崩溃后的恢复。因为在修改完成前的原始数据不会受到影响\n        2. 提供了任何给定时间点的一致数据快照\n    * 例子： 一些现代化的文件系统，如ZFS、Btrfs\n\n\n## 3 CPU Virtualization\n> 从本章开始，我们正式开始讨论虚拟化的第一个主题： CPU 虚拟化\n> 本章会解决以下问题：\n> 1. What is a process?\n> 2. Why is **limited direct execution** a good approach for virtualizing the CPU? \n> 3. What execution state must be saved for a process? \n> 4. What 3 modes could a process in? \n\n\n### 3.1 What is process?\n> Process: An **execution stream**（执行流） in the context（上下文） of a **process state**\n\n**execution stream**\n    * A stream of executing instructions\n    * Running piece of code\n    * Thread of control (其实和execution stream一个意思。单线程的话就是执行流嘛。然后多线程的话，每个线程都有自己的执行流。)\n\n执行流指的是计算机程序正在执行的指令的顺序流。代表着一段指令是活动的。\n* 说人话，就是正在跑的程序，这个程序得是活的，而不是在磁盘上的静态文件。在跑的过程中，CPU会直接处理这些指令序列\n\n补充一下： CPU全名**central processing unit**。别学了半天OS，CPU到底是个啥都不知道。。\n\n**process state**\n    * Everything that the running code can affect or affected by\n    * Register\n        * Heap, General Purpose, floating point, stack pointer, program counter\n    * Memory Spaces\n    * 例子： Open files\n\n\n* process is not program!\n    * program是静态的代码和数据\n    * process是动态的代码和数据\n    * 可以有多个process运行同一个program\n\n### 3.2 Process Management Segments\n* OS 会为每个进程分配memory。\n* 这个memory，包含了很多的块(segment)\n    * 从上到下来看\n    * 最高层是 stack，用于存储局部变量。也包括command line arguments（位于顶部）， 以及环境变量\n    * 再往下走是Heap。用于动态的memory。 在stack和heap之间，有一块unused segment，用于stack/heap的扩容\n    * .bss Global Uniniialized Variables（全局未初始化变量）\n    * .data Global Initialized Variables（全局已初始化变量）\n    * 最底层才是code。Read-Only\n\n### 3.3 Process vs. Thread\n很明显，进程肯定不是线程\n\n但是他们还是有相似之处的，我们可以把线程看作一个**轻量版** 的process（Light weight Process LWP）。\n\nThread is a execution stream that **shares an address space**\n一个进程里存在多个线程\n\n举个共享内存空间的例子。\n对于进程来说，两个相同程序的不同进程，当他们都在access同一个地址值的时候，他们得到的结果不一样 （内存虚拟化）\n而对于线程，一个进程内的多个线程，当他们都在access同一个地址值的时候，他们得到的结果是一样的\n\n\n对于进程，我们的目标是： **让每个进程都感觉，自己是独占cpu的。**\n\n### 3.4 Resources Sharing\n了解了目标后，我们先看一下OS是怎么分配资源(resources)的\n\n首先， 资源分配通分为两种： \n    1. time sharing\n    2. space sharing\n\n\n> time sharing 主要针对的是**单CPU**的情况。 使多个用户或进程能够共享单个处理器。\n具体做法是：将可用的处理时间划分为多个小的时间间隔（timeslice），并且将这些时间片分配给各个用户/进程。从而打到各个用户/进程公平分配资源的效果，并且在他们各自分配的时间片内，能够独享cpu\n* 关si键词： 公平、快速切换（illusion of multaneous execution）\n\n\n> space sharing 关注的是**空间**上的共享/复用。每一个进程都被分配CPU容量的一小部分。\n* 关键词：并行（Parallel）执行， 同时执行（real simultanous execution）， 资源隔离（resource isolation）\n\n在共享时，我们主要注意两点：\n1. cannot perform restricted operation\n2. should not run forever or make the entire system slow => performance\n\n###3.5 Provide Good CPU Performance\n\n1. Direct Execution\n    * 直接让用户操作硬件： CPU只负责创建并初始化进程，之后的控制权就回到起点（比如main()），交给用户手中了。\n\n这样子用户进程的权限就过大了。因此Direct Execution肯定是有问题的：\n\n1. 进程（Process）可以做一些受限（restricted）的事情\n    * 比如读取/写入别的进程的数据\n\n2. 进程可以永久执行（缓慢，有漏洞，恶意（malicious））\n    * OS 需要在进程之间交换(swap)的能力\n\n3. OS很多操作很慢： 比如I/O  还是进程切换能力\n\n根据以上问题，我们可以给出一个折中的解决方案: 让OS和Hardware保留一些控制权。\n\n### 3.5.1 Restricted Ops\nQ1: 我们如何确保用户进程不会单方面（unilaterally）执行受限(restricted)的操作呢?\n\n解决方法： （权限级别/分离）privilege levels/separation\n\n* 如果想要直接和设备进行交互， 那就用kernal mode，这样就不受限制了。\n\n* 对于用户进程，就在user mode下执行。如果试图和设备进行直接交互，就会进陷阱（trap），然后software interrupt\n\n* 如果用户进程想和设备进行交互的话，可以通过以下方式：\n    1. System Calls (由OS实现的方法)\n    2. Change Privilege Level（权限级别）through system call（trap）\n\nSystem call demo: 1 direct system call & 1 system call provided by libc function.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n\nint main(int argc, char *argv[]) {\n    long ID1, ID2;\n    ID1 = syscall(SYS_getpid);\n    printf(\"direct system call, pid = %ld\\n\", ID1);//direct system call, pid = 3565265\n    ID2 = getpid();\n    printf(\"libc wrapped system call, pid = %ld\\n\", ID2);//libc wrapped system call, pid = 3565265\n}\n```\n\n### 3.6 System Call Table and Trap Table\n> 前面讲到过，系统调用表和陷阱表之间存在映射。用于管理用户引发的系统事件。\n> 主要得知道怎么通过汇编，对系统调用表和陷阱表进行分析，从而得出系统时间的结果。\n\nCPU使用EAX寄存器（register）的内容作为源操作数。\n窍门就是看$后面的数字内容，找系统调用表和陷阱表上数字对应的操作就行。\n\n比如这道题：\n\n```\n\nSuppose the trap table on a machine looks like the following:\n\n1 - illegal; call OS process kill routine\n\n2- run OS system call routine\n\nSuppose the OS's system call table looks like the following.\n\n1 - sys_read()\n\n2 - sys_write()\n\nWhat happens when an application performs the following instructions?\n\nmovl $1, %eax\n\nint $1\n```\n\n前面的1是system call表里的，后面的int $1是trap表里的。所以结果就是kill runtime.\nmovl -> 放进eax， int -> 产生软件中断。\n\n总结一下，user processes 是不被允许直接 perform：\n1. arbitrary memory access\n2. Disk I/O\n3. Special x86 instructions like lidt. (Inteterrupted Discription Table)\n\n如果user processes做了上面的事情，那么大概率就是进了trap，然后kill routine。\n\n\n### 3.7 How to take CPU away?\n> OS 需要实现多任务处理（multitasking）。先记住一个词**上下文切换**。后面会重点围绕这个概念来讲\n\n* Mechanism： To switch between classes\n* Policy: To decide which process to run at what time.\n\n**Mechaism 和 Policy的区别？**\n> Policy: Decision-maker to optimize some workload performance metric\n    * Which Process to run? When to run? => scheduler\n> Mechanism: Low-level code that implements the decision\n    * How ? => Dispatcher\n\n在这里，我们先将Dispatcher\n\nDispatch 的逻辑很简单\n\n```c\nwhile (1) {\n    run process A for some time slice\n    stop process A and save its time\n    load context of another process\n}\n```\n\n问题是：\n    1. dispatcher怎么在一段时间后，重新获得控制？\n    2. 哪些execution context必须被保存并恢复？\n\n#### 3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？\n> Option 1 : Cooperative Muti-tasking\n> 通过trap，将CPU移交给操作系统的信任线程\n    * 例如： System Call， page fault（想要换取的page不在main memory里）或者 error\n    * yield()\n但是，这样子的话也有问题。设想一个process，它没有任何越过自身权限的操作（I/O）， 也没有进任何的Trap，也没有自己叫yield(),那么最终，这个process就会一直占着整个机器。唯一办法只有重启。\n\n这时候就有了第二种选项\n> Option 2: Regain control without cooperation\n我们可以启用周期性的，时钟。进入OS的时候，我们启动时钟，，时钟时间到后，硬件会生成timer interrupt\n用户也不能屏蔽掉timer interrupt，因为他们没有权限这样子做。\n\n#### 3.7.2 Context save在哪里？\n> process control block (PCB) 也可以叫做 process descriptor (PD)\n> 每个进程都会有PCB\n\n### 3.7.2.1 PCB 存储了哪些信息\n1. PID\n2. Process state (I.e., running, ready, or blocked)\n3. Execution state (all registers, PC, stack pointer) -- Context\n4. Scheduling priority\n5. Accounting information (parent and child processes)\n6. Credentials (which resources can be accessed, owner)\n7. Pointers to other allocated resources (e.g., open files)\n\n### 3.7.2.2. Context 保存/切换流程\n1. 进程A从user mode 转换到 kernal mode，权限提升。OS决定从A转到B\n2. 在kernal stack上保存A的上下文（PC， registers， kernal stack pointer）\n3. 将stack pointer指向进程B的kernal stack\n4. 从B的kernal stack中恢复上下文\n\n```c\nstruct context {\n    int eip;\t// Index pointer register\n    int esp;\t// Stack pointer register\n    int ebx;\t// Called the base register\n    int ecx;\t// Called the counter register\n    int edx;\t// Called the data register\n    int esi;\t// Source index register\n    int edi;\t// Destination index register\n    int ebp;\t// Stack base pointer register\n};\n\n```\n\n一些进程在执行不需要Cpu的任务的时候，OS会switch到哪些需要CPU的进程\n为了完成这个功能，OS必须关注进程的状态\n```c\nenum proc_state { UNUSED, EMBRYO, SLEEPING,\n                  RUNNABLE, RUNNING, ZOMBIE };\n```\nRunning: 占用cpu\nReady： 等待CPU\nBlocked：正在等待同步或者I/O.\n\n\n## 4. Scheduling\n\n### 4.1 两种创建Process的方式\n\n1. New process from sratch (从0构建)\n\n* 步骤\n    * 从memory中加载指定代码和数据；并创建空的call stack\n    * create and initialzie pcb\n    * put process on ready list.\n\n好处：定制化，no waste work\n坏处： 很难涵盖所有可能的options for setup. 比如WindowesNT有10个参数，这咋搞。\n\n2. 第二个方式： Clone an existing project and change it.\n   Fork(): 克隆调用者\n    * 停止目前的进程，保存他的状态\n    * 复制代码的stack，code ,data, pcb\n    * 将PCB放进ready list\n   Exec (char *file): exec覆盖调用进程\n    * 替换掉目前的代码和数据\n\ndemo: Base shell program\n```c\nwhile (1) {\n\tChar *cmd = getcmd();\n\tInt retval = fork();\n\tIf (retval == 0) {\n\t\t// This is the child process\n\t\t// Setup the child’s process environment here\n\t\t// E.g., where is standard I/O, how to handle signals?\n\t\texec(cmd);\n\t\t// exec does not return if it succeeds\n\t\tprintf(“ERROR: Could not execute %s\\n”, cmd);\n\t\texit(1);\n\t} else {\n\t\t// This is the parent process; Wait for child to finish\n\t\tint pid = retval;\n\t\twait(pid);\n\t}\n}\n```\n\n### 4.2 Dispatcher 和 Scheduling 区别\n> Dispatcher是一个low level 的mechanism 而 Scheduling是policy\n\nScheduling: Policy to determine which process gets CPU when\n\n重点： How to transition?\t(“mechanism”)\n      When to transition?\t(“policy”)  \n\n一个用于理解的例子：文件IO   Process alternates between CPU and I/O process moves between ready and blocked queues\n\n一些术语\nWorkload: set of **job** descriptions (arrival time, run_time)\n    * Job: View as current CPU burst of a process\n\nMetric: measurement of quality of schedule\n    * Minimize turnaround time\n         Do not want to wait long for job to complete\n         Completion_time – arrival_time （process/thread complete - process/thread add to runqueue）\n    * Minimize response time\n        * Schedule interactive jobs promptly so users see output quickly\n        * Initial_schedule_time – arrival_time （process/thread add to runqueue - process/thread scheduled）\n    * Maximize throughput\n        * Want many jobs to complete per unit of time\n    * Maximize resource utilization\n        * Keep expensive devices busy\n    Minimize overhead\n        * Reduce number of context switches\n    Maximize fairness\n        * All jobs get same amount of CPU over some time interval\n\n\n### 4.3 一些 Scheduler\n> 在考虑Workload的情况下，我们需要考虑这些是否达成\n> 1. Each job runs for the same amount of time\n> 2. All jobs **arrive at the same time**\n> 3. All jobs only use the CPU (no I/O)\n> 4. Run-time of each job is known\n\n#### 4.3.1 FIFO\nFIFO: First In, First Out\t\n    - also called FCFS (first come first served)\n \t- 根据arrive time来干活\n    - ABC同时到，先干A，A好了的同时马上干B\n    - turn_around = completion_time - arrival_time\n\n计算题： 算一下avg_turn_around_time:\n    ![Alt text](image.png)\n\n显然FIFO是不满足第一条的， 每个Job跑的时间都不一样。从而导致，metric中的turnaround会很高\n\n![Alt text](image-1.png)\n如果第一个来的job非常的time-consuming，那么就会导致，后面那些原本能够很快就完成的job，被堵着（阻塞）。\n\n这里的平均turnout_time就达到了 (60 + 70 + 80) / 3 = 70s 而原本有的任务只需要10s就可以完成。\n\n根据FIFO的缺点，我们就可以设计出第二种似乎更好的Scheduler。 Shortest Job First（SJF）\n\n#### 4.3.2 SJF\n> 选择run_time最小的job\n\n计算1： 对于这个例子，平均turnout time是多少呢\n\n![Alt text](image-2.png)\n(10 + 20 + 80) / 3 = 36.7\n\n\n计算2： 对于这个例子，平均turnout time是多少呢\n![Alt text](image-3.png)\nturn_around = completion_time - arrival_time\n记住这个公式，就很好算了。\n    \n\n可以看出，FIFO和SJF都是非抢占式（non-preemptive）的。只有当任务执行完毕，或者优先级不够的情况下，才会让出CPU。\n\n抢占式（preemptive）的CPU则相反。就算你的job已经在执行了，万一来了个比你正在执行的job更牛的job，则会schedule更牛的job，你正在运行的job失去了CPU，在旁边等着\n\n\n#### 4.3.3 STCF\n> Shortest time-to-completion First\n永远执行会完成最快的任务。\n\n计算：平均turnaround time\n![Alt text](image-4.png) \n(80 - 0) + (20 - 10) + (30 - 10) = 80 + 10 +  20 = 110\n110/3 = 36.6s\n很明显在这种情况下，抢占式的turnout time会比非抢占式的快很多\n\n##### 4.3.3.1 Response Time\n> 有时候，从**任务到达**到**任务开始**的这段时间也很重要。我们将这段时间称为：Response Time\n> response_time = first_run_time - arrival_time\n\n![Alt text](image-5.png)\njob b在10s的时候到。 \nturnaround time = 30 - 10 = 20s\nresponse time = 20 - 10 = 10s\n\n#### 4.3.4 RR\n> Round Robin\n> 在response time方面比STCF、SJF、FIFO做的都好\n> 因为它会每一段时间就会交替状态为Ready的进程，从而每个job第一次开始run的时间不会差距不会特别大。\n\n![Alt text](image-6.png)\n\n当前，有得必有失。RR在turnaround time上非常慢。因为job是交替执行的，原本能很快结束的job被迫得隔一段时间就让出CPU。\n通常，我们选择RR的原因是因为我们不知道每个job的run time。选择rr的目的和stcf、sjf一样，都是为了让能够最快完成的进程，有机会最早做到。\n\n\n#### 4.3.5 MLFQ\n> Multi Level Feedback Queue\n\n不同类型的job，要求也不一样\n\n- 交互性的（interactive）program，需要更快的response time\n- 批处理（batch）program，需要更快的turnaround time。\n\nMLFQ 基于多层的RR（Round Robin）实现。\n每层都有更高的优先级，并会抢占低优先级的层数。\n\n##### 4.3.5 决定优先级\n\n两种方式能够用来决定优先级。\n1. History\n> 使用进程过去的behavior来预测未来的behavior\n> 根据此进程过去的 CPU 突发（作业），猜测 CPU 突发（作业）的行为方式\n\n##### 4.3.6 MLFQ Rules \n1. If priority(A) > priority(B), A runs\n2. If priority(A) == priority(B), A and B runs in RR\n3. Process start at the top priority\n4. If job uses the full timeslice, then demote process\n\nMLFQ 的小缺陷\n低优先级的任务可能永远都不会被scheduled。因此，我们需要每隔一段时间就去将所有的job放到最高优先级的队列中。\n\n#### 4.3.6 Lottery Schedudling\n就和它的名字一样。彩票。\n目标： fair share\n* 只关心能否公平地分享CPU\n\n**Fair Scheduler**:: Guarantee that each job obtain a certain percentage of CPU time. Not care about response time or turnaroud time\n实现逻辑也很简单： 给processes 一张彩票，谁中了谁就run。更高的优先级说明拿到了更多的彩票。\n\nTicket: 代表了一个process可以占用多少份额的资源。\n\n比如 Process A拿了75张票，那就占用75%的CPU。 Proess B拿了25张票，那就占用25%的CPU\n然后Scheduler就会在这100张票里去抽，抽中哪一个数字，就执行手里握着那个数字的线程任务。\n\nlottery 算法的实现\n```c\nint counter = 0;\nint winner = getrandom(0, totaltickets);\nnode_t *current = head;\n\nwhile (current) {\n    counter += current->tickets;\n    if (counter > winner)\n        break;\n    current = current->next;\n}\n// current is the winner\n\n```\n\n![Alt text](image.png)\n\n\n#### 4.3.7 Stride Scheduling\n目标同样是为了防止任何线程monopoly CPU。\n\nThe basic idea is assign each process a 'stride', which represents its priority or share of the CPU time. \n\n系统中的每个进程都被分配了一个唯一的步长值。步幅与进程的优先级成反比。优先级较高的进程分配较小的步幅，优先级较低的进程分配较大的步幅。目标是让优先级较高的进程更频繁地访问 CPU。\n\n同样，进程会被放进一个队列。所有进程自身的counter从0开始。每次自己被执行了，就将自身的counter 翻一翻（counter + stride）。 Scheduler会选择具有最小counter的process。\n![Alt text](image-1.png)\n\n* Stride Scheduling同样也存在问题：\n    * 对于新增job，很难确保公平性和优先性。因为每个job，在初始状态下，counter都是0.问题是，当这些线程执行了一段时间后，counter就会变得很大，起码会和0差很多。那么新的job加进来，scheduler必然会判定一直让新job占用cpu，这样就不公平了\n    * 就算不考虑新增。如果你想手动更改process的优先级，又该怎么做呢\n    \n#### 4.3.8 Complete Fair Scheduling\n很显然Stride Scheduling可以确保一定的完整性，但是不能完全确保完全公平\n\n我们的目标是无论线程数量的大小，无论何时添加、更改线程，都能保证其公平地使用资源\n\nComplete Fair Scheduling(CFS) 自从Linux 2.6.23 版本被应用。 O(logN) runtime\n原本是MLFQ\nProcess now ordered by the amount of CPU time they use\n取代了队列，转而使用红黑树\n\n* CFS核心概念\n    * 使用一个counter记录累计执行时间（cummulative execution time）\n    * Schedule process with **least** runtime\n\n下面这些都是gpt对其的介绍\n* 虚拟运行时间：\n    * CFS为每个可运行的进程维护一个“虚拟运行时间”。虚拟运行时间表示一个进程等待执行的时间相对于其他进程。较小的虚拟运行时间值表示更高的优先级。\n\n* 调度决策：\n    * 选择具有最小虚拟运行时间的进程进行执行。这确保了等待时间较长或累积CPU时间较短的进程被优先考虑。\n\n* 时间量子：\n    * CFS不使用固定的时间片或时间量子，而是根据可运行进程的数量和它们的虚拟运行时间动态调整时间量子。\n\n* 动态时间量子计算：\n    * CFS根据进程的权重计算每个进程的时间量子。权重是分配给每个进程的值，表示它在CPU中的份额。较高的权重导致较大的时间量子。\n\n* 权重和Nice值：\n    * 进程根据其优先级被分配权重。用户进程可以使用“nice”值进行优先级调整，该值范围从-20到+19。较低的nice值表示较高的优先级。权重与nice值成反比。\n\n* 平衡机制：\n    * CFS采用平衡机制来维持随时间的公平性。它定期检查运行队列，如果检测到不平衡，则重新分配负载。这有助于确保没有进程在CPU时间上被不公平地耗尽。\n\n* 稳态公平性：\n    * CFS旨在实现稳态公平性，这意味着在更长的时间内，每个进程都能获得其公平份额的CPU时间，而不考虑短期波动。\n\n* 红黑树数据结构：\n    * CFS中的运行队列使用红黑树数据结构实现。这允许根据它们的虚拟运行时间有效地插入和删除进程。\n\n\n![Alt text](image-2.png)\n\n\n## 5. Muti-core Scheduling\n> 由于多核处理器的兴起，多核调度成为必须。因为单单添加CPU的数量不会让一个应用程序执行地更快。我们需要重写应用程序以保证其能**并行**执行\n\n### 5.1 单CPU + 缓存 + main memory\nCPU分出一篇区域给缓存，存放popular data found in main memory. 速度块，容量小\nMain memory存放所有数据，从main memory获取数据的速度会比cache慢很多\n\n### 5.2 多CPU情况\n简单来说，每个CPU都有一个缓存区域。那两个CPU加起来就有两块缓存区域了。\n\n同步不同缓存区域的内存看起来很简单： CPU0 将memory中的 数据放进了自己的缓存区，CPU1会读取CPU0的缓存区，同步数据。\n\n但是，有一种特殊情况：\n    1. CPU 0 读内存放进缓存，CPU1 读到了共享。\n    2. CPU 0 更新了缓存中的数据 同时 CPU 1 被schedule了\n    3. 此时 CPU 1 中保存的还是过去的数据。\n数据就不一致了\n\n\n解决方法很简单： Bus Snooping\n    * 每个cache都会通过观察bus来注意到memory的更新\n    * 当CPU注意到自身memory中的数据更新了，就会注意到这个变化\n\n### 5.3 Cache Affinity\n> 无论是多CPU还是单CPU，Scheduler都会尝试将一个进程放在同一个CPU上执行。因为当CPU在执行该线程时，会往缓存里加很多关于改进程的状态。那么等到改进程下次启动时，就会更快一点，因为缓存里已经有信息了\n\n实现方式：将所有需要scheduled的任务全部放在一个队列里面。每个CPU就从这个**Globally Shared**的队列里面拿job。\n\n坏处： \n    1. 锁 \n    2. 扩展性缺少\n    3. Cache Affinity\n    4. 实现起来复杂\n\n### 5.4 Multi-queue Multiprocessor Scheduling (MQMS)\n* Contains Multiple Scheduling queues\n    * 每条队列都有自己的Scheduling Discipline\n    * 当job进入系统的时候，只会放在一条队列上， 从而避免了信息共享（information sharing）和 同步（synchronization）的问题\n\n\nMQMS with Round Robin\n![Alt text](image-3.png)\n\nMQMS的问题： 需要通过跨内核迁移进程来平衡跨内核的负载\n\n## 6. Virtualizing Memory\n\n目标： \n\n* Transparency\n  * Processes are not aware that memory is shared\n  * Works regardless of number and/or location of processes\n* Protection\n  * Cannot corrupt OS or other processes\n* Privacy\n  * Cannot read data of other processes\n* Efficiency\n  * Do not waste memory resources (minimize fragmentation（碎片化）)\n* Sharing\n  * Cooperating processes can share portions of address space\n\n### 6.1 Abstraction: Address Space\n\n> Address space: Each process has set of addresses that map to bytes\n\n问题是：OS是如何让每个Process觉得，自己有专用的地址空间的？\n\n** 回顾 Addresss Space 中都有什么？ **\n\n1. 静态：\n   * Code\n   * Global Variables\n2. 动态：\n   * Stack\n   * Heap\n\n#### 6.1.1 为什么进程需要动态地分配资源？\n\n> 1. 不知道编译时需要的内存量. 静态分配内存时必须悲观, 为最坏的情况分配足够的资源;不高效地使用存储\n> 2. 对于那些递归的步骤，不知道会嵌套多少次\n> 3. 进程中会有复杂的数据结构，需要我们手动分配资源。\n\n#### 6.1.2 Stack用在哪里？\n\n> 操作系统将Stack用于过程调用帧(procedure call frames), 存放local varibles and parameters\n> 局部变量例子\n\n```c\n#include <stdio.h>\n\nvoid foo(int z);\n\nint main(int argc, char *argv[]) {\n    int A = 0; \n    foo(A);\n    printf(\"A: %d\\n\", A); //A: 0\n}\n\nvoid foo(int z) {\n    int A = 2;\n    z = 5;\n    printf(\"A: %d, Z: %d\\n\", A, z); //A: 2, Z: 5\n}\n```\n\n#### 6.1.3 Heap用在哪里？\n\n> 任何位置的malloc(), new() 都会跑到heap里\n>\n>   * Heap memory consists of allocated area and free area\n>   * Order of Allocation and free is unpredictable.\n\npro：所有数据结构都是这样用的\ncons: \n    * Allocation can be slow\n    * End up with small chunks of free spaces -- Fragmentation(碎片化)\n\n#### 6.1.4 OS在managing heap中的作用\n\n> OS gives big chunk of free memory to process\n> OS provides library manages individual allocations\n\n代码中各个数据结构在address space中的分布\n![Alt text](image-4.png)\n\n","source":"_posts/OSD.md","raw":"---\ntitle:  Operting System Design -- CS416 Midterm 篇\ndate: 2023-10-29 01:11:23\n---\n\n# 1. 为什么要学习OSD？\n> OS forms the foundation of modern computing\n\n1. **Abstractions**: Modern Software 是如何使用 Hardware的？\n\n2. **Resource Management**： 如何去做 resource isolation？\n\n3. 如何在兼顾**实现以上两点的同时**，确保 **High Performace** ?\n\n在这门课上，主要通过两种方式来学习OS\n\n* 1. Conceptual Learning\n* 2. Intensive Programming\n\n在笔记的书写中，很多时候并不能很好、贴切的翻译一些英文句子和词汇，所以就直接使用了来自课件、书上的原话。\n\n# 2. OS 导论\nOS, 是一个抽象（abstract）和 管理（manage）硬件资源的 **软件**\n从高到低排序： 用户 -> 应用程序 -> 操作系统 -> 硬件\n\n本章将是这门课内容的导论。section 2以后的章节将对对于各个主题，进行更深层次的讨论和总结。\n\n## 2.1 硬件\n\nOS管理的硬件主要有\n\n1. memory： 基本实体都是DRAM,  对应OS中的Memory，使用malloc()作为memory controller, 来分配内存\n2. Disk：对应OS中的File System, 通过SATA传输，使用read()/write() 进行控制\n3. Nework Adapter: 对应OS中的网络模块， 使用send()/recv() 进行传输\n\n\n## 2.2 OS提供了什么？\n\n1. **Software library (abstraction)** between applications and hardware to make the hardware easier to use\n    * Simple, uniform view of diverse hardware devices\n\n2. **Mechanisms and policies for resource management**, to provision and isolate hardware across many applications\n    * Effective multi-tenant（多租户） and multi-application systems\n\n## 2.3 Abstrction\n\n### 2.3.1 现代操作系统通常为哪些资源提供哪些抽象?\n> CPU：进程/线程\n> 内存：地址空间\n> 存储：文件\n\n### 2.3.2 操作系统提供抽象的好处？\n> 允许应用程序重用公共资源\n> 让不同的设备看起来相同 （内存、主板、硬盘）\n> 提供更高级别或更有用的功能\n\n### 2.3.3 挑战\n1. What are the correct abstractions?\n2. How much of the hardware capabilities should be exposed?\n\n## 2.4 System Calls\n* 系统调用允许用户告诉操作系统在硬件上执行什么操作\n* 操作系统提供标准软件接口 （API）\n* 典型的操作系统会导出几百个系统调用\n* 运行程序、访问内存、访问硬件设备......\n\n## 2.5 Resource Management\n> Want fair and efficient use of hardware across applications\n\n### 2.5.1 Advantages of OS providing resource management:\n1. Protect applications from one another\n2. Provide efficient access to resources (cost, time, energy)\n3. Provide fair access to resources\n\n### 2.5.2 Challenges\n1. What are the correct **mechanisms**?\n2. What are the correct **policies**?\n\n## 2.6 Virtualization\n> Make each application believe it has each hardware resource to itself\n> 这门课主要关注：CPU和Memory\n\n### 2.6.1 Virtualizing CPU\n* 系统有大量的虚拟CPU： 将一个物理CPU转换为实际上无穷多数量的CPU。允许很多程序同时执行\n* 可以理解成，当我们在命令行同时执行多个c文件的时候，这时候就可以看成是多个程序同时执行，并实际上使用同一个cpu，但是这些c文件，他们认为自己独占cpu。\n\n### 2.6.2 Virtualizing Memory\n* 物理内存其实是一个byte数组\n* 一个程序将自身所有的数据结构存放在内存中\n* 读取内存 （load）: \n    * 指定一个能够访问数据的地址\n* 写入内存 （store）：\n    * 指定要写入特定地址的数据\n\n虚拟化内存涉及到的一些Mechanism：\n1. Virtual-to-Physical Memory Mapping\n2. Page-Fault\n\nDemo1： 用c分配内存\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[1]) {\n    int a = 0;\n    printf(\"%d\\n\", a);//0\n    //aa指针指向a的地址\n    int *aa = &a; \n    //加了*是指针，对应一个数据的地址。那么指针加上指针，就是再次得到值。\n    *aa += 1;\n    printf(\"%x\\n\", aa);//a16738d4\n    printf(\"%d\\n\", a);//1\n\n    //创建p指针，分配内存。\n    int *p = malloc(sizeof(int));\n    //复制给该片区域\n    *p = 100;\n    printf(\"address of p: %x\\n\", p); //fbf156b0\n    printf(\"value stored in p: %d\\n\", *p);//100\n    printf(\"address of p: %x\\n\", &(*p));//fbf156b0\n}\n```\n\n每个进程都有自己的私有虚拟内存空间（private virtual memory space），OS则会映射这些address space到物理内存中\n* 对一个正在运行的程序的内存引用，不会影响到其他程序的address space。\n* 物理内存是一个由OS管理的共享资源\n\n\n## 2.7 Concurrency\n> Concurrency（并发）： Events are occurring simultaneously and may interact with one another\nOS必须能够处理并发事件\n\n比较简单的处理方式： 直接隔离他们，阻止他们交互，从而达到Hide Concurrency的效果。\n但是，这样子指标不治本。因为很多时候有些任务，就是需要进程间交互才能执行的。这时候，才是真正想办法来处理了。\n常见做法有：\n1. 为进程提供抽象（锁(lock)、信号（semaphores）、条件变量(condition variables)、共享内存(shared memory)、关键部分(critical sections)）\n2. 如果用了锁，则需要确保进程不会死锁\n3. 让交互线程(interaction threads)必须协调对共享数据(shared data)的访问\n\n多线程Demo：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nvolatile int counter = 0;\nint loop;\nchar *name;\n\nvoid *worker() {\n    for (int i = 0; i < loop; i++) {\n        counter++;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    loop = atoi(argv[1]);\n    pthread_t p1, p2;\n    printf(\"initial value: %d\\n\", counter);\n    pthread_create(&p1, NULL, worker, NULL);\n    pthread_create(&p2, NULL, worker, NULL);\n    pthread_join(p1, NULL);\n    pthread_join(p2, NULL);\n    printf(\"Final value: %d\\n\", counter); // 20.\n}\n```\n\n可以试着执行之下上面代码。试着改变参数大小。可以发现，如果参数比较小（100~1000），那么最终结果就是参数值*2. 但是，当参数变大后，结果就不对了。\n\n```shell\n./mte 10\ninitial value: 0\nFinal value: 20\n\n./mte 1000\ninitial value: 0\nFinal value: 2000\n\n./mte 10000\ninitial value: 0\nFinal value: 14692\n\n./mte 1000000\ninitial value: 0\nFinal value: 1007083\n```\n\n这是因为并发的情况并没有处理好。p1和p2这两个线程同时执行，并且同时对一个counter进行增加操作。数字小的时候，p1或p2执行的很快，因此并不会出现**p2更新了数字，p1读了旧的数字并将该数字更新到了和p2更新后同样值的情况**。参考数据库的脏读。\n\n有点抽象，举个例子：\n```\np2:  读出counter: 10000  然后+ 1 = 10001\np1： 读出counter: 10000  然后+ 1 = 10001;\n```\n那这样就等于白操作了。\n\n## 2.8 Persistence\n> Persistence: Access information permanently\n\n* 信息的寿命比任何一个线程都要长\n* 机器出现未预期的**重启、断电**。这时候就体现出持久化的重要性了\n\n持久化需要：\n1. 确保出现unexpected failure的时候，信息能够正确的存储\n2. 提供Abstraction使得进程不知道数据是如何存储的\n3. 因为磁盘IO很慢，我们需要对持久化进行优化\n\n### 2.8.1 OS 在持久化过程中做了什么？\n1. 搞清楚新的数据在disk的那一块存放\n2. 向底层（underlying）存储设备（storage device）发出I/O 请求\n3. 文件系统（FileSystem）在IO期间处理崩溃\n\n### 2.8.2 两种持久化策略：\n1. Journaling\n    * 日志文件系统： 一种文件系统，在将这些更改提交到主文件系统之前，使用日志记录对文件系统的更改\n    * 运行流程：\n        * 对文件系统的更改首先记录在日志中\n        * 更改成功写入日志后，将其提交到主文件系统\n        * 当系统出现崩溃或故障时，可以通过重放日志来恢复文件系统。日志中记录的任何不完整或不一致的操作都可以完成或撤消，以维护文件系统的完整性。\n        * 崩溃后恢复速度更快\n        * 数据完整性得到保证\n    * 例子： ext3、ext4\n\n2. Copy on write\n    * 写入时不直接对原位置的数据进行修改，而是写入新的位置\n    * 原数据将一直保存，直到写入完成\n    * 运行流程：\n        1. 当需要读取数据时，首先从当前位置读取数据\n        2. 在新位置制作数据的副本\n        3. 对副本进行修改\n        4. 最后将只想原数据的指针更新指向新数据的副本\n    * 优点：\n        1. 简化了崩溃后的恢复。因为在修改完成前的原始数据不会受到影响\n        2. 提供了任何给定时间点的一致数据快照\n    * 例子： 一些现代化的文件系统，如ZFS、Btrfs\n\n\n## 3 CPU Virtualization\n> 从本章开始，我们正式开始讨论虚拟化的第一个主题： CPU 虚拟化\n> 本章会解决以下问题：\n> 1. What is a process?\n> 2. Why is **limited direct execution** a good approach for virtualizing the CPU? \n> 3. What execution state must be saved for a process? \n> 4. What 3 modes could a process in? \n\n\n### 3.1 What is process?\n> Process: An **execution stream**（执行流） in the context（上下文） of a **process state**\n\n**execution stream**\n    * A stream of executing instructions\n    * Running piece of code\n    * Thread of control (其实和execution stream一个意思。单线程的话就是执行流嘛。然后多线程的话，每个线程都有自己的执行流。)\n\n执行流指的是计算机程序正在执行的指令的顺序流。代表着一段指令是活动的。\n* 说人话，就是正在跑的程序，这个程序得是活的，而不是在磁盘上的静态文件。在跑的过程中，CPU会直接处理这些指令序列\n\n补充一下： CPU全名**central processing unit**。别学了半天OS，CPU到底是个啥都不知道。。\n\n**process state**\n    * Everything that the running code can affect or affected by\n    * Register\n        * Heap, General Purpose, floating point, stack pointer, program counter\n    * Memory Spaces\n    * 例子： Open files\n\n\n* process is not program!\n    * program是静态的代码和数据\n    * process是动态的代码和数据\n    * 可以有多个process运行同一个program\n\n### 3.2 Process Management Segments\n* OS 会为每个进程分配memory。\n* 这个memory，包含了很多的块(segment)\n    * 从上到下来看\n    * 最高层是 stack，用于存储局部变量。也包括command line arguments（位于顶部）， 以及环境变量\n    * 再往下走是Heap。用于动态的memory。 在stack和heap之间，有一块unused segment，用于stack/heap的扩容\n    * .bss Global Uniniialized Variables（全局未初始化变量）\n    * .data Global Initialized Variables（全局已初始化变量）\n    * 最底层才是code。Read-Only\n\n### 3.3 Process vs. Thread\n很明显，进程肯定不是线程\n\n但是他们还是有相似之处的，我们可以把线程看作一个**轻量版** 的process（Light weight Process LWP）。\n\nThread is a execution stream that **shares an address space**\n一个进程里存在多个线程\n\n举个共享内存空间的例子。\n对于进程来说，两个相同程序的不同进程，当他们都在access同一个地址值的时候，他们得到的结果不一样 （内存虚拟化）\n而对于线程，一个进程内的多个线程，当他们都在access同一个地址值的时候，他们得到的结果是一样的\n\n\n对于进程，我们的目标是： **让每个进程都感觉，自己是独占cpu的。**\n\n### 3.4 Resources Sharing\n了解了目标后，我们先看一下OS是怎么分配资源(resources)的\n\n首先， 资源分配通分为两种： \n    1. time sharing\n    2. space sharing\n\n\n> time sharing 主要针对的是**单CPU**的情况。 使多个用户或进程能够共享单个处理器。\n具体做法是：将可用的处理时间划分为多个小的时间间隔（timeslice），并且将这些时间片分配给各个用户/进程。从而打到各个用户/进程公平分配资源的效果，并且在他们各自分配的时间片内，能够独享cpu\n* 关si键词： 公平、快速切换（illusion of multaneous execution）\n\n\n> space sharing 关注的是**空间**上的共享/复用。每一个进程都被分配CPU容量的一小部分。\n* 关键词：并行（Parallel）执行， 同时执行（real simultanous execution）， 资源隔离（resource isolation）\n\n在共享时，我们主要注意两点：\n1. cannot perform restricted operation\n2. should not run forever or make the entire system slow => performance\n\n###3.5 Provide Good CPU Performance\n\n1. Direct Execution\n    * 直接让用户操作硬件： CPU只负责创建并初始化进程，之后的控制权就回到起点（比如main()），交给用户手中了。\n\n这样子用户进程的权限就过大了。因此Direct Execution肯定是有问题的：\n\n1. 进程（Process）可以做一些受限（restricted）的事情\n    * 比如读取/写入别的进程的数据\n\n2. 进程可以永久执行（缓慢，有漏洞，恶意（malicious））\n    * OS 需要在进程之间交换(swap)的能力\n\n3. OS很多操作很慢： 比如I/O  还是进程切换能力\n\n根据以上问题，我们可以给出一个折中的解决方案: 让OS和Hardware保留一些控制权。\n\n### 3.5.1 Restricted Ops\nQ1: 我们如何确保用户进程不会单方面（unilaterally）执行受限(restricted)的操作呢?\n\n解决方法： （权限级别/分离）privilege levels/separation\n\n* 如果想要直接和设备进行交互， 那就用kernal mode，这样就不受限制了。\n\n* 对于用户进程，就在user mode下执行。如果试图和设备进行直接交互，就会进陷阱（trap），然后software interrupt\n\n* 如果用户进程想和设备进行交互的话，可以通过以下方式：\n    1. System Calls (由OS实现的方法)\n    2. Change Privilege Level（权限级别）through system call（trap）\n\nSystem call demo: 1 direct system call & 1 system call provided by libc function.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n\nint main(int argc, char *argv[]) {\n    long ID1, ID2;\n    ID1 = syscall(SYS_getpid);\n    printf(\"direct system call, pid = %ld\\n\", ID1);//direct system call, pid = 3565265\n    ID2 = getpid();\n    printf(\"libc wrapped system call, pid = %ld\\n\", ID2);//libc wrapped system call, pid = 3565265\n}\n```\n\n### 3.6 System Call Table and Trap Table\n> 前面讲到过，系统调用表和陷阱表之间存在映射。用于管理用户引发的系统事件。\n> 主要得知道怎么通过汇编，对系统调用表和陷阱表进行分析，从而得出系统时间的结果。\n\nCPU使用EAX寄存器（register）的内容作为源操作数。\n窍门就是看$后面的数字内容，找系统调用表和陷阱表上数字对应的操作就行。\n\n比如这道题：\n\n```\n\nSuppose the trap table on a machine looks like the following:\n\n1 - illegal; call OS process kill routine\n\n2- run OS system call routine\n\nSuppose the OS's system call table looks like the following.\n\n1 - sys_read()\n\n2 - sys_write()\n\nWhat happens when an application performs the following instructions?\n\nmovl $1, %eax\n\nint $1\n```\n\n前面的1是system call表里的，后面的int $1是trap表里的。所以结果就是kill runtime.\nmovl -> 放进eax， int -> 产生软件中断。\n\n总结一下，user processes 是不被允许直接 perform：\n1. arbitrary memory access\n2. Disk I/O\n3. Special x86 instructions like lidt. (Inteterrupted Discription Table)\n\n如果user processes做了上面的事情，那么大概率就是进了trap，然后kill routine。\n\n\n### 3.7 How to take CPU away?\n> OS 需要实现多任务处理（multitasking）。先记住一个词**上下文切换**。后面会重点围绕这个概念来讲\n\n* Mechanism： To switch between classes\n* Policy: To decide which process to run at what time.\n\n**Mechaism 和 Policy的区别？**\n> Policy: Decision-maker to optimize some workload performance metric\n    * Which Process to run? When to run? => scheduler\n> Mechanism: Low-level code that implements the decision\n    * How ? => Dispatcher\n\n在这里，我们先将Dispatcher\n\nDispatch 的逻辑很简单\n\n```c\nwhile (1) {\n    run process A for some time slice\n    stop process A and save its time\n    load context of another process\n}\n```\n\n问题是：\n    1. dispatcher怎么在一段时间后，重新获得控制？\n    2. 哪些execution context必须被保存并恢复？\n\n#### 3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？\n> Option 1 : Cooperative Muti-tasking\n> 通过trap，将CPU移交给操作系统的信任线程\n    * 例如： System Call， page fault（想要换取的page不在main memory里）或者 error\n    * yield()\n但是，这样子的话也有问题。设想一个process，它没有任何越过自身权限的操作（I/O）， 也没有进任何的Trap，也没有自己叫yield(),那么最终，这个process就会一直占着整个机器。唯一办法只有重启。\n\n这时候就有了第二种选项\n> Option 2: Regain control without cooperation\n我们可以启用周期性的，时钟。进入OS的时候，我们启动时钟，，时钟时间到后，硬件会生成timer interrupt\n用户也不能屏蔽掉timer interrupt，因为他们没有权限这样子做。\n\n#### 3.7.2 Context save在哪里？\n> process control block (PCB) 也可以叫做 process descriptor (PD)\n> 每个进程都会有PCB\n\n### 3.7.2.1 PCB 存储了哪些信息\n1. PID\n2. Process state (I.e., running, ready, or blocked)\n3. Execution state (all registers, PC, stack pointer) -- Context\n4. Scheduling priority\n5. Accounting information (parent and child processes)\n6. Credentials (which resources can be accessed, owner)\n7. Pointers to other allocated resources (e.g., open files)\n\n### 3.7.2.2. Context 保存/切换流程\n1. 进程A从user mode 转换到 kernal mode，权限提升。OS决定从A转到B\n2. 在kernal stack上保存A的上下文（PC， registers， kernal stack pointer）\n3. 将stack pointer指向进程B的kernal stack\n4. 从B的kernal stack中恢复上下文\n\n```c\nstruct context {\n    int eip;\t// Index pointer register\n    int esp;\t// Stack pointer register\n    int ebx;\t// Called the base register\n    int ecx;\t// Called the counter register\n    int edx;\t// Called the data register\n    int esi;\t// Source index register\n    int edi;\t// Destination index register\n    int ebp;\t// Stack base pointer register\n};\n\n```\n\n一些进程在执行不需要Cpu的任务的时候，OS会switch到哪些需要CPU的进程\n为了完成这个功能，OS必须关注进程的状态\n```c\nenum proc_state { UNUSED, EMBRYO, SLEEPING,\n                  RUNNABLE, RUNNING, ZOMBIE };\n```\nRunning: 占用cpu\nReady： 等待CPU\nBlocked：正在等待同步或者I/O.\n\n\n## 4. Scheduling\n\n### 4.1 两种创建Process的方式\n\n1. New process from sratch (从0构建)\n\n* 步骤\n    * 从memory中加载指定代码和数据；并创建空的call stack\n    * create and initialzie pcb\n    * put process on ready list.\n\n好处：定制化，no waste work\n坏处： 很难涵盖所有可能的options for setup. 比如WindowesNT有10个参数，这咋搞。\n\n2. 第二个方式： Clone an existing project and change it.\n   Fork(): 克隆调用者\n    * 停止目前的进程，保存他的状态\n    * 复制代码的stack，code ,data, pcb\n    * 将PCB放进ready list\n   Exec (char *file): exec覆盖调用进程\n    * 替换掉目前的代码和数据\n\ndemo: Base shell program\n```c\nwhile (1) {\n\tChar *cmd = getcmd();\n\tInt retval = fork();\n\tIf (retval == 0) {\n\t\t// This is the child process\n\t\t// Setup the child’s process environment here\n\t\t// E.g., where is standard I/O, how to handle signals?\n\t\texec(cmd);\n\t\t// exec does not return if it succeeds\n\t\tprintf(“ERROR: Could not execute %s\\n”, cmd);\n\t\texit(1);\n\t} else {\n\t\t// This is the parent process; Wait for child to finish\n\t\tint pid = retval;\n\t\twait(pid);\n\t}\n}\n```\n\n### 4.2 Dispatcher 和 Scheduling 区别\n> Dispatcher是一个low level 的mechanism 而 Scheduling是policy\n\nScheduling: Policy to determine which process gets CPU when\n\n重点： How to transition?\t(“mechanism”)\n      When to transition?\t(“policy”)  \n\n一个用于理解的例子：文件IO   Process alternates between CPU and I/O process moves between ready and blocked queues\n\n一些术语\nWorkload: set of **job** descriptions (arrival time, run_time)\n    * Job: View as current CPU burst of a process\n\nMetric: measurement of quality of schedule\n    * Minimize turnaround time\n         Do not want to wait long for job to complete\n         Completion_time – arrival_time （process/thread complete - process/thread add to runqueue）\n    * Minimize response time\n        * Schedule interactive jobs promptly so users see output quickly\n        * Initial_schedule_time – arrival_time （process/thread add to runqueue - process/thread scheduled）\n    * Maximize throughput\n        * Want many jobs to complete per unit of time\n    * Maximize resource utilization\n        * Keep expensive devices busy\n    Minimize overhead\n        * Reduce number of context switches\n    Maximize fairness\n        * All jobs get same amount of CPU over some time interval\n\n\n### 4.3 一些 Scheduler\n> 在考虑Workload的情况下，我们需要考虑这些是否达成\n> 1. Each job runs for the same amount of time\n> 2. All jobs **arrive at the same time**\n> 3. All jobs only use the CPU (no I/O)\n> 4. Run-time of each job is known\n\n#### 4.3.1 FIFO\nFIFO: First In, First Out\t\n    - also called FCFS (first come first served)\n \t- 根据arrive time来干活\n    - ABC同时到，先干A，A好了的同时马上干B\n    - turn_around = completion_time - arrival_time\n\n计算题： 算一下avg_turn_around_time:\n    ![Alt text](image.png)\n\n显然FIFO是不满足第一条的， 每个Job跑的时间都不一样。从而导致，metric中的turnaround会很高\n\n![Alt text](image-1.png)\n如果第一个来的job非常的time-consuming，那么就会导致，后面那些原本能够很快就完成的job，被堵着（阻塞）。\n\n这里的平均turnout_time就达到了 (60 + 70 + 80) / 3 = 70s 而原本有的任务只需要10s就可以完成。\n\n根据FIFO的缺点，我们就可以设计出第二种似乎更好的Scheduler。 Shortest Job First（SJF）\n\n#### 4.3.2 SJF\n> 选择run_time最小的job\n\n计算1： 对于这个例子，平均turnout time是多少呢\n\n![Alt text](image-2.png)\n(10 + 20 + 80) / 3 = 36.7\n\n\n计算2： 对于这个例子，平均turnout time是多少呢\n![Alt text](image-3.png)\nturn_around = completion_time - arrival_time\n记住这个公式，就很好算了。\n    \n\n可以看出，FIFO和SJF都是非抢占式（non-preemptive）的。只有当任务执行完毕，或者优先级不够的情况下，才会让出CPU。\n\n抢占式（preemptive）的CPU则相反。就算你的job已经在执行了，万一来了个比你正在执行的job更牛的job，则会schedule更牛的job，你正在运行的job失去了CPU，在旁边等着\n\n\n#### 4.3.3 STCF\n> Shortest time-to-completion First\n永远执行会完成最快的任务。\n\n计算：平均turnaround time\n![Alt text](image-4.png) \n(80 - 0) + (20 - 10) + (30 - 10) = 80 + 10 +  20 = 110\n110/3 = 36.6s\n很明显在这种情况下，抢占式的turnout time会比非抢占式的快很多\n\n##### 4.3.3.1 Response Time\n> 有时候，从**任务到达**到**任务开始**的这段时间也很重要。我们将这段时间称为：Response Time\n> response_time = first_run_time - arrival_time\n\n![Alt text](image-5.png)\njob b在10s的时候到。 \nturnaround time = 30 - 10 = 20s\nresponse time = 20 - 10 = 10s\n\n#### 4.3.4 RR\n> Round Robin\n> 在response time方面比STCF、SJF、FIFO做的都好\n> 因为它会每一段时间就会交替状态为Ready的进程，从而每个job第一次开始run的时间不会差距不会特别大。\n\n![Alt text](image-6.png)\n\n当前，有得必有失。RR在turnaround time上非常慢。因为job是交替执行的，原本能很快结束的job被迫得隔一段时间就让出CPU。\n通常，我们选择RR的原因是因为我们不知道每个job的run time。选择rr的目的和stcf、sjf一样，都是为了让能够最快完成的进程，有机会最早做到。\n\n\n#### 4.3.5 MLFQ\n> Multi Level Feedback Queue\n\n不同类型的job，要求也不一样\n\n- 交互性的（interactive）program，需要更快的response time\n- 批处理（batch）program，需要更快的turnaround time。\n\nMLFQ 基于多层的RR（Round Robin）实现。\n每层都有更高的优先级，并会抢占低优先级的层数。\n\n##### 4.3.5 决定优先级\n\n两种方式能够用来决定优先级。\n1. History\n> 使用进程过去的behavior来预测未来的behavior\n> 根据此进程过去的 CPU 突发（作业），猜测 CPU 突发（作业）的行为方式\n\n##### 4.3.6 MLFQ Rules \n1. If priority(A) > priority(B), A runs\n2. If priority(A) == priority(B), A and B runs in RR\n3. Process start at the top priority\n4. If job uses the full timeslice, then demote process\n\nMLFQ 的小缺陷\n低优先级的任务可能永远都不会被scheduled。因此，我们需要每隔一段时间就去将所有的job放到最高优先级的队列中。\n\n#### 4.3.6 Lottery Schedudling\n就和它的名字一样。彩票。\n目标： fair share\n* 只关心能否公平地分享CPU\n\n**Fair Scheduler**:: Guarantee that each job obtain a certain percentage of CPU time. Not care about response time or turnaroud time\n实现逻辑也很简单： 给processes 一张彩票，谁中了谁就run。更高的优先级说明拿到了更多的彩票。\n\nTicket: 代表了一个process可以占用多少份额的资源。\n\n比如 Process A拿了75张票，那就占用75%的CPU。 Proess B拿了25张票，那就占用25%的CPU\n然后Scheduler就会在这100张票里去抽，抽中哪一个数字，就执行手里握着那个数字的线程任务。\n\nlottery 算法的实现\n```c\nint counter = 0;\nint winner = getrandom(0, totaltickets);\nnode_t *current = head;\n\nwhile (current) {\n    counter += current->tickets;\n    if (counter > winner)\n        break;\n    current = current->next;\n}\n// current is the winner\n\n```\n\n![Alt text](image.png)\n\n\n#### 4.3.7 Stride Scheduling\n目标同样是为了防止任何线程monopoly CPU。\n\nThe basic idea is assign each process a 'stride', which represents its priority or share of the CPU time. \n\n系统中的每个进程都被分配了一个唯一的步长值。步幅与进程的优先级成反比。优先级较高的进程分配较小的步幅，优先级较低的进程分配较大的步幅。目标是让优先级较高的进程更频繁地访问 CPU。\n\n同样，进程会被放进一个队列。所有进程自身的counter从0开始。每次自己被执行了，就将自身的counter 翻一翻（counter + stride）。 Scheduler会选择具有最小counter的process。\n![Alt text](image-1.png)\n\n* Stride Scheduling同样也存在问题：\n    * 对于新增job，很难确保公平性和优先性。因为每个job，在初始状态下，counter都是0.问题是，当这些线程执行了一段时间后，counter就会变得很大，起码会和0差很多。那么新的job加进来，scheduler必然会判定一直让新job占用cpu，这样就不公平了\n    * 就算不考虑新增。如果你想手动更改process的优先级，又该怎么做呢\n    \n#### 4.3.8 Complete Fair Scheduling\n很显然Stride Scheduling可以确保一定的完整性，但是不能完全确保完全公平\n\n我们的目标是无论线程数量的大小，无论何时添加、更改线程，都能保证其公平地使用资源\n\nComplete Fair Scheduling(CFS) 自从Linux 2.6.23 版本被应用。 O(logN) runtime\n原本是MLFQ\nProcess now ordered by the amount of CPU time they use\n取代了队列，转而使用红黑树\n\n* CFS核心概念\n    * 使用一个counter记录累计执行时间（cummulative execution time）\n    * Schedule process with **least** runtime\n\n下面这些都是gpt对其的介绍\n* 虚拟运行时间：\n    * CFS为每个可运行的进程维护一个“虚拟运行时间”。虚拟运行时间表示一个进程等待执行的时间相对于其他进程。较小的虚拟运行时间值表示更高的优先级。\n\n* 调度决策：\n    * 选择具有最小虚拟运行时间的进程进行执行。这确保了等待时间较长或累积CPU时间较短的进程被优先考虑。\n\n* 时间量子：\n    * CFS不使用固定的时间片或时间量子，而是根据可运行进程的数量和它们的虚拟运行时间动态调整时间量子。\n\n* 动态时间量子计算：\n    * CFS根据进程的权重计算每个进程的时间量子。权重是分配给每个进程的值，表示它在CPU中的份额。较高的权重导致较大的时间量子。\n\n* 权重和Nice值：\n    * 进程根据其优先级被分配权重。用户进程可以使用“nice”值进行优先级调整，该值范围从-20到+19。较低的nice值表示较高的优先级。权重与nice值成反比。\n\n* 平衡机制：\n    * CFS采用平衡机制来维持随时间的公平性。它定期检查运行队列，如果检测到不平衡，则重新分配负载。这有助于确保没有进程在CPU时间上被不公平地耗尽。\n\n* 稳态公平性：\n    * CFS旨在实现稳态公平性，这意味着在更长的时间内，每个进程都能获得其公平份额的CPU时间，而不考虑短期波动。\n\n* 红黑树数据结构：\n    * CFS中的运行队列使用红黑树数据结构实现。这允许根据它们的虚拟运行时间有效地插入和删除进程。\n\n\n![Alt text](image-2.png)\n\n\n## 5. Muti-core Scheduling\n> 由于多核处理器的兴起，多核调度成为必须。因为单单添加CPU的数量不会让一个应用程序执行地更快。我们需要重写应用程序以保证其能**并行**执行\n\n### 5.1 单CPU + 缓存 + main memory\nCPU分出一篇区域给缓存，存放popular data found in main memory. 速度块，容量小\nMain memory存放所有数据，从main memory获取数据的速度会比cache慢很多\n\n### 5.2 多CPU情况\n简单来说，每个CPU都有一个缓存区域。那两个CPU加起来就有两块缓存区域了。\n\n同步不同缓存区域的内存看起来很简单： CPU0 将memory中的 数据放进了自己的缓存区，CPU1会读取CPU0的缓存区，同步数据。\n\n但是，有一种特殊情况：\n    1. CPU 0 读内存放进缓存，CPU1 读到了共享。\n    2. CPU 0 更新了缓存中的数据 同时 CPU 1 被schedule了\n    3. 此时 CPU 1 中保存的还是过去的数据。\n数据就不一致了\n\n\n解决方法很简单： Bus Snooping\n    * 每个cache都会通过观察bus来注意到memory的更新\n    * 当CPU注意到自身memory中的数据更新了，就会注意到这个变化\n\n### 5.3 Cache Affinity\n> 无论是多CPU还是单CPU，Scheduler都会尝试将一个进程放在同一个CPU上执行。因为当CPU在执行该线程时，会往缓存里加很多关于改进程的状态。那么等到改进程下次启动时，就会更快一点，因为缓存里已经有信息了\n\n实现方式：将所有需要scheduled的任务全部放在一个队列里面。每个CPU就从这个**Globally Shared**的队列里面拿job。\n\n坏处： \n    1. 锁 \n    2. 扩展性缺少\n    3. Cache Affinity\n    4. 实现起来复杂\n\n### 5.4 Multi-queue Multiprocessor Scheduling (MQMS)\n* Contains Multiple Scheduling queues\n    * 每条队列都有自己的Scheduling Discipline\n    * 当job进入系统的时候，只会放在一条队列上， 从而避免了信息共享（information sharing）和 同步（synchronization）的问题\n\n\nMQMS with Round Robin\n![Alt text](image-3.png)\n\nMQMS的问题： 需要通过跨内核迁移进程来平衡跨内核的负载\n\n## 6. Virtualizing Memory\n\n目标： \n\n* Transparency\n  * Processes are not aware that memory is shared\n  * Works regardless of number and/or location of processes\n* Protection\n  * Cannot corrupt OS or other processes\n* Privacy\n  * Cannot read data of other processes\n* Efficiency\n  * Do not waste memory resources (minimize fragmentation（碎片化）)\n* Sharing\n  * Cooperating processes can share portions of address space\n\n### 6.1 Abstraction: Address Space\n\n> Address space: Each process has set of addresses that map to bytes\n\n问题是：OS是如何让每个Process觉得，自己有专用的地址空间的？\n\n** 回顾 Addresss Space 中都有什么？ **\n\n1. 静态：\n   * Code\n   * Global Variables\n2. 动态：\n   * Stack\n   * Heap\n\n#### 6.1.1 为什么进程需要动态地分配资源？\n\n> 1. 不知道编译时需要的内存量. 静态分配内存时必须悲观, 为最坏的情况分配足够的资源;不高效地使用存储\n> 2. 对于那些递归的步骤，不知道会嵌套多少次\n> 3. 进程中会有复杂的数据结构，需要我们手动分配资源。\n\n#### 6.1.2 Stack用在哪里？\n\n> 操作系统将Stack用于过程调用帧(procedure call frames), 存放local varibles and parameters\n> 局部变量例子\n\n```c\n#include <stdio.h>\n\nvoid foo(int z);\n\nint main(int argc, char *argv[]) {\n    int A = 0; \n    foo(A);\n    printf(\"A: %d\\n\", A); //A: 0\n}\n\nvoid foo(int z) {\n    int A = 2;\n    z = 5;\n    printf(\"A: %d, Z: %d\\n\", A, z); //A: 2, Z: 5\n}\n```\n\n#### 6.1.3 Heap用在哪里？\n\n> 任何位置的malloc(), new() 都会跑到heap里\n>\n>   * Heap memory consists of allocated area and free area\n>   * Order of Allocation and free is unpredictable.\n\npro：所有数据结构都是这样用的\ncons: \n    * Allocation can be slow\n    * End up with small chunks of free spaces -- Fragmentation(碎片化)\n\n#### 6.1.4 OS在managing heap中的作用\n\n> OS gives big chunk of free memory to process\n> OS provides library manages individual allocations\n\n代码中各个数据结构在address space中的分布\n![Alt text](image-4.png)\n\n","slug":"OSD","published":1,"updated":"2023-11-08T23:11:26.282Z","_id":"cloegqxiw0000mshzbos79vkk","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-为什么要学习OSD？\"><a href=\"#1-为什么要学习OSD？\" class=\"headerlink\" title=\"1. 为什么要学习OSD？\"></a>1. 为什么要学习OSD？</h1><blockquote>\n<p>OS forms the foundation of modern computing</p>\n</blockquote>\n<ol>\n<li><p><strong>Abstractions</strong>: Modern Software 是如何使用 Hardware的？</p>\n</li>\n<li><p><strong>Resource Management</strong>： 如何去做 resource isolation？</p>\n</li>\n<li><p>如何在兼顾<strong>实现以上两点的同时</strong>，确保 <strong>High Performace</strong> ?</p>\n</li>\n</ol>\n<p>在这门课上，主要通过两种方式来学习OS</p>\n<ul>\n<li><ol>\n<li>Conceptual Learning</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Intensive Programming</li>\n</ol>\n</li>\n</ul>\n<p>在笔记的书写中，很多时候并不能很好、贴切的翻译一些英文句子和词汇，所以就直接使用了来自课件、书上的原话。</p>\n<h1 id=\"2-OS-导论\"><a href=\"#2-OS-导论\" class=\"headerlink\" title=\"2. OS 导论\"></a>2. OS 导论</h1><p>OS, 是一个抽象（abstract）和 管理（manage）硬件资源的 <strong>软件</strong><br>从高到低排序： 用户 -&gt; 应用程序 -&gt; 操作系统 -&gt; 硬件</p>\n<p>本章将是这门课内容的导论。section 2以后的章节将对对于各个主题，进行更深层次的讨论和总结。</p>\n<h2 id=\"2-1-硬件\"><a href=\"#2-1-硬件\" class=\"headerlink\" title=\"2.1 硬件\"></a>2.1 硬件</h2><p>OS管理的硬件主要有</p>\n<ol>\n<li>memory： 基本实体都是DRAM,  对应OS中的Memory，使用malloc()作为memory controller, 来分配内存</li>\n<li>Disk：对应OS中的File System, 通过SATA传输，使用read()&#x2F;write() 进行控制</li>\n<li>Nework Adapter: 对应OS中的网络模块， 使用send()&#x2F;recv() 进行传输</li>\n</ol>\n<h2 id=\"2-2-OS提供了什么？\"><a href=\"#2-2-OS提供了什么？\" class=\"headerlink\" title=\"2.2 OS提供了什么？\"></a>2.2 OS提供了什么？</h2><ol>\n<li><p><strong>Software library (abstraction)</strong> between applications and hardware to make the hardware easier to use</p>\n<ul>\n<li>Simple, uniform view of diverse hardware devices</li>\n</ul>\n</li>\n<li><p><strong>Mechanisms and policies for resource management</strong>, to provision and isolate hardware across many applications</p>\n<ul>\n<li>Effective multi-tenant（多租户） and multi-application systems</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-3-Abstrction\"><a href=\"#2-3-Abstrction\" class=\"headerlink\" title=\"2.3 Abstrction\"></a>2.3 Abstrction</h2><h3 id=\"2-3-1-现代操作系统通常为哪些资源提供哪些抽象\"><a href=\"#2-3-1-现代操作系统通常为哪些资源提供哪些抽象\" class=\"headerlink\" title=\"2.3.1 现代操作系统通常为哪些资源提供哪些抽象?\"></a>2.3.1 现代操作系统通常为哪些资源提供哪些抽象?</h3><blockquote>\n<p>CPU：进程&#x2F;线程<br>内存：地址空间<br>存储：文件</p>\n</blockquote>\n<h3 id=\"2-3-2-操作系统提供抽象的好处？\"><a href=\"#2-3-2-操作系统提供抽象的好处？\" class=\"headerlink\" title=\"2.3.2 操作系统提供抽象的好处？\"></a>2.3.2 操作系统提供抽象的好处？</h3><blockquote>\n<p>允许应用程序重用公共资源<br>让不同的设备看起来相同 （内存、主板、硬盘）<br>提供更高级别或更有用的功能</p>\n</blockquote>\n<h3 id=\"2-3-3-挑战\"><a href=\"#2-3-3-挑战\" class=\"headerlink\" title=\"2.3.3 挑战\"></a>2.3.3 挑战</h3><ol>\n<li>What are the correct abstractions?</li>\n<li>How much of the hardware capabilities should be exposed?</li>\n</ol>\n<h2 id=\"2-4-System-Calls\"><a href=\"#2-4-System-Calls\" class=\"headerlink\" title=\"2.4 System Calls\"></a>2.4 System Calls</h2><ul>\n<li>系统调用允许用户告诉操作系统在硬件上执行什么操作</li>\n<li>操作系统提供标准软件接口 （API）</li>\n<li>典型的操作系统会导出几百个系统调用</li>\n<li>运行程序、访问内存、访问硬件设备……</li>\n</ul>\n<h2 id=\"2-5-Resource-Management\"><a href=\"#2-5-Resource-Management\" class=\"headerlink\" title=\"2.5 Resource Management\"></a>2.5 Resource Management</h2><blockquote>\n<p>Want fair and efficient use of hardware across applications</p>\n</blockquote>\n<h3 id=\"2-5-1-Advantages-of-OS-providing-resource-management\"><a href=\"#2-5-1-Advantages-of-OS-providing-resource-management\" class=\"headerlink\" title=\"2.5.1 Advantages of OS providing resource management:\"></a>2.5.1 Advantages of OS providing resource management:</h3><ol>\n<li>Protect applications from one another</li>\n<li>Provide efficient access to resources (cost, time, energy)</li>\n<li>Provide fair access to resources</li>\n</ol>\n<h3 id=\"2-5-2-Challenges\"><a href=\"#2-5-2-Challenges\" class=\"headerlink\" title=\"2.5.2 Challenges\"></a>2.5.2 Challenges</h3><ol>\n<li>What are the correct <strong>mechanisms</strong>?</li>\n<li>What are the correct <strong>policies</strong>?</li>\n</ol>\n<h2 id=\"2-6-Virtualization\"><a href=\"#2-6-Virtualization\" class=\"headerlink\" title=\"2.6 Virtualization\"></a>2.6 Virtualization</h2><blockquote>\n<p>Make each application believe it has each hardware resource to itself<br>这门课主要关注：CPU和Memory</p>\n</blockquote>\n<h3 id=\"2-6-1-Virtualizing-CPU\"><a href=\"#2-6-1-Virtualizing-CPU\" class=\"headerlink\" title=\"2.6.1 Virtualizing CPU\"></a>2.6.1 Virtualizing CPU</h3><ul>\n<li>系统有大量的虚拟CPU： 将一个物理CPU转换为实际上无穷多数量的CPU。允许很多程序同时执行</li>\n<li>可以理解成，当我们在命令行同时执行多个c文件的时候，这时候就可以看成是多个程序同时执行，并实际上使用同一个cpu，但是这些c文件，他们认为自己独占cpu。</li>\n</ul>\n<h3 id=\"2-6-2-Virtualizing-Memory\"><a href=\"#2-6-2-Virtualizing-Memory\" class=\"headerlink\" title=\"2.6.2 Virtualizing Memory\"></a>2.6.2 Virtualizing Memory</h3><ul>\n<li>物理内存其实是一个byte数组</li>\n<li>一个程序将自身所有的数据结构存放在内存中</li>\n<li>读取内存 （load）: <ul>\n<li>指定一个能够访问数据的地址</li>\n</ul>\n</li>\n<li>写入内存 （store）：<ul>\n<li>指定要写入特定地址的数据</li>\n</ul>\n</li>\n</ul>\n<p>虚拟化内存涉及到的一些Mechanism：</p>\n<ol>\n<li>Virtual-to-Physical Memory Mapping</li>\n<li>Page-Fault</li>\n</ol>\n<p>Demo1： 用c分配内存</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[1]) &#123;\n    int a = 0;\n    printf(&quot;%d\\n&quot;, a);//0\n    //aa指针指向a的地址\n    int *aa = &amp;a; \n    //加了*是指针，对应一个数据的地址。那么指针加上指针，就是再次得到值。\n    *aa += 1;\n    printf(&quot;%x\\n&quot;, aa);//a16738d4\n    printf(&quot;%d\\n&quot;, a);//1\n\n    //创建p指针，分配内存。\n    int *p = malloc(sizeof(int));\n    //复制给该片区域\n    *p = 100;\n    printf(&quot;address of p: %x\\n&quot;, p); //fbf156b0\n    printf(&quot;value stored in p: %d\\n&quot;, *p);//100\n    printf(&quot;address of p: %x\\n&quot;, &amp;(*p));//fbf156b0\n&#125;\n</code></pre>\n<p>每个进程都有自己的私有虚拟内存空间（private virtual memory space），OS则会映射这些address space到物理内存中</p>\n<ul>\n<li>对一个正在运行的程序的内存引用，不会影响到其他程序的address space。</li>\n<li>物理内存是一个由OS管理的共享资源</li>\n</ul>\n<h2 id=\"2-7-Concurrency\"><a href=\"#2-7-Concurrency\" class=\"headerlink\" title=\"2.7 Concurrency\"></a>2.7 Concurrency</h2><blockquote>\n<p>Concurrency（并发）： Events are occurring simultaneously and may interact with one another<br>OS必须能够处理并发事件</p>\n</blockquote>\n<p>比较简单的处理方式： 直接隔离他们，阻止他们交互，从而达到Hide Concurrency的效果。<br>但是，这样子指标不治本。因为很多时候有些任务，就是需要进程间交互才能执行的。这时候，才是真正想办法来处理了。<br>常见做法有：</p>\n<ol>\n<li>为进程提供抽象（锁(lock)、信号（semaphores）、条件变量(condition variables)、共享内存(shared memory)、关键部分(critical sections)）</li>\n<li>如果用了锁，则需要确保进程不会死锁</li>\n<li>让交互线程(interaction threads)必须协调对共享数据(shared data)的访问</li>\n</ol>\n<p>多线程Demo：</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n\nvolatile int counter = 0;\nint loop;\nchar *name;\n\nvoid *worker() &#123;\n    for (int i = 0; i &lt; loop; i++) &#123;\n        counter++;\n    &#125;\n&#125;\n\nint main(int argc, char *argv[]) &#123;\n    loop = atoi(argv[1]);\n    pthread_t p1, p2;\n    printf(&quot;initial value: %d\\n&quot;, counter);\n    pthread_create(&amp;p1, NULL, worker, NULL);\n    pthread_create(&amp;p2, NULL, worker, NULL);\n    pthread_join(p1, NULL);\n    pthread_join(p2, NULL);\n    printf(&quot;Final value: %d\\n&quot;, counter); // 20.\n&#125;\n</code></pre>\n<p>可以试着执行之下上面代码。试着改变参数大小。可以发现，如果参数比较小（100~1000），那么最终结果就是参数值*2. 但是，当参数变大后，结果就不对了。</p>\n<pre><code class=\"shell\">./mte 10\ninitial value: 0\nFinal value: 20\n\n./mte 1000\ninitial value: 0\nFinal value: 2000\n\n./mte 10000\ninitial value: 0\nFinal value: 14692\n\n./mte 1000000\ninitial value: 0\nFinal value: 1007083\n</code></pre>\n<p>这是因为并发的情况并没有处理好。p1和p2这两个线程同时执行，并且同时对一个counter进行增加操作。数字小的时候，p1或p2执行的很快，因此并不会出现<strong>p2更新了数字，p1读了旧的数字并将该数字更新到了和p2更新后同样值的情况</strong>。参考数据库的脏读。</p>\n<p>有点抽象，举个例子：</p>\n<pre><code>p2:  读出counter: 10000  然后+ 1 = 10001\np1： 读出counter: 10000  然后+ 1 = 10001;\n</code></pre>\n<p>那这样就等于白操作了。</p>\n<h2 id=\"2-8-Persistence\"><a href=\"#2-8-Persistence\" class=\"headerlink\" title=\"2.8 Persistence\"></a>2.8 Persistence</h2><blockquote>\n<p>Persistence: Access information permanently</p>\n</blockquote>\n<ul>\n<li>信息的寿命比任何一个线程都要长</li>\n<li>机器出现未预期的<strong>重启、断电</strong>。这时候就体现出持久化的重要性了</li>\n</ul>\n<p>持久化需要：</p>\n<ol>\n<li>确保出现unexpected failure的时候，信息能够正确的存储</li>\n<li>提供Abstraction使得进程不知道数据是如何存储的</li>\n<li>因为磁盘IO很慢，我们需要对持久化进行优化</li>\n</ol>\n<h3 id=\"2-8-1-OS-在持久化过程中做了什么？\"><a href=\"#2-8-1-OS-在持久化过程中做了什么？\" class=\"headerlink\" title=\"2.8.1 OS 在持久化过程中做了什么？\"></a>2.8.1 OS 在持久化过程中做了什么？</h3><ol>\n<li>搞清楚新的数据在disk的那一块存放</li>\n<li>向底层（underlying）存储设备（storage device）发出I&#x2F;O 请求</li>\n<li>文件系统（FileSystem）在IO期间处理崩溃</li>\n</ol>\n<h3 id=\"2-8-2-两种持久化策略：\"><a href=\"#2-8-2-两种持久化策略：\" class=\"headerlink\" title=\"2.8.2 两种持久化策略：\"></a>2.8.2 两种持久化策略：</h3><ol>\n<li><p>Journaling</p>\n<ul>\n<li>日志文件系统： 一种文件系统，在将这些更改提交到主文件系统之前，使用日志记录对文件系统的更改</li>\n<li>运行流程：<ul>\n<li>对文件系统的更改首先记录在日志中</li>\n<li>更改成功写入日志后，将其提交到主文件系统</li>\n<li>当系统出现崩溃或故障时，可以通过重放日志来恢复文件系统。日志中记录的任何不完整或不一致的操作都可以完成或撤消，以维护文件系统的完整性。</li>\n<li>崩溃后恢复速度更快</li>\n<li>数据完整性得到保证</li>\n</ul>\n</li>\n<li>例子： ext3、ext4</li>\n</ul>\n</li>\n<li><p>Copy on write</p>\n<ul>\n<li>写入时不直接对原位置的数据进行修改，而是写入新的位置</li>\n<li>原数据将一直保存，直到写入完成</li>\n<li>运行流程：<ol>\n<li>当需要读取数据时，首先从当前位置读取数据</li>\n<li>在新位置制作数据的副本</li>\n<li>对副本进行修改</li>\n<li>最后将只想原数据的指针更新指向新数据的副本</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>简化了崩溃后的恢复。因为在修改完成前的原始数据不会受到影响</li>\n<li>提供了任何给定时间点的一致数据快照</li>\n</ol>\n</li>\n<li>例子： 一些现代化的文件系统，如ZFS、Btrfs</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-CPU-Virtualization\"><a href=\"#3-CPU-Virtualization\" class=\"headerlink\" title=\"3 CPU Virtualization\"></a>3 CPU Virtualization</h2><blockquote>\n<p>从本章开始，我们正式开始讨论虚拟化的第一个主题： CPU 虚拟化<br>本章会解决以下问题：</p>\n<ol>\n<li>What is a process?</li>\n<li>Why is <strong>limited direct execution</strong> a good approach for virtualizing the CPU? </li>\n<li>What execution state must be saved for a process? </li>\n<li>What 3 modes could a process in?</li>\n</ol>\n</blockquote>\n<h3 id=\"3-1-What-is-process\"><a href=\"#3-1-What-is-process\" class=\"headerlink\" title=\"3.1 What is process?\"></a>3.1 What is process?</h3><blockquote>\n<p>Process: An <strong>execution stream</strong>（执行流） in the context（上下文） of a <strong>process state</strong></p>\n</blockquote>\n<p><strong>execution stream</strong><br>    * A stream of executing instructions<br>    * Running piece of code<br>    * Thread of control (其实和execution stream一个意思。单线程的话就是执行流嘛。然后多线程的话，每个线程都有自己的执行流。)</p>\n<p>执行流指的是计算机程序正在执行的指令的顺序流。代表着一段指令是活动的。</p>\n<ul>\n<li>说人话，就是正在跑的程序，这个程序得是活的，而不是在磁盘上的静态文件。在跑的过程中，CPU会直接处理这些指令序列</li>\n</ul>\n<p>补充一下： CPU全名<strong>central processing unit</strong>。别学了半天OS，CPU到底是个啥都不知道。。</p>\n<p><strong>process state</strong><br>    * Everything that the running code can affect or affected by<br>    * Register<br>        * Heap, General Purpose, floating point, stack pointer, program counter<br>    * Memory Spaces<br>    * 例子： Open files</p>\n<ul>\n<li>process is not program!<ul>\n<li>program是静态的代码和数据</li>\n<li>process是动态的代码和数据</li>\n<li>可以有多个process运行同一个program</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-Process-Management-Segments\"><a href=\"#3-2-Process-Management-Segments\" class=\"headerlink\" title=\"3.2 Process Management Segments\"></a>3.2 Process Management Segments</h3><ul>\n<li>OS 会为每个进程分配memory。</li>\n<li>这个memory，包含了很多的块(segment)<ul>\n<li>从上到下来看</li>\n<li>最高层是 stack，用于存储局部变量。也包括command line arguments（位于顶部）， 以及环境变量</li>\n<li>再往下走是Heap。用于动态的memory。 在stack和heap之间，有一块unused segment，用于stack&#x2F;heap的扩容</li>\n<li>.bss Global Uniniialized Variables（全局未初始化变量）</li>\n<li>.data Global Initialized Variables（全局已初始化变量）</li>\n<li>最底层才是code。Read-Only</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3-Process-vs-Thread\"><a href=\"#3-3-Process-vs-Thread\" class=\"headerlink\" title=\"3.3 Process vs. Thread\"></a>3.3 Process vs. Thread</h3><p>很明显，进程肯定不是线程</p>\n<p>但是他们还是有相似之处的，我们可以把线程看作一个<strong>轻量版</strong> 的process（Light weight Process LWP）。</p>\n<p>Thread is a execution stream that <strong>shares an address space</strong><br>一个进程里存在多个线程</p>\n<p>举个共享内存空间的例子。<br>对于进程来说，两个相同程序的不同进程，当他们都在access同一个地址值的时候，他们得到的结果不一样 （内存虚拟化）<br>而对于线程，一个进程内的多个线程，当他们都在access同一个地址值的时候，他们得到的结果是一样的</p>\n<p>对于进程，我们的目标是： <strong>让每个进程都感觉，自己是独占cpu的。</strong></p>\n<h3 id=\"3-4-Resources-Sharing\"><a href=\"#3-4-Resources-Sharing\" class=\"headerlink\" title=\"3.4 Resources Sharing\"></a>3.4 Resources Sharing</h3><p>了解了目标后，我们先看一下OS是怎么分配资源(resources)的</p>\n<p>首先， 资源分配通分为两种：<br>    1. time sharing<br>    2. space sharing</p>\n<blockquote>\n<p>time sharing 主要针对的是<strong>单CPU</strong>的情况。 使多个用户或进程能够共享单个处理器。<br>具体做法是：将可用的处理时间划分为多个小的时间间隔（timeslice），并且将这些时间片分配给各个用户&#x2F;进程。从而打到各个用户&#x2F;进程公平分配资源的效果，并且在他们各自分配的时间片内，能够独享cpu</p>\n</blockquote>\n<ul>\n<li>关si键词： 公平、快速切换（illusion of multaneous execution）</li>\n</ul>\n<blockquote>\n<p>space sharing 关注的是<strong>空间</strong>上的共享&#x2F;复用。每一个进程都被分配CPU容量的一小部分。</p>\n</blockquote>\n<ul>\n<li>关键词：并行（Parallel）执行， 同时执行（real simultanous execution）， 资源隔离（resource isolation）</li>\n</ul>\n<p>在共享时，我们主要注意两点：</p>\n<ol>\n<li>cannot perform restricted operation</li>\n<li>should not run forever or make the entire system slow &#x3D;&gt; performance</li>\n</ol>\n<p>###3.5 Provide Good CPU Performance</p>\n<ol>\n<li>Direct Execution<ul>\n<li>直接让用户操作硬件： CPU只负责创建并初始化进程，之后的控制权就回到起点（比如main()），交给用户手中了。</li>\n</ul>\n</li>\n</ol>\n<p>这样子用户进程的权限就过大了。因此Direct Execution肯定是有问题的：</p>\n<ol>\n<li><p>进程（Process）可以做一些受限（restricted）的事情</p>\n<ul>\n<li>比如读取&#x2F;写入别的进程的数据</li>\n</ul>\n</li>\n<li><p>进程可以永久执行（缓慢，有漏洞，恶意（malicious））</p>\n<ul>\n<li>OS 需要在进程之间交换(swap)的能力</li>\n</ul>\n</li>\n<li><p>OS很多操作很慢： 比如I&#x2F;O  还是进程切换能力</p>\n</li>\n</ol>\n<p>根据以上问题，我们可以给出一个折中的解决方案: 让OS和Hardware保留一些控制权。</p>\n<h3 id=\"3-5-1-Restricted-Ops\"><a href=\"#3-5-1-Restricted-Ops\" class=\"headerlink\" title=\"3.5.1 Restricted Ops\"></a>3.5.1 Restricted Ops</h3><p>Q1: 我们如何确保用户进程不会单方面（unilaterally）执行受限(restricted)的操作呢?</p>\n<p>解决方法： （权限级别&#x2F;分离）privilege levels&#x2F;separation</p>\n<ul>\n<li><p>如果想要直接和设备进行交互， 那就用kernal mode，这样就不受限制了。</p>\n</li>\n<li><p>对于用户进程，就在user mode下执行。如果试图和设备进行直接交互，就会进陷阱（trap），然后software interrupt</p>\n</li>\n<li><p>如果用户进程想和设备进行交互的话，可以通过以下方式：</p>\n<ol>\n<li>System Calls (由OS实现的方法)</li>\n<li>Change Privilege Level（权限级别）through system call（trap）</li>\n</ol>\n</li>\n</ul>\n<p>System call demo: 1 direct system call &amp; 1 system call provided by libc function.</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main(int argc, char *argv[]) &#123;\n    long ID1, ID2;\n    ID1 = syscall(SYS_getpid);\n    printf(&quot;direct system call, pid = %ld\\n&quot;, ID1);//direct system call, pid = 3565265\n    ID2 = getpid();\n    printf(&quot;libc wrapped system call, pid = %ld\\n&quot;, ID2);//libc wrapped system call, pid = 3565265\n&#125;\n</code></pre>\n<h3 id=\"3-6-System-Call-Table-and-Trap-Table\"><a href=\"#3-6-System-Call-Table-and-Trap-Table\" class=\"headerlink\" title=\"3.6 System Call Table and Trap Table\"></a>3.6 System Call Table and Trap Table</h3><blockquote>\n<p>前面讲到过，系统调用表和陷阱表之间存在映射。用于管理用户引发的系统事件。<br>主要得知道怎么通过汇编，对系统调用表和陷阱表进行分析，从而得出系统时间的结果。</p>\n</blockquote>\n<p>CPU使用EAX寄存器（register）的内容作为源操作数。<br>窍门就是看$后面的数字内容，找系统调用表和陷阱表上数字对应的操作就行。</p>\n<p>比如这道题：</p>\n<pre><code>\nSuppose the trap table on a machine looks like the following:\n\n1 - illegal; call OS process kill routine\n\n2- run OS system call routine\n\nSuppose the OS&#39;s system call table looks like the following.\n\n1 - sys_read()\n\n2 - sys_write()\n\nWhat happens when an application performs the following instructions?\n\nmovl $1, %eax\n\nint $1\n</code></pre>\n<p>前面的1是system call表里的，后面的int $1是trap表里的。所以结果就是kill runtime.<br>movl -&gt; 放进eax， int -&gt; 产生软件中断。</p>\n<p>总结一下，user processes 是不被允许直接 perform：</p>\n<ol>\n<li>arbitrary memory access</li>\n<li>Disk I&#x2F;O</li>\n<li>Special x86 instructions like lidt. (Inteterrupted Discription Table)</li>\n</ol>\n<p>如果user processes做了上面的事情，那么大概率就是进了trap，然后kill routine。</p>\n<h3 id=\"3-7-How-to-take-CPU-away\"><a href=\"#3-7-How-to-take-CPU-away\" class=\"headerlink\" title=\"3.7 How to take CPU away?\"></a>3.7 How to take CPU away?</h3><blockquote>\n<p>OS 需要实现多任务处理（multitasking）。先记住一个词<strong>上下文切换</strong>。后面会重点围绕这个概念来讲</p>\n</blockquote>\n<ul>\n<li>Mechanism： To switch between classes</li>\n<li>Policy: To decide which process to run at what time.</li>\n</ul>\n<p><strong>Mechaism 和 Policy的区别？</strong></p>\n<blockquote>\n<p>Policy: Decision-maker to optimize some workload performance metric<br>    * Which Process to run? When to run? &#x3D;&gt; scheduler<br>Mechanism: Low-level code that implements the decision<br>    * How ? &#x3D;&gt; Dispatcher</p>\n</blockquote>\n<p>在这里，我们先将Dispatcher</p>\n<p>Dispatch 的逻辑很简单</p>\n<pre><code class=\"c\">while (1) &#123;\n    run process A for some time slice\n    stop process A and save its time\n    load context of another process\n&#125;\n</code></pre>\n<p>问题是：<br>    1. dispatcher怎么在一段时间后，重新获得控制？<br>    2. 哪些execution context必须被保存并恢复？</p>\n<h4 id=\"3-7-1-Q1-dispatcher怎么在一段时间后，重新获得控制？\"><a href=\"#3-7-1-Q1-dispatcher怎么在一段时间后，重新获得控制？\" class=\"headerlink\" title=\"3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？\"></a>3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？</h4><blockquote>\n<p>Option 1 : Cooperative Muti-tasking<br>通过trap，将CPU移交给操作系统的信任线程<br>    * 例如： System Call， page fault（想要换取的page不在main memory里）或者 error<br>    * yield()<br>但是，这样子的话也有问题。设想一个process，它没有任何越过自身权限的操作（I&#x2F;O）， 也没有进任何的Trap，也没有自己叫yield(),那么最终，这个process就会一直占着整个机器。唯一办法只有重启。</p>\n</blockquote>\n<p>这时候就有了第二种选项</p>\n<blockquote>\n<p>Option 2: Regain control without cooperation<br>我们可以启用周期性的，时钟。进入OS的时候，我们启动时钟，，时钟时间到后，硬件会生成timer interrupt<br>用户也不能屏蔽掉timer interrupt，因为他们没有权限这样子做。</p>\n</blockquote>\n<h4 id=\"3-7-2-Context-save在哪里？\"><a href=\"#3-7-2-Context-save在哪里？\" class=\"headerlink\" title=\"3.7.2 Context save在哪里？\"></a>3.7.2 Context save在哪里？</h4><blockquote>\n<p>process control block (PCB) 也可以叫做 process descriptor (PD)<br>每个进程都会有PCB</p>\n</blockquote>\n<h3 id=\"3-7-2-1-PCB-存储了哪些信息\"><a href=\"#3-7-2-1-PCB-存储了哪些信息\" class=\"headerlink\" title=\"3.7.2.1 PCB 存储了哪些信息\"></a>3.7.2.1 PCB 存储了哪些信息</h3><ol>\n<li>PID</li>\n<li>Process state (I.e., running, ready, or blocked)</li>\n<li>Execution state (all registers, PC, stack pointer) – Context</li>\n<li>Scheduling priority</li>\n<li>Accounting information (parent and child processes)</li>\n<li>Credentials (which resources can be accessed, owner)</li>\n<li>Pointers to other allocated resources (e.g., open files)</li>\n</ol>\n<h3 id=\"3-7-2-2-Context-保存-切换流程\"><a href=\"#3-7-2-2-Context-保存-切换流程\" class=\"headerlink\" title=\"3.7.2.2. Context 保存&#x2F;切换流程\"></a>3.7.2.2. Context 保存&#x2F;切换流程</h3><ol>\n<li>进程A从user mode 转换到 kernal mode，权限提升。OS决定从A转到B</li>\n<li>在kernal stack上保存A的上下文（PC， registers， kernal stack pointer）</li>\n<li>将stack pointer指向进程B的kernal stack</li>\n<li>从B的kernal stack中恢复上下文</li>\n</ol>\n<pre><code class=\"c\">struct context &#123;\n    int eip;\t// Index pointer register\n    int esp;\t// Stack pointer register\n    int ebx;\t// Called the base register\n    int ecx;\t// Called the counter register\n    int edx;\t// Called the data register\n    int esi;\t// Source index register\n    int edi;\t// Destination index register\n    int ebp;\t// Stack base pointer register\n&#125;;\n</code></pre>\n<p>一些进程在执行不需要Cpu的任务的时候，OS会switch到哪些需要CPU的进程<br>为了完成这个功能，OS必须关注进程的状态</p>\n<pre><code class=\"c\">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING,\n                  RUNNABLE, RUNNING, ZOMBIE &#125;;\n</code></pre>\n<p>Running: 占用cpu<br>Ready： 等待CPU<br>Blocked：正在等待同步或者I&#x2F;O.</p>\n<h2 id=\"4-Scheduling\"><a href=\"#4-Scheduling\" class=\"headerlink\" title=\"4. Scheduling\"></a>4. Scheduling</h2><h3 id=\"4-1-两种创建Process的方式\"><a href=\"#4-1-两种创建Process的方式\" class=\"headerlink\" title=\"4.1 两种创建Process的方式\"></a>4.1 两种创建Process的方式</h3><ol>\n<li>New process from sratch (从0构建)</li>\n</ol>\n<ul>\n<li>步骤<ul>\n<li>从memory中加载指定代码和数据；并创建空的call stack</li>\n<li>create and initialzie pcb</li>\n<li>put process on ready list.</li>\n</ul>\n</li>\n</ul>\n<p>好处：定制化，no waste work<br>坏处： 很难涵盖所有可能的options for setup. 比如WindowesNT有10个参数，这咋搞。</p>\n<ol start=\"2\">\n<li>第二个方式： Clone an existing project and change it.<br>Fork(): 克隆调用者<ul>\n<li>停止目前的进程，保存他的状态</li>\n<li>复制代码的stack，code ,data, pcb</li>\n<li>将PCB放进ready list<br>Exec (char *file): exec覆盖调用进程</li>\n<li>替换掉目前的代码和数据</li>\n</ul>\n</li>\n</ol>\n<p>demo: Base shell program</p>\n<pre><code class=\"c\">while (1) &#123;\n    Char *cmd = getcmd();\n    Int retval = fork();\n    If (retval == 0) &#123;\n        // This is the child process\n        // Setup the child’s process environment here\n        // E.g., where is standard I/O, how to handle signals?\n        exec(cmd);\n        // exec does not return if it succeeds\n        printf(“ERROR: Could not execute %s\\n”, cmd);\n        exit(1);\n    &#125; else &#123;\n        // This is the parent process; Wait for child to finish\n        int pid = retval;\n        wait(pid);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-2-Dispatcher-和-Scheduling-区别\"><a href=\"#4-2-Dispatcher-和-Scheduling-区别\" class=\"headerlink\" title=\"4.2 Dispatcher 和 Scheduling 区别\"></a>4.2 Dispatcher 和 Scheduling 区别</h3><blockquote>\n<p>Dispatcher是一个low level 的mechanism 而 Scheduling是policy</p>\n</blockquote>\n<p>Scheduling: Policy to determine which process gets CPU when</p>\n<p>重点： How to transition?\t(“mechanism”)<br>      When to transition?\t(“policy”)  </p>\n<p>一个用于理解的例子：文件IO   Process alternates between CPU and I&#x2F;O process moves between ready and blocked queues</p>\n<p>一些术语<br>Workload: set of <strong>job</strong> descriptions (arrival time, run_time)<br>    * Job: View as current CPU burst of a process</p>\n<p>Metric: measurement of quality of schedule<br>    * Minimize turnaround time<br>         Do not want to wait long for job to complete<br>         Completion_time – arrival_time （process&#x2F;thread complete - process&#x2F;thread add to runqueue）<br>    * Minimize response time<br>        * Schedule interactive jobs promptly so users see output quickly<br>        * Initial_schedule_time – arrival_time （process&#x2F;thread add to runqueue - process&#x2F;thread scheduled）<br>    * Maximize throughput<br>        * Want many jobs to complete per unit of time<br>    * Maximize resource utilization<br>        * Keep expensive devices busy<br>    Minimize overhead<br>        * Reduce number of context switches<br>    Maximize fairness<br>        * All jobs get same amount of CPU over some time interval</p>\n<h3 id=\"4-3-一些-Scheduler\"><a href=\"#4-3-一些-Scheduler\" class=\"headerlink\" title=\"4.3 一些 Scheduler\"></a>4.3 一些 Scheduler</h3><blockquote>\n<p>在考虑Workload的情况下，我们需要考虑这些是否达成</p>\n<ol>\n<li>Each job runs for the same amount of time</li>\n<li>All jobs <strong>arrive at the same time</strong></li>\n<li>All jobs only use the CPU (no I&#x2F;O)</li>\n<li>Run-time of each job is known</li>\n</ol>\n</blockquote>\n<h4 id=\"4-3-1-FIFO\"><a href=\"#4-3-1-FIFO\" class=\"headerlink\" title=\"4.3.1 FIFO\"></a>4.3.1 FIFO</h4><p>FIFO: First In, First Out\t<br>    - also called FCFS (first come first served)<br>     - 根据arrive time来干活<br>    - ABC同时到，先干A，A好了的同时马上干B<br>    - turn_around &#x3D; completion_time - arrival_time</p>\n<p>计算题： 算一下avg_turn_around_time:<br>    <img src=\"/image.png\" alt=\"Alt text\"></p>\n<p>显然FIFO是不满足第一条的， 每个Job跑的时间都不一样。从而导致，metric中的turnaround会很高</p>\n<p><img src=\"/image-1.png\" alt=\"Alt text\"><br>如果第一个来的job非常的time-consuming，那么就会导致，后面那些原本能够很快就完成的job，被堵着（阻塞）。</p>\n<p>这里的平均turnout_time就达到了 (60 + 70 + 80) &#x2F; 3 &#x3D; 70s 而原本有的任务只需要10s就可以完成。</p>\n<p>根据FIFO的缺点，我们就可以设计出第二种似乎更好的Scheduler。 Shortest Job First（SJF）</p>\n<h4 id=\"4-3-2-SJF\"><a href=\"#4-3-2-SJF\" class=\"headerlink\" title=\"4.3.2 SJF\"></a>4.3.2 SJF</h4><blockquote>\n<p>选择run_time最小的job</p>\n</blockquote>\n<p>计算1： 对于这个例子，平均turnout time是多少呢</p>\n<p><img src=\"/image-2.png\" alt=\"Alt text\"><br>(10 + 20 + 80) &#x2F; 3 &#x3D; 36.7</p>\n<p>计算2： 对于这个例子，平均turnout time是多少呢<br><img src=\"/image-3.png\" alt=\"Alt text\"><br>turn_around &#x3D; completion_time - arrival_time<br>记住这个公式，就很好算了。</p>\n<p>可以看出，FIFO和SJF都是非抢占式（non-preemptive）的。只有当任务执行完毕，或者优先级不够的情况下，才会让出CPU。</p>\n<p>抢占式（preemptive）的CPU则相反。就算你的job已经在执行了，万一来了个比你正在执行的job更牛的job，则会schedule更牛的job，你正在运行的job失去了CPU，在旁边等着</p>\n<h4 id=\"4-3-3-STCF\"><a href=\"#4-3-3-STCF\" class=\"headerlink\" title=\"4.3.3 STCF\"></a>4.3.3 STCF</h4><blockquote>\n<p>Shortest time-to-completion First<br>永远执行会完成最快的任务。</p>\n</blockquote>\n<p>计算：平均turnaround time<br><img src=\"/image-4.png\" alt=\"Alt text\"><br>(80 - 0) + (20 - 10) + (30 - 10) &#x3D; 80 + 10 +  20 &#x3D; 110<br>110&#x2F;3 &#x3D; 36.6s<br>很明显在这种情况下，抢占式的turnout time会比非抢占式的快很多</p>\n<h5 id=\"4-3-3-1-Response-Time\"><a href=\"#4-3-3-1-Response-Time\" class=\"headerlink\" title=\"4.3.3.1 Response Time\"></a>4.3.3.1 Response Time</h5><blockquote>\n<p>有时候，从<strong>任务到达</strong>到<strong>任务开始</strong>的这段时间也很重要。我们将这段时间称为：Response Time<br>response_time &#x3D; first_run_time - arrival_time</p>\n</blockquote>\n<p><img src=\"/image-5.png\" alt=\"Alt text\"><br>job b在10s的时候到。<br>turnaround time &#x3D; 30 - 10 &#x3D; 20s<br>response time &#x3D; 20 - 10 &#x3D; 10s</p>\n<h4 id=\"4-3-4-RR\"><a href=\"#4-3-4-RR\" class=\"headerlink\" title=\"4.3.4 RR\"></a>4.3.4 RR</h4><blockquote>\n<p>Round Robin<br>在response time方面比STCF、SJF、FIFO做的都好<br>因为它会每一段时间就会交替状态为Ready的进程，从而每个job第一次开始run的时间不会差距不会特别大。</p>\n</blockquote>\n<p><img src=\"/image-6.png\" alt=\"Alt text\"></p>\n<p>当前，有得必有失。RR在turnaround time上非常慢。因为job是交替执行的，原本能很快结束的job被迫得隔一段时间就让出CPU。<br>通常，我们选择RR的原因是因为我们不知道每个job的run time。选择rr的目的和stcf、sjf一样，都是为了让能够最快完成的进程，有机会最早做到。</p>\n<h4 id=\"4-3-5-MLFQ\"><a href=\"#4-3-5-MLFQ\" class=\"headerlink\" title=\"4.3.5 MLFQ\"></a>4.3.5 MLFQ</h4><blockquote>\n<p>Multi Level Feedback Queue</p>\n</blockquote>\n<p>不同类型的job，要求也不一样</p>\n<ul>\n<li>交互性的（interactive）program，需要更快的response time</li>\n<li>批处理（batch）program，需要更快的turnaround time。</li>\n</ul>\n<p>MLFQ 基于多层的RR（Round Robin）实现。<br>每层都有更高的优先级，并会抢占低优先级的层数。</p>\n<h5 id=\"4-3-5-决定优先级\"><a href=\"#4-3-5-决定优先级\" class=\"headerlink\" title=\"4.3.5 决定优先级\"></a>4.3.5 决定优先级</h5><p>两种方式能够用来决定优先级。</p>\n<ol>\n<li>History<blockquote>\n<p>使用进程过去的behavior来预测未来的behavior<br>根据此进程过去的 CPU 突发（作业），猜测 CPU 突发（作业）的行为方式</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"4-3-6-MLFQ-Rules\"><a href=\"#4-3-6-MLFQ-Rules\" class=\"headerlink\" title=\"4.3.6 MLFQ Rules\"></a>4.3.6 MLFQ Rules</h5><ol>\n<li>If priority(A) &gt; priority(B), A runs</li>\n<li>If priority(A) &#x3D;&#x3D; priority(B), A and B runs in RR</li>\n<li>Process start at the top priority</li>\n<li>If job uses the full timeslice, then demote process</li>\n</ol>\n<p>MLFQ 的小缺陷<br>低优先级的任务可能永远都不会被scheduled。因此，我们需要每隔一段时间就去将所有的job放到最高优先级的队列中。</p>\n<h4 id=\"4-3-6-Lottery-Schedudling\"><a href=\"#4-3-6-Lottery-Schedudling\" class=\"headerlink\" title=\"4.3.6 Lottery Schedudling\"></a>4.3.6 Lottery Schedudling</h4><p>就和它的名字一样。彩票。<br>目标： fair share</p>\n<ul>\n<li>只关心能否公平地分享CPU</li>\n</ul>\n<p><strong>Fair Scheduler</strong>:: Guarantee that each job obtain a certain percentage of CPU time. Not care about response time or turnaroud time<br>实现逻辑也很简单： 给processes 一张彩票，谁中了谁就run。更高的优先级说明拿到了更多的彩票。</p>\n<p>Ticket: 代表了一个process可以占用多少份额的资源。</p>\n<p>比如 Process A拿了75张票，那就占用75%的CPU。 Proess B拿了25张票，那就占用25%的CPU<br>然后Scheduler就会在这100张票里去抽，抽中哪一个数字，就执行手里握着那个数字的线程任务。</p>\n<p>lottery 算法的实现</p>\n<pre><code class=\"c\">int counter = 0;\nint winner = getrandom(0, totaltickets);\nnode_t *current = head;\n\nwhile (current) &#123;\n    counter += current-&gt;tickets;\n    if (counter &gt; winner)\n        break;\n    current = current-&gt;next;\n&#125;\n// current is the winner\n</code></pre>\n<p><img src=\"/image.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-7-Stride-Scheduling\"><a href=\"#4-3-7-Stride-Scheduling\" class=\"headerlink\" title=\"4.3.7 Stride Scheduling\"></a>4.3.7 Stride Scheduling</h4><p>目标同样是为了防止任何线程monopoly CPU。</p>\n<p>The basic idea is assign each process a ‘stride’, which represents its priority or share of the CPU time. </p>\n<p>系统中的每个进程都被分配了一个唯一的步长值。步幅与进程的优先级成反比。优先级较高的进程分配较小的步幅，优先级较低的进程分配较大的步幅。目标是让优先级较高的进程更频繁地访问 CPU。</p>\n<p>同样，进程会被放进一个队列。所有进程自身的counter从0开始。每次自己被执行了，就将自身的counter 翻一翻（counter + stride）。 Scheduler会选择具有最小counter的process。<br><img src=\"/image-1.png\" alt=\"Alt text\"></p>\n<ul>\n<li>Stride Scheduling同样也存在问题：<ul>\n<li>对于新增job，很难确保公平性和优先性。因为每个job，在初始状态下，counter都是0.问题是，当这些线程执行了一段时间后，counter就会变得很大，起码会和0差很多。那么新的job加进来，scheduler必然会判定一直让新job占用cpu，这样就不公平了</li>\n<li>就算不考虑新增。如果你想手动更改process的优先级，又该怎么做呢</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-3-8-Complete-Fair-Scheduling\"><a href=\"#4-3-8-Complete-Fair-Scheduling\" class=\"headerlink\" title=\"4.3.8 Complete Fair Scheduling\"></a>4.3.8 Complete Fair Scheduling</h4><p>很显然Stride Scheduling可以确保一定的完整性，但是不能完全确保完全公平</p>\n<p>我们的目标是无论线程数量的大小，无论何时添加、更改线程，都能保证其公平地使用资源</p>\n<p>Complete Fair Scheduling(CFS) 自从Linux 2.6.23 版本被应用。 O(logN) runtime<br>原本是MLFQ<br>Process now ordered by the amount of CPU time they use<br>取代了队列，转而使用红黑树</p>\n<ul>\n<li>CFS核心概念<ul>\n<li>使用一个counter记录累计执行时间（cummulative execution time）</li>\n<li>Schedule process with <strong>least</strong> runtime</li>\n</ul>\n</li>\n</ul>\n<p>下面这些都是gpt对其的介绍</p>\n<ul>\n<li><p>虚拟运行时间：</p>\n<ul>\n<li>CFS为每个可运行的进程维护一个“虚拟运行时间”。虚拟运行时间表示一个进程等待执行的时间相对于其他进程。较小的虚拟运行时间值表示更高的优先级。</li>\n</ul>\n</li>\n<li><p>调度决策：</p>\n<ul>\n<li>选择具有最小虚拟运行时间的进程进行执行。这确保了等待时间较长或累积CPU时间较短的进程被优先考虑。</li>\n</ul>\n</li>\n<li><p>时间量子：</p>\n<ul>\n<li>CFS不使用固定的时间片或时间量子，而是根据可运行进程的数量和它们的虚拟运行时间动态调整时间量子。</li>\n</ul>\n</li>\n<li><p>动态时间量子计算：</p>\n<ul>\n<li>CFS根据进程的权重计算每个进程的时间量子。权重是分配给每个进程的值，表示它在CPU中的份额。较高的权重导致较大的时间量子。</li>\n</ul>\n</li>\n<li><p>权重和Nice值：</p>\n<ul>\n<li>进程根据其优先级被分配权重。用户进程可以使用“nice”值进行优先级调整，该值范围从-20到+19。较低的nice值表示较高的优先级。权重与nice值成反比。</li>\n</ul>\n</li>\n<li><p>平衡机制：</p>\n<ul>\n<li>CFS采用平衡机制来维持随时间的公平性。它定期检查运行队列，如果检测到不平衡，则重新分配负载。这有助于确保没有进程在CPU时间上被不公平地耗尽。</li>\n</ul>\n</li>\n<li><p>稳态公平性：</p>\n<ul>\n<li>CFS旨在实现稳态公平性，这意味着在更长的时间内，每个进程都能获得其公平份额的CPU时间，而不考虑短期波动。</li>\n</ul>\n</li>\n<li><p>红黑树数据结构：</p>\n<ul>\n<li>CFS中的运行队列使用红黑树数据结构实现。这允许根据它们的虚拟运行时间有效地插入和删除进程。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/image-2.png\" alt=\"Alt text\"></p>\n<h2 id=\"5-Muti-core-Scheduling\"><a href=\"#5-Muti-core-Scheduling\" class=\"headerlink\" title=\"5. Muti-core Scheduling\"></a>5. Muti-core Scheduling</h2><blockquote>\n<p>由于多核处理器的兴起，多核调度成为必须。因为单单添加CPU的数量不会让一个应用程序执行地更快。我们需要重写应用程序以保证其能<strong>并行</strong>执行</p>\n</blockquote>\n<h3 id=\"5-1-单CPU-缓存-main-memory\"><a href=\"#5-1-单CPU-缓存-main-memory\" class=\"headerlink\" title=\"5.1 单CPU + 缓存 + main memory\"></a>5.1 单CPU + 缓存 + main memory</h3><p>CPU分出一篇区域给缓存，存放popular data found in main memory. 速度块，容量小<br>Main memory存放所有数据，从main memory获取数据的速度会比cache慢很多</p>\n<h3 id=\"5-2-多CPU情况\"><a href=\"#5-2-多CPU情况\" class=\"headerlink\" title=\"5.2 多CPU情况\"></a>5.2 多CPU情况</h3><p>简单来说，每个CPU都有一个缓存区域。那两个CPU加起来就有两块缓存区域了。</p>\n<p>同步不同缓存区域的内存看起来很简单： CPU0 将memory中的 数据放进了自己的缓存区，CPU1会读取CPU0的缓存区，同步数据。</p>\n<p>但是，有一种特殊情况：<br>    1. CPU 0 读内存放进缓存，CPU1 读到了共享。<br>    2. CPU 0 更新了缓存中的数据 同时 CPU 1 被schedule了<br>    3. 此时 CPU 1 中保存的还是过去的数据。<br>数据就不一致了</p>\n<p>解决方法很简单： Bus Snooping<br>    * 每个cache都会通过观察bus来注意到memory的更新<br>    * 当CPU注意到自身memory中的数据更新了，就会注意到这个变化</p>\n<h3 id=\"5-3-Cache-Affinity\"><a href=\"#5-3-Cache-Affinity\" class=\"headerlink\" title=\"5.3 Cache Affinity\"></a>5.3 Cache Affinity</h3><blockquote>\n<p>无论是多CPU还是单CPU，Scheduler都会尝试将一个进程放在同一个CPU上执行。因为当CPU在执行该线程时，会往缓存里加很多关于改进程的状态。那么等到改进程下次启动时，就会更快一点，因为缓存里已经有信息了</p>\n</blockquote>\n<p>实现方式：将所有需要scheduled的任务全部放在一个队列里面。每个CPU就从这个<strong>Globally Shared</strong>的队列里面拿job。</p>\n<p>坏处：<br>    1. 锁<br>    2. 扩展性缺少<br>    3. Cache Affinity<br>    4. 实现起来复杂</p>\n<h3 id=\"5-4-Multi-queue-Multiprocessor-Scheduling-MQMS\"><a href=\"#5-4-Multi-queue-Multiprocessor-Scheduling-MQMS\" class=\"headerlink\" title=\"5.4 Multi-queue Multiprocessor Scheduling (MQMS)\"></a>5.4 Multi-queue Multiprocessor Scheduling (MQMS)</h3><ul>\n<li>Contains Multiple Scheduling queues<ul>\n<li>每条队列都有自己的Scheduling Discipline</li>\n<li>当job进入系统的时候，只会放在一条队列上， 从而避免了信息共享（information sharing）和 同步（synchronization）的问题</li>\n</ul>\n</li>\n</ul>\n<p>MQMS with Round Robin<br><img src=\"/image-3.png\" alt=\"Alt text\"></p>\n<p>MQMS的问题： 需要通过跨内核迁移进程来平衡跨内核的负载</p>\n<h2 id=\"6-Virtualizing-Memory\"><a href=\"#6-Virtualizing-Memory\" class=\"headerlink\" title=\"6. Virtualizing Memory\"></a>6. Virtualizing Memory</h2><p>目标： </p>\n<ul>\n<li>Transparency<ul>\n<li>Processes are not aware that memory is shared</li>\n<li>Works regardless of number and&#x2F;or location of processes</li>\n</ul>\n</li>\n<li>Protection<ul>\n<li>Cannot corrupt OS or other processes</li>\n</ul>\n</li>\n<li>Privacy<ul>\n<li>Cannot read data of other processes</li>\n</ul>\n</li>\n<li>Efficiency<ul>\n<li>Do not waste memory resources (minimize fragmentation（碎片化）)</li>\n</ul>\n</li>\n<li>Sharing<ul>\n<li>Cooperating processes can share portions of address space</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-1-Abstraction-Address-Space\"><a href=\"#6-1-Abstraction-Address-Space\" class=\"headerlink\" title=\"6.1 Abstraction: Address Space\"></a>6.1 Abstraction: Address Space</h3><blockquote>\n<p>Address space: Each process has set of addresses that map to bytes</p>\n</blockquote>\n<p>问题是：OS是如何让每个Process觉得，自己有专用的地址空间的？</p>\n<p>** 回顾 Addresss Space 中都有什么？ **</p>\n<ol>\n<li>静态：<ul>\n<li>Code</li>\n<li>Global Variables</li>\n</ul>\n</li>\n<li>动态：<ul>\n<li>Stack</li>\n<li>Heap</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-1-为什么进程需要动态地分配资源？\"><a href=\"#6-1-1-为什么进程需要动态地分配资源？\" class=\"headerlink\" title=\"6.1.1 为什么进程需要动态地分配资源？\"></a>6.1.1 为什么进程需要动态地分配资源？</h4><blockquote>\n<ol>\n<li>不知道编译时需要的内存量. 静态分配内存时必须悲观, 为最坏的情况分配足够的资源;不高效地使用存储</li>\n<li>对于那些递归的步骤，不知道会嵌套多少次</li>\n<li>进程中会有复杂的数据结构，需要我们手动分配资源。</li>\n</ol>\n</blockquote>\n<h4 id=\"6-1-2-Stack用在哪里？\"><a href=\"#6-1-2-Stack用在哪里？\" class=\"headerlink\" title=\"6.1.2 Stack用在哪里？\"></a>6.1.2 Stack用在哪里？</h4><blockquote>\n<p>操作系统将Stack用于过程调用帧(procedure call frames), 存放local varibles and parameters<br>局部变量例子</p>\n</blockquote>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\nvoid foo(int z);\n\nint main(int argc, char *argv[]) &#123;\n    int A = 0; \n    foo(A);\n    printf(&quot;A: %d\\n&quot;, A); //A: 0\n&#125;\n\nvoid foo(int z) &#123;\n    int A = 2;\n    z = 5;\n    printf(&quot;A: %d, Z: %d\\n&quot;, A, z); //A: 2, Z: 5\n&#125;\n</code></pre>\n<h4 id=\"6-1-3-Heap用在哪里？\"><a href=\"#6-1-3-Heap用在哪里？\" class=\"headerlink\" title=\"6.1.3 Heap用在哪里？\"></a>6.1.3 Heap用在哪里？</h4><blockquote>\n<p>任何位置的malloc(), new() 都会跑到heap里</p>\n<ul>\n<li>Heap memory consists of allocated area and free area</li>\n<li>Order of Allocation and free is unpredictable.</li>\n</ul>\n</blockquote>\n<p>pro：所有数据结构都是这样用的<br>cons:<br>    * Allocation can be slow<br>    * End up with small chunks of free spaces – Fragmentation(碎片化)</p>\n<h4 id=\"6-1-4-OS在managing-heap中的作用\"><a href=\"#6-1-4-OS在managing-heap中的作用\" class=\"headerlink\" title=\"6.1.4 OS在managing heap中的作用\"></a>6.1.4 OS在managing heap中的作用</h4><blockquote>\n<p>OS gives big chunk of free memory to process<br>OS provides library manages individual allocations</p>\n</blockquote>\n<p>代码中各个数据结构在address space中的分布<br><img src=\"/image-4.png\" alt=\"Alt text\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-为什么要学习OSD？\"><a href=\"#1-为什么要学习OSD？\" class=\"headerlink\" title=\"1. 为什么要学习OSD？\"></a>1. 为什么要学习OSD？</h1><blockquote>\n<p>OS forms the foundation of modern computing</p>\n</blockquote>\n<ol>\n<li><p><strong>Abstractions</strong>: Modern Software 是如何使用 Hardware的？</p>\n</li>\n<li><p><strong>Resource Management</strong>： 如何去做 resource isolation？</p>\n</li>\n<li><p>如何在兼顾<strong>实现以上两点的同时</strong>，确保 <strong>High Performace</strong> ?</p>\n</li>\n</ol>\n<p>在这门课上，主要通过两种方式来学习OS</p>\n<ul>\n<li><ol>\n<li>Conceptual Learning</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>Intensive Programming</li>\n</ol>\n</li>\n</ul>\n<p>在笔记的书写中，很多时候并不能很好、贴切的翻译一些英文句子和词汇，所以就直接使用了来自课件、书上的原话。</p>\n<h1 id=\"2-OS-导论\"><a href=\"#2-OS-导论\" class=\"headerlink\" title=\"2. OS 导论\"></a>2. OS 导论</h1><p>OS, 是一个抽象（abstract）和 管理（manage）硬件资源的 <strong>软件</strong><br>从高到低排序： 用户 -&gt; 应用程序 -&gt; 操作系统 -&gt; 硬件</p>\n<p>本章将是这门课内容的导论。section 2以后的章节将对对于各个主题，进行更深层次的讨论和总结。</p>\n<h2 id=\"2-1-硬件\"><a href=\"#2-1-硬件\" class=\"headerlink\" title=\"2.1 硬件\"></a>2.1 硬件</h2><p>OS管理的硬件主要有</p>\n<ol>\n<li>memory： 基本实体都是DRAM,  对应OS中的Memory，使用malloc()作为memory controller, 来分配内存</li>\n<li>Disk：对应OS中的File System, 通过SATA传输，使用read()&#x2F;write() 进行控制</li>\n<li>Nework Adapter: 对应OS中的网络模块， 使用send()&#x2F;recv() 进行传输</li>\n</ol>\n<h2 id=\"2-2-OS提供了什么？\"><a href=\"#2-2-OS提供了什么？\" class=\"headerlink\" title=\"2.2 OS提供了什么？\"></a>2.2 OS提供了什么？</h2><ol>\n<li><p><strong>Software library (abstraction)</strong> between applications and hardware to make the hardware easier to use</p>\n<ul>\n<li>Simple, uniform view of diverse hardware devices</li>\n</ul>\n</li>\n<li><p><strong>Mechanisms and policies for resource management</strong>, to provision and isolate hardware across many applications</p>\n<ul>\n<li>Effective multi-tenant（多租户） and multi-application systems</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-3-Abstrction\"><a href=\"#2-3-Abstrction\" class=\"headerlink\" title=\"2.3 Abstrction\"></a>2.3 Abstrction</h2><h3 id=\"2-3-1-现代操作系统通常为哪些资源提供哪些抽象\"><a href=\"#2-3-1-现代操作系统通常为哪些资源提供哪些抽象\" class=\"headerlink\" title=\"2.3.1 现代操作系统通常为哪些资源提供哪些抽象?\"></a>2.3.1 现代操作系统通常为哪些资源提供哪些抽象?</h3><blockquote>\n<p>CPU：进程&#x2F;线程<br>内存：地址空间<br>存储：文件</p>\n</blockquote>\n<h3 id=\"2-3-2-操作系统提供抽象的好处？\"><a href=\"#2-3-2-操作系统提供抽象的好处？\" class=\"headerlink\" title=\"2.3.2 操作系统提供抽象的好处？\"></a>2.3.2 操作系统提供抽象的好处？</h3><blockquote>\n<p>允许应用程序重用公共资源<br>让不同的设备看起来相同 （内存、主板、硬盘）<br>提供更高级别或更有用的功能</p>\n</blockquote>\n<h3 id=\"2-3-3-挑战\"><a href=\"#2-3-3-挑战\" class=\"headerlink\" title=\"2.3.3 挑战\"></a>2.3.3 挑战</h3><ol>\n<li>What are the correct abstractions?</li>\n<li>How much of the hardware capabilities should be exposed?</li>\n</ol>\n<h2 id=\"2-4-System-Calls\"><a href=\"#2-4-System-Calls\" class=\"headerlink\" title=\"2.4 System Calls\"></a>2.4 System Calls</h2><ul>\n<li>系统调用允许用户告诉操作系统在硬件上执行什么操作</li>\n<li>操作系统提供标准软件接口 （API）</li>\n<li>典型的操作系统会导出几百个系统调用</li>\n<li>运行程序、访问内存、访问硬件设备……</li>\n</ul>\n<h2 id=\"2-5-Resource-Management\"><a href=\"#2-5-Resource-Management\" class=\"headerlink\" title=\"2.5 Resource Management\"></a>2.5 Resource Management</h2><blockquote>\n<p>Want fair and efficient use of hardware across applications</p>\n</blockquote>\n<h3 id=\"2-5-1-Advantages-of-OS-providing-resource-management\"><a href=\"#2-5-1-Advantages-of-OS-providing-resource-management\" class=\"headerlink\" title=\"2.5.1 Advantages of OS providing resource management:\"></a>2.5.1 Advantages of OS providing resource management:</h3><ol>\n<li>Protect applications from one another</li>\n<li>Provide efficient access to resources (cost, time, energy)</li>\n<li>Provide fair access to resources</li>\n</ol>\n<h3 id=\"2-5-2-Challenges\"><a href=\"#2-5-2-Challenges\" class=\"headerlink\" title=\"2.5.2 Challenges\"></a>2.5.2 Challenges</h3><ol>\n<li>What are the correct <strong>mechanisms</strong>?</li>\n<li>What are the correct <strong>policies</strong>?</li>\n</ol>\n<h2 id=\"2-6-Virtualization\"><a href=\"#2-6-Virtualization\" class=\"headerlink\" title=\"2.6 Virtualization\"></a>2.6 Virtualization</h2><blockquote>\n<p>Make each application believe it has each hardware resource to itself<br>这门课主要关注：CPU和Memory</p>\n</blockquote>\n<h3 id=\"2-6-1-Virtualizing-CPU\"><a href=\"#2-6-1-Virtualizing-CPU\" class=\"headerlink\" title=\"2.6.1 Virtualizing CPU\"></a>2.6.1 Virtualizing CPU</h3><ul>\n<li>系统有大量的虚拟CPU： 将一个物理CPU转换为实际上无穷多数量的CPU。允许很多程序同时执行</li>\n<li>可以理解成，当我们在命令行同时执行多个c文件的时候，这时候就可以看成是多个程序同时执行，并实际上使用同一个cpu，但是这些c文件，他们认为自己独占cpu。</li>\n</ul>\n<h3 id=\"2-6-2-Virtualizing-Memory\"><a href=\"#2-6-2-Virtualizing-Memory\" class=\"headerlink\" title=\"2.6.2 Virtualizing Memory\"></a>2.6.2 Virtualizing Memory</h3><ul>\n<li>物理内存其实是一个byte数组</li>\n<li>一个程序将自身所有的数据结构存放在内存中</li>\n<li>读取内存 （load）: <ul>\n<li>指定一个能够访问数据的地址</li>\n</ul>\n</li>\n<li>写入内存 （store）：<ul>\n<li>指定要写入特定地址的数据</li>\n</ul>\n</li>\n</ul>\n<p>虚拟化内存涉及到的一些Mechanism：</p>\n<ol>\n<li>Virtual-to-Physical Memory Mapping</li>\n<li>Page-Fault</li>\n</ol>\n<p>Demo1： 用c分配内存</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[1]) &#123;\n    int a = 0;\n    printf(&quot;%d\\n&quot;, a);//0\n    //aa指针指向a的地址\n    int *aa = &amp;a; \n    //加了*是指针，对应一个数据的地址。那么指针加上指针，就是再次得到值。\n    *aa += 1;\n    printf(&quot;%x\\n&quot;, aa);//a16738d4\n    printf(&quot;%d\\n&quot;, a);//1\n\n    //创建p指针，分配内存。\n    int *p = malloc(sizeof(int));\n    //复制给该片区域\n    *p = 100;\n    printf(&quot;address of p: %x\\n&quot;, p); //fbf156b0\n    printf(&quot;value stored in p: %d\\n&quot;, *p);//100\n    printf(&quot;address of p: %x\\n&quot;, &amp;(*p));//fbf156b0\n&#125;\n</code></pre>\n<p>每个进程都有自己的私有虚拟内存空间（private virtual memory space），OS则会映射这些address space到物理内存中</p>\n<ul>\n<li>对一个正在运行的程序的内存引用，不会影响到其他程序的address space。</li>\n<li>物理内存是一个由OS管理的共享资源</li>\n</ul>\n<h2 id=\"2-7-Concurrency\"><a href=\"#2-7-Concurrency\" class=\"headerlink\" title=\"2.7 Concurrency\"></a>2.7 Concurrency</h2><blockquote>\n<p>Concurrency（并发）： Events are occurring simultaneously and may interact with one another<br>OS必须能够处理并发事件</p>\n</blockquote>\n<p>比较简单的处理方式： 直接隔离他们，阻止他们交互，从而达到Hide Concurrency的效果。<br>但是，这样子指标不治本。因为很多时候有些任务，就是需要进程间交互才能执行的。这时候，才是真正想办法来处理了。<br>常见做法有：</p>\n<ol>\n<li>为进程提供抽象（锁(lock)、信号（semaphores）、条件变量(condition variables)、共享内存(shared memory)、关键部分(critical sections)）</li>\n<li>如果用了锁，则需要确保进程不会死锁</li>\n<li>让交互线程(interaction threads)必须协调对共享数据(shared data)的访问</li>\n</ol>\n<p>多线程Demo：</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n\nvolatile int counter = 0;\nint loop;\nchar *name;\n\nvoid *worker() &#123;\n    for (int i = 0; i &lt; loop; i++) &#123;\n        counter++;\n    &#125;\n&#125;\n\nint main(int argc, char *argv[]) &#123;\n    loop = atoi(argv[1]);\n    pthread_t p1, p2;\n    printf(&quot;initial value: %d\\n&quot;, counter);\n    pthread_create(&amp;p1, NULL, worker, NULL);\n    pthread_create(&amp;p2, NULL, worker, NULL);\n    pthread_join(p1, NULL);\n    pthread_join(p2, NULL);\n    printf(&quot;Final value: %d\\n&quot;, counter); // 20.\n&#125;\n</code></pre>\n<p>可以试着执行之下上面代码。试着改变参数大小。可以发现，如果参数比较小（100~1000），那么最终结果就是参数值*2. 但是，当参数变大后，结果就不对了。</p>\n<pre><code class=\"shell\">./mte 10\ninitial value: 0\nFinal value: 20\n\n./mte 1000\ninitial value: 0\nFinal value: 2000\n\n./mte 10000\ninitial value: 0\nFinal value: 14692\n\n./mte 1000000\ninitial value: 0\nFinal value: 1007083\n</code></pre>\n<p>这是因为并发的情况并没有处理好。p1和p2这两个线程同时执行，并且同时对一个counter进行增加操作。数字小的时候，p1或p2执行的很快，因此并不会出现<strong>p2更新了数字，p1读了旧的数字并将该数字更新到了和p2更新后同样值的情况</strong>。参考数据库的脏读。</p>\n<p>有点抽象，举个例子：</p>\n<pre><code>p2:  读出counter: 10000  然后+ 1 = 10001\np1： 读出counter: 10000  然后+ 1 = 10001;\n</code></pre>\n<p>那这样就等于白操作了。</p>\n<h2 id=\"2-8-Persistence\"><a href=\"#2-8-Persistence\" class=\"headerlink\" title=\"2.8 Persistence\"></a>2.8 Persistence</h2><blockquote>\n<p>Persistence: Access information permanently</p>\n</blockquote>\n<ul>\n<li>信息的寿命比任何一个线程都要长</li>\n<li>机器出现未预期的<strong>重启、断电</strong>。这时候就体现出持久化的重要性了</li>\n</ul>\n<p>持久化需要：</p>\n<ol>\n<li>确保出现unexpected failure的时候，信息能够正确的存储</li>\n<li>提供Abstraction使得进程不知道数据是如何存储的</li>\n<li>因为磁盘IO很慢，我们需要对持久化进行优化</li>\n</ol>\n<h3 id=\"2-8-1-OS-在持久化过程中做了什么？\"><a href=\"#2-8-1-OS-在持久化过程中做了什么？\" class=\"headerlink\" title=\"2.8.1 OS 在持久化过程中做了什么？\"></a>2.8.1 OS 在持久化过程中做了什么？</h3><ol>\n<li>搞清楚新的数据在disk的那一块存放</li>\n<li>向底层（underlying）存储设备（storage device）发出I&#x2F;O 请求</li>\n<li>文件系统（FileSystem）在IO期间处理崩溃</li>\n</ol>\n<h3 id=\"2-8-2-两种持久化策略：\"><a href=\"#2-8-2-两种持久化策略：\" class=\"headerlink\" title=\"2.8.2 两种持久化策略：\"></a>2.8.2 两种持久化策略：</h3><ol>\n<li><p>Journaling</p>\n<ul>\n<li>日志文件系统： 一种文件系统，在将这些更改提交到主文件系统之前，使用日志记录对文件系统的更改</li>\n<li>运行流程：<ul>\n<li>对文件系统的更改首先记录在日志中</li>\n<li>更改成功写入日志后，将其提交到主文件系统</li>\n<li>当系统出现崩溃或故障时，可以通过重放日志来恢复文件系统。日志中记录的任何不完整或不一致的操作都可以完成或撤消，以维护文件系统的完整性。</li>\n<li>崩溃后恢复速度更快</li>\n<li>数据完整性得到保证</li>\n</ul>\n</li>\n<li>例子： ext3、ext4</li>\n</ul>\n</li>\n<li><p>Copy on write</p>\n<ul>\n<li>写入时不直接对原位置的数据进行修改，而是写入新的位置</li>\n<li>原数据将一直保存，直到写入完成</li>\n<li>运行流程：<ol>\n<li>当需要读取数据时，首先从当前位置读取数据</li>\n<li>在新位置制作数据的副本</li>\n<li>对副本进行修改</li>\n<li>最后将只想原数据的指针更新指向新数据的副本</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>简化了崩溃后的恢复。因为在修改完成前的原始数据不会受到影响</li>\n<li>提供了任何给定时间点的一致数据快照</li>\n</ol>\n</li>\n<li>例子： 一些现代化的文件系统，如ZFS、Btrfs</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-CPU-Virtualization\"><a href=\"#3-CPU-Virtualization\" class=\"headerlink\" title=\"3 CPU Virtualization\"></a>3 CPU Virtualization</h2><blockquote>\n<p>从本章开始，我们正式开始讨论虚拟化的第一个主题： CPU 虚拟化<br>本章会解决以下问题：</p>\n<ol>\n<li>What is a process?</li>\n<li>Why is <strong>limited direct execution</strong> a good approach for virtualizing the CPU? </li>\n<li>What execution state must be saved for a process? </li>\n<li>What 3 modes could a process in?</li>\n</ol>\n</blockquote>\n<h3 id=\"3-1-What-is-process\"><a href=\"#3-1-What-is-process\" class=\"headerlink\" title=\"3.1 What is process?\"></a>3.1 What is process?</h3><blockquote>\n<p>Process: An <strong>execution stream</strong>（执行流） in the context（上下文） of a <strong>process state</strong></p>\n</blockquote>\n<p><strong>execution stream</strong><br>    * A stream of executing instructions<br>    * Running piece of code<br>    * Thread of control (其实和execution stream一个意思。单线程的话就是执行流嘛。然后多线程的话，每个线程都有自己的执行流。)</p>\n<p>执行流指的是计算机程序正在执行的指令的顺序流。代表着一段指令是活动的。</p>\n<ul>\n<li>说人话，就是正在跑的程序，这个程序得是活的，而不是在磁盘上的静态文件。在跑的过程中，CPU会直接处理这些指令序列</li>\n</ul>\n<p>补充一下： CPU全名<strong>central processing unit</strong>。别学了半天OS，CPU到底是个啥都不知道。。</p>\n<p><strong>process state</strong><br>    * Everything that the running code can affect or affected by<br>    * Register<br>        * Heap, General Purpose, floating point, stack pointer, program counter<br>    * Memory Spaces<br>    * 例子： Open files</p>\n<ul>\n<li>process is not program!<ul>\n<li>program是静态的代码和数据</li>\n<li>process是动态的代码和数据</li>\n<li>可以有多个process运行同一个program</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-Process-Management-Segments\"><a href=\"#3-2-Process-Management-Segments\" class=\"headerlink\" title=\"3.2 Process Management Segments\"></a>3.2 Process Management Segments</h3><ul>\n<li>OS 会为每个进程分配memory。</li>\n<li>这个memory，包含了很多的块(segment)<ul>\n<li>从上到下来看</li>\n<li>最高层是 stack，用于存储局部变量。也包括command line arguments（位于顶部）， 以及环境变量</li>\n<li>再往下走是Heap。用于动态的memory。 在stack和heap之间，有一块unused segment，用于stack&#x2F;heap的扩容</li>\n<li>.bss Global Uniniialized Variables（全局未初始化变量）</li>\n<li>.data Global Initialized Variables（全局已初始化变量）</li>\n<li>最底层才是code。Read-Only</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3-Process-vs-Thread\"><a href=\"#3-3-Process-vs-Thread\" class=\"headerlink\" title=\"3.3 Process vs. Thread\"></a>3.3 Process vs. Thread</h3><p>很明显，进程肯定不是线程</p>\n<p>但是他们还是有相似之处的，我们可以把线程看作一个<strong>轻量版</strong> 的process（Light weight Process LWP）。</p>\n<p>Thread is a execution stream that <strong>shares an address space</strong><br>一个进程里存在多个线程</p>\n<p>举个共享内存空间的例子。<br>对于进程来说，两个相同程序的不同进程，当他们都在access同一个地址值的时候，他们得到的结果不一样 （内存虚拟化）<br>而对于线程，一个进程内的多个线程，当他们都在access同一个地址值的时候，他们得到的结果是一样的</p>\n<p>对于进程，我们的目标是： <strong>让每个进程都感觉，自己是独占cpu的。</strong></p>\n<h3 id=\"3-4-Resources-Sharing\"><a href=\"#3-4-Resources-Sharing\" class=\"headerlink\" title=\"3.4 Resources Sharing\"></a>3.4 Resources Sharing</h3><p>了解了目标后，我们先看一下OS是怎么分配资源(resources)的</p>\n<p>首先， 资源分配通分为两种：<br>    1. time sharing<br>    2. space sharing</p>\n<blockquote>\n<p>time sharing 主要针对的是<strong>单CPU</strong>的情况。 使多个用户或进程能够共享单个处理器。<br>具体做法是：将可用的处理时间划分为多个小的时间间隔（timeslice），并且将这些时间片分配给各个用户&#x2F;进程。从而打到各个用户&#x2F;进程公平分配资源的效果，并且在他们各自分配的时间片内，能够独享cpu</p>\n</blockquote>\n<ul>\n<li>关si键词： 公平、快速切换（illusion of multaneous execution）</li>\n</ul>\n<blockquote>\n<p>space sharing 关注的是<strong>空间</strong>上的共享&#x2F;复用。每一个进程都被分配CPU容量的一小部分。</p>\n</blockquote>\n<ul>\n<li>关键词：并行（Parallel）执行， 同时执行（real simultanous execution）， 资源隔离（resource isolation）</li>\n</ul>\n<p>在共享时，我们主要注意两点：</p>\n<ol>\n<li>cannot perform restricted operation</li>\n<li>should not run forever or make the entire system slow &#x3D;&gt; performance</li>\n</ol>\n<p>###3.5 Provide Good CPU Performance</p>\n<ol>\n<li>Direct Execution<ul>\n<li>直接让用户操作硬件： CPU只负责创建并初始化进程，之后的控制权就回到起点（比如main()），交给用户手中了。</li>\n</ul>\n</li>\n</ol>\n<p>这样子用户进程的权限就过大了。因此Direct Execution肯定是有问题的：</p>\n<ol>\n<li><p>进程（Process）可以做一些受限（restricted）的事情</p>\n<ul>\n<li>比如读取&#x2F;写入别的进程的数据</li>\n</ul>\n</li>\n<li><p>进程可以永久执行（缓慢，有漏洞，恶意（malicious））</p>\n<ul>\n<li>OS 需要在进程之间交换(swap)的能力</li>\n</ul>\n</li>\n<li><p>OS很多操作很慢： 比如I&#x2F;O  还是进程切换能力</p>\n</li>\n</ol>\n<p>根据以上问题，我们可以给出一个折中的解决方案: 让OS和Hardware保留一些控制权。</p>\n<h3 id=\"3-5-1-Restricted-Ops\"><a href=\"#3-5-1-Restricted-Ops\" class=\"headerlink\" title=\"3.5.1 Restricted Ops\"></a>3.5.1 Restricted Ops</h3><p>Q1: 我们如何确保用户进程不会单方面（unilaterally）执行受限(restricted)的操作呢?</p>\n<p>解决方法： （权限级别&#x2F;分离）privilege levels&#x2F;separation</p>\n<ul>\n<li><p>如果想要直接和设备进行交互， 那就用kernal mode，这样就不受限制了。</p>\n</li>\n<li><p>对于用户进程，就在user mode下执行。如果试图和设备进行直接交互，就会进陷阱（trap），然后software interrupt</p>\n</li>\n<li><p>如果用户进程想和设备进行交互的话，可以通过以下方式：</p>\n<ol>\n<li>System Calls (由OS实现的方法)</li>\n<li>Change Privilege Level（权限级别）through system call（trap）</li>\n</ol>\n</li>\n</ul>\n<p>System call demo: 1 direct system call &amp; 1 system call provided by libc function.</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main(int argc, char *argv[]) &#123;\n    long ID1, ID2;\n    ID1 = syscall(SYS_getpid);\n    printf(&quot;direct system call, pid = %ld\\n&quot;, ID1);//direct system call, pid = 3565265\n    ID2 = getpid();\n    printf(&quot;libc wrapped system call, pid = %ld\\n&quot;, ID2);//libc wrapped system call, pid = 3565265\n&#125;\n</code></pre>\n<h3 id=\"3-6-System-Call-Table-and-Trap-Table\"><a href=\"#3-6-System-Call-Table-and-Trap-Table\" class=\"headerlink\" title=\"3.6 System Call Table and Trap Table\"></a>3.6 System Call Table and Trap Table</h3><blockquote>\n<p>前面讲到过，系统调用表和陷阱表之间存在映射。用于管理用户引发的系统事件。<br>主要得知道怎么通过汇编，对系统调用表和陷阱表进行分析，从而得出系统时间的结果。</p>\n</blockquote>\n<p>CPU使用EAX寄存器（register）的内容作为源操作数。<br>窍门就是看$后面的数字内容，找系统调用表和陷阱表上数字对应的操作就行。</p>\n<p>比如这道题：</p>\n<pre><code>\nSuppose the trap table on a machine looks like the following:\n\n1 - illegal; call OS process kill routine\n\n2- run OS system call routine\n\nSuppose the OS&#39;s system call table looks like the following.\n\n1 - sys_read()\n\n2 - sys_write()\n\nWhat happens when an application performs the following instructions?\n\nmovl $1, %eax\n\nint $1\n</code></pre>\n<p>前面的1是system call表里的，后面的int $1是trap表里的。所以结果就是kill runtime.<br>movl -&gt; 放进eax， int -&gt; 产生软件中断。</p>\n<p>总结一下，user processes 是不被允许直接 perform：</p>\n<ol>\n<li>arbitrary memory access</li>\n<li>Disk I&#x2F;O</li>\n<li>Special x86 instructions like lidt. (Inteterrupted Discription Table)</li>\n</ol>\n<p>如果user processes做了上面的事情，那么大概率就是进了trap，然后kill routine。</p>\n<h3 id=\"3-7-How-to-take-CPU-away\"><a href=\"#3-7-How-to-take-CPU-away\" class=\"headerlink\" title=\"3.7 How to take CPU away?\"></a>3.7 How to take CPU away?</h3><blockquote>\n<p>OS 需要实现多任务处理（multitasking）。先记住一个词<strong>上下文切换</strong>。后面会重点围绕这个概念来讲</p>\n</blockquote>\n<ul>\n<li>Mechanism： To switch between classes</li>\n<li>Policy: To decide which process to run at what time.</li>\n</ul>\n<p><strong>Mechaism 和 Policy的区别？</strong></p>\n<blockquote>\n<p>Policy: Decision-maker to optimize some workload performance metric<br>    * Which Process to run? When to run? &#x3D;&gt; scheduler<br>Mechanism: Low-level code that implements the decision<br>    * How ? &#x3D;&gt; Dispatcher</p>\n</blockquote>\n<p>在这里，我们先将Dispatcher</p>\n<p>Dispatch 的逻辑很简单</p>\n<pre><code class=\"c\">while (1) &#123;\n    run process A for some time slice\n    stop process A and save its time\n    load context of another process\n&#125;\n</code></pre>\n<p>问题是：<br>    1. dispatcher怎么在一段时间后，重新获得控制？<br>    2. 哪些execution context必须被保存并恢复？</p>\n<h4 id=\"3-7-1-Q1-dispatcher怎么在一段时间后，重新获得控制？\"><a href=\"#3-7-1-Q1-dispatcher怎么在一段时间后，重新获得控制？\" class=\"headerlink\" title=\"3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？\"></a>3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？</h4><blockquote>\n<p>Option 1 : Cooperative Muti-tasking<br>通过trap，将CPU移交给操作系统的信任线程<br>    * 例如： System Call， page fault（想要换取的page不在main memory里）或者 error<br>    * yield()<br>但是，这样子的话也有问题。设想一个process，它没有任何越过自身权限的操作（I&#x2F;O）， 也没有进任何的Trap，也没有自己叫yield(),那么最终，这个process就会一直占着整个机器。唯一办法只有重启。</p>\n</blockquote>\n<p>这时候就有了第二种选项</p>\n<blockquote>\n<p>Option 2: Regain control without cooperation<br>我们可以启用周期性的，时钟。进入OS的时候，我们启动时钟，，时钟时间到后，硬件会生成timer interrupt<br>用户也不能屏蔽掉timer interrupt，因为他们没有权限这样子做。</p>\n</blockquote>\n<h4 id=\"3-7-2-Context-save在哪里？\"><a href=\"#3-7-2-Context-save在哪里？\" class=\"headerlink\" title=\"3.7.2 Context save在哪里？\"></a>3.7.2 Context save在哪里？</h4><blockquote>\n<p>process control block (PCB) 也可以叫做 process descriptor (PD)<br>每个进程都会有PCB</p>\n</blockquote>\n<h3 id=\"3-7-2-1-PCB-存储了哪些信息\"><a href=\"#3-7-2-1-PCB-存储了哪些信息\" class=\"headerlink\" title=\"3.7.2.1 PCB 存储了哪些信息\"></a>3.7.2.1 PCB 存储了哪些信息</h3><ol>\n<li>PID</li>\n<li>Process state (I.e., running, ready, or blocked)</li>\n<li>Execution state (all registers, PC, stack pointer) – Context</li>\n<li>Scheduling priority</li>\n<li>Accounting information (parent and child processes)</li>\n<li>Credentials (which resources can be accessed, owner)</li>\n<li>Pointers to other allocated resources (e.g., open files)</li>\n</ol>\n<h3 id=\"3-7-2-2-Context-保存-切换流程\"><a href=\"#3-7-2-2-Context-保存-切换流程\" class=\"headerlink\" title=\"3.7.2.2. Context 保存&#x2F;切换流程\"></a>3.7.2.2. Context 保存&#x2F;切换流程</h3><ol>\n<li>进程A从user mode 转换到 kernal mode，权限提升。OS决定从A转到B</li>\n<li>在kernal stack上保存A的上下文（PC， registers， kernal stack pointer）</li>\n<li>将stack pointer指向进程B的kernal stack</li>\n<li>从B的kernal stack中恢复上下文</li>\n</ol>\n<pre><code class=\"c\">struct context &#123;\n    int eip;\t// Index pointer register\n    int esp;\t// Stack pointer register\n    int ebx;\t// Called the base register\n    int ecx;\t// Called the counter register\n    int edx;\t// Called the data register\n    int esi;\t// Source index register\n    int edi;\t// Destination index register\n    int ebp;\t// Stack base pointer register\n&#125;;\n</code></pre>\n<p>一些进程在执行不需要Cpu的任务的时候，OS会switch到哪些需要CPU的进程<br>为了完成这个功能，OS必须关注进程的状态</p>\n<pre><code class=\"c\">enum proc_state &#123; UNUSED, EMBRYO, SLEEPING,\n                  RUNNABLE, RUNNING, ZOMBIE &#125;;\n</code></pre>\n<p>Running: 占用cpu<br>Ready： 等待CPU<br>Blocked：正在等待同步或者I&#x2F;O.</p>\n<h2 id=\"4-Scheduling\"><a href=\"#4-Scheduling\" class=\"headerlink\" title=\"4. Scheduling\"></a>4. Scheduling</h2><h3 id=\"4-1-两种创建Process的方式\"><a href=\"#4-1-两种创建Process的方式\" class=\"headerlink\" title=\"4.1 两种创建Process的方式\"></a>4.1 两种创建Process的方式</h3><ol>\n<li>New process from sratch (从0构建)</li>\n</ol>\n<ul>\n<li>步骤<ul>\n<li>从memory中加载指定代码和数据；并创建空的call stack</li>\n<li>create and initialzie pcb</li>\n<li>put process on ready list.</li>\n</ul>\n</li>\n</ul>\n<p>好处：定制化，no waste work<br>坏处： 很难涵盖所有可能的options for setup. 比如WindowesNT有10个参数，这咋搞。</p>\n<ol start=\"2\">\n<li>第二个方式： Clone an existing project and change it.<br>Fork(): 克隆调用者<ul>\n<li>停止目前的进程，保存他的状态</li>\n<li>复制代码的stack，code ,data, pcb</li>\n<li>将PCB放进ready list<br>Exec (char *file): exec覆盖调用进程</li>\n<li>替换掉目前的代码和数据</li>\n</ul>\n</li>\n</ol>\n<p>demo: Base shell program</p>\n<pre><code class=\"c\">while (1) &#123;\n    Char *cmd = getcmd();\n    Int retval = fork();\n    If (retval == 0) &#123;\n        // This is the child process\n        // Setup the child’s process environment here\n        // E.g., where is standard I/O, how to handle signals?\n        exec(cmd);\n        // exec does not return if it succeeds\n        printf(“ERROR: Could not execute %s\\n”, cmd);\n        exit(1);\n    &#125; else &#123;\n        // This is the parent process; Wait for child to finish\n        int pid = retval;\n        wait(pid);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-2-Dispatcher-和-Scheduling-区别\"><a href=\"#4-2-Dispatcher-和-Scheduling-区别\" class=\"headerlink\" title=\"4.2 Dispatcher 和 Scheduling 区别\"></a>4.2 Dispatcher 和 Scheduling 区别</h3><blockquote>\n<p>Dispatcher是一个low level 的mechanism 而 Scheduling是policy</p>\n</blockquote>\n<p>Scheduling: Policy to determine which process gets CPU when</p>\n<p>重点： How to transition?\t(“mechanism”)<br>      When to transition?\t(“policy”)  </p>\n<p>一个用于理解的例子：文件IO   Process alternates between CPU and I&#x2F;O process moves between ready and blocked queues</p>\n<p>一些术语<br>Workload: set of <strong>job</strong> descriptions (arrival time, run_time)<br>    * Job: View as current CPU burst of a process</p>\n<p>Metric: measurement of quality of schedule<br>    * Minimize turnaround time<br>         Do not want to wait long for job to complete<br>         Completion_time – arrival_time （process&#x2F;thread complete - process&#x2F;thread add to runqueue）<br>    * Minimize response time<br>        * Schedule interactive jobs promptly so users see output quickly<br>        * Initial_schedule_time – arrival_time （process&#x2F;thread add to runqueue - process&#x2F;thread scheduled）<br>    * Maximize throughput<br>        * Want many jobs to complete per unit of time<br>    * Maximize resource utilization<br>        * Keep expensive devices busy<br>    Minimize overhead<br>        * Reduce number of context switches<br>    Maximize fairness<br>        * All jobs get same amount of CPU over some time interval</p>\n<h3 id=\"4-3-一些-Scheduler\"><a href=\"#4-3-一些-Scheduler\" class=\"headerlink\" title=\"4.3 一些 Scheduler\"></a>4.3 一些 Scheduler</h3><blockquote>\n<p>在考虑Workload的情况下，我们需要考虑这些是否达成</p>\n<ol>\n<li>Each job runs for the same amount of time</li>\n<li>All jobs <strong>arrive at the same time</strong></li>\n<li>All jobs only use the CPU (no I&#x2F;O)</li>\n<li>Run-time of each job is known</li>\n</ol>\n</blockquote>\n<h4 id=\"4-3-1-FIFO\"><a href=\"#4-3-1-FIFO\" class=\"headerlink\" title=\"4.3.1 FIFO\"></a>4.3.1 FIFO</h4><p>FIFO: First In, First Out\t<br>    - also called FCFS (first come first served)<br>     - 根据arrive time来干活<br>    - ABC同时到，先干A，A好了的同时马上干B<br>    - turn_around &#x3D; completion_time - arrival_time</p>\n<p>计算题： 算一下avg_turn_around_time:<br>    <img src=\"/image.png\" alt=\"Alt text\"></p>\n<p>显然FIFO是不满足第一条的， 每个Job跑的时间都不一样。从而导致，metric中的turnaround会很高</p>\n<p><img src=\"/image-1.png\" alt=\"Alt text\"><br>如果第一个来的job非常的time-consuming，那么就会导致，后面那些原本能够很快就完成的job，被堵着（阻塞）。</p>\n<p>这里的平均turnout_time就达到了 (60 + 70 + 80) &#x2F; 3 &#x3D; 70s 而原本有的任务只需要10s就可以完成。</p>\n<p>根据FIFO的缺点，我们就可以设计出第二种似乎更好的Scheduler。 Shortest Job First（SJF）</p>\n<h4 id=\"4-3-2-SJF\"><a href=\"#4-3-2-SJF\" class=\"headerlink\" title=\"4.3.2 SJF\"></a>4.3.2 SJF</h4><blockquote>\n<p>选择run_time最小的job</p>\n</blockquote>\n<p>计算1： 对于这个例子，平均turnout time是多少呢</p>\n<p><img src=\"/image-2.png\" alt=\"Alt text\"><br>(10 + 20 + 80) &#x2F; 3 &#x3D; 36.7</p>\n<p>计算2： 对于这个例子，平均turnout time是多少呢<br><img src=\"/image-3.png\" alt=\"Alt text\"><br>turn_around &#x3D; completion_time - arrival_time<br>记住这个公式，就很好算了。</p>\n<p>可以看出，FIFO和SJF都是非抢占式（non-preemptive）的。只有当任务执行完毕，或者优先级不够的情况下，才会让出CPU。</p>\n<p>抢占式（preemptive）的CPU则相反。就算你的job已经在执行了，万一来了个比你正在执行的job更牛的job，则会schedule更牛的job，你正在运行的job失去了CPU，在旁边等着</p>\n<h4 id=\"4-3-3-STCF\"><a href=\"#4-3-3-STCF\" class=\"headerlink\" title=\"4.3.3 STCF\"></a>4.3.3 STCF</h4><blockquote>\n<p>Shortest time-to-completion First<br>永远执行会完成最快的任务。</p>\n</blockquote>\n<p>计算：平均turnaround time<br><img src=\"/image-4.png\" alt=\"Alt text\"><br>(80 - 0) + (20 - 10) + (30 - 10) &#x3D; 80 + 10 +  20 &#x3D; 110<br>110&#x2F;3 &#x3D; 36.6s<br>很明显在这种情况下，抢占式的turnout time会比非抢占式的快很多</p>\n<h5 id=\"4-3-3-1-Response-Time\"><a href=\"#4-3-3-1-Response-Time\" class=\"headerlink\" title=\"4.3.3.1 Response Time\"></a>4.3.3.1 Response Time</h5><blockquote>\n<p>有时候，从<strong>任务到达</strong>到<strong>任务开始</strong>的这段时间也很重要。我们将这段时间称为：Response Time<br>response_time &#x3D; first_run_time - arrival_time</p>\n</blockquote>\n<p><img src=\"/image-5.png\" alt=\"Alt text\"><br>job b在10s的时候到。<br>turnaround time &#x3D; 30 - 10 &#x3D; 20s<br>response time &#x3D; 20 - 10 &#x3D; 10s</p>\n<h4 id=\"4-3-4-RR\"><a href=\"#4-3-4-RR\" class=\"headerlink\" title=\"4.3.4 RR\"></a>4.3.4 RR</h4><blockquote>\n<p>Round Robin<br>在response time方面比STCF、SJF、FIFO做的都好<br>因为它会每一段时间就会交替状态为Ready的进程，从而每个job第一次开始run的时间不会差距不会特别大。</p>\n</blockquote>\n<p><img src=\"/image-6.png\" alt=\"Alt text\"></p>\n<p>当前，有得必有失。RR在turnaround time上非常慢。因为job是交替执行的，原本能很快结束的job被迫得隔一段时间就让出CPU。<br>通常，我们选择RR的原因是因为我们不知道每个job的run time。选择rr的目的和stcf、sjf一样，都是为了让能够最快完成的进程，有机会最早做到。</p>\n<h4 id=\"4-3-5-MLFQ\"><a href=\"#4-3-5-MLFQ\" class=\"headerlink\" title=\"4.3.5 MLFQ\"></a>4.3.5 MLFQ</h4><blockquote>\n<p>Multi Level Feedback Queue</p>\n</blockquote>\n<p>不同类型的job，要求也不一样</p>\n<ul>\n<li>交互性的（interactive）program，需要更快的response time</li>\n<li>批处理（batch）program，需要更快的turnaround time。</li>\n</ul>\n<p>MLFQ 基于多层的RR（Round Robin）实现。<br>每层都有更高的优先级，并会抢占低优先级的层数。</p>\n<h5 id=\"4-3-5-决定优先级\"><a href=\"#4-3-5-决定优先级\" class=\"headerlink\" title=\"4.3.5 决定优先级\"></a>4.3.5 决定优先级</h5><p>两种方式能够用来决定优先级。</p>\n<ol>\n<li>History<blockquote>\n<p>使用进程过去的behavior来预测未来的behavior<br>根据此进程过去的 CPU 突发（作业），猜测 CPU 突发（作业）的行为方式</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"4-3-6-MLFQ-Rules\"><a href=\"#4-3-6-MLFQ-Rules\" class=\"headerlink\" title=\"4.3.6 MLFQ Rules\"></a>4.3.6 MLFQ Rules</h5><ol>\n<li>If priority(A) &gt; priority(B), A runs</li>\n<li>If priority(A) &#x3D;&#x3D; priority(B), A and B runs in RR</li>\n<li>Process start at the top priority</li>\n<li>If job uses the full timeslice, then demote process</li>\n</ol>\n<p>MLFQ 的小缺陷<br>低优先级的任务可能永远都不会被scheduled。因此，我们需要每隔一段时间就去将所有的job放到最高优先级的队列中。</p>\n<h4 id=\"4-3-6-Lottery-Schedudling\"><a href=\"#4-3-6-Lottery-Schedudling\" class=\"headerlink\" title=\"4.3.6 Lottery Schedudling\"></a>4.3.6 Lottery Schedudling</h4><p>就和它的名字一样。彩票。<br>目标： fair share</p>\n<ul>\n<li>只关心能否公平地分享CPU</li>\n</ul>\n<p><strong>Fair Scheduler</strong>:: Guarantee that each job obtain a certain percentage of CPU time. Not care about response time or turnaroud time<br>实现逻辑也很简单： 给processes 一张彩票，谁中了谁就run。更高的优先级说明拿到了更多的彩票。</p>\n<p>Ticket: 代表了一个process可以占用多少份额的资源。</p>\n<p>比如 Process A拿了75张票，那就占用75%的CPU。 Proess B拿了25张票，那就占用25%的CPU<br>然后Scheduler就会在这100张票里去抽，抽中哪一个数字，就执行手里握着那个数字的线程任务。</p>\n<p>lottery 算法的实现</p>\n<pre><code class=\"c\">int counter = 0;\nint winner = getrandom(0, totaltickets);\nnode_t *current = head;\n\nwhile (current) &#123;\n    counter += current-&gt;tickets;\n    if (counter &gt; winner)\n        break;\n    current = current-&gt;next;\n&#125;\n// current is the winner\n</code></pre>\n<p><img src=\"/image.png\" alt=\"Alt text\"></p>\n<h4 id=\"4-3-7-Stride-Scheduling\"><a href=\"#4-3-7-Stride-Scheduling\" class=\"headerlink\" title=\"4.3.7 Stride Scheduling\"></a>4.3.7 Stride Scheduling</h4><p>目标同样是为了防止任何线程monopoly CPU。</p>\n<p>The basic idea is assign each process a ‘stride’, which represents its priority or share of the CPU time. </p>\n<p>系统中的每个进程都被分配了一个唯一的步长值。步幅与进程的优先级成反比。优先级较高的进程分配较小的步幅，优先级较低的进程分配较大的步幅。目标是让优先级较高的进程更频繁地访问 CPU。</p>\n<p>同样，进程会被放进一个队列。所有进程自身的counter从0开始。每次自己被执行了，就将自身的counter 翻一翻（counter + stride）。 Scheduler会选择具有最小counter的process。<br><img src=\"/image-1.png\" alt=\"Alt text\"></p>\n<ul>\n<li>Stride Scheduling同样也存在问题：<ul>\n<li>对于新增job，很难确保公平性和优先性。因为每个job，在初始状态下，counter都是0.问题是，当这些线程执行了一段时间后，counter就会变得很大，起码会和0差很多。那么新的job加进来，scheduler必然会判定一直让新job占用cpu，这样就不公平了</li>\n<li>就算不考虑新增。如果你想手动更改process的优先级，又该怎么做呢</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-3-8-Complete-Fair-Scheduling\"><a href=\"#4-3-8-Complete-Fair-Scheduling\" class=\"headerlink\" title=\"4.3.8 Complete Fair Scheduling\"></a>4.3.8 Complete Fair Scheduling</h4><p>很显然Stride Scheduling可以确保一定的完整性，但是不能完全确保完全公平</p>\n<p>我们的目标是无论线程数量的大小，无论何时添加、更改线程，都能保证其公平地使用资源</p>\n<p>Complete Fair Scheduling(CFS) 自从Linux 2.6.23 版本被应用。 O(logN) runtime<br>原本是MLFQ<br>Process now ordered by the amount of CPU time they use<br>取代了队列，转而使用红黑树</p>\n<ul>\n<li>CFS核心概念<ul>\n<li>使用一个counter记录累计执行时间（cummulative execution time）</li>\n<li>Schedule process with <strong>least</strong> runtime</li>\n</ul>\n</li>\n</ul>\n<p>下面这些都是gpt对其的介绍</p>\n<ul>\n<li><p>虚拟运行时间：</p>\n<ul>\n<li>CFS为每个可运行的进程维护一个“虚拟运行时间”。虚拟运行时间表示一个进程等待执行的时间相对于其他进程。较小的虚拟运行时间值表示更高的优先级。</li>\n</ul>\n</li>\n<li><p>调度决策：</p>\n<ul>\n<li>选择具有最小虚拟运行时间的进程进行执行。这确保了等待时间较长或累积CPU时间较短的进程被优先考虑。</li>\n</ul>\n</li>\n<li><p>时间量子：</p>\n<ul>\n<li>CFS不使用固定的时间片或时间量子，而是根据可运行进程的数量和它们的虚拟运行时间动态调整时间量子。</li>\n</ul>\n</li>\n<li><p>动态时间量子计算：</p>\n<ul>\n<li>CFS根据进程的权重计算每个进程的时间量子。权重是分配给每个进程的值，表示它在CPU中的份额。较高的权重导致较大的时间量子。</li>\n</ul>\n</li>\n<li><p>权重和Nice值：</p>\n<ul>\n<li>进程根据其优先级被分配权重。用户进程可以使用“nice”值进行优先级调整，该值范围从-20到+19。较低的nice值表示较高的优先级。权重与nice值成反比。</li>\n</ul>\n</li>\n<li><p>平衡机制：</p>\n<ul>\n<li>CFS采用平衡机制来维持随时间的公平性。它定期检查运行队列，如果检测到不平衡，则重新分配负载。这有助于确保没有进程在CPU时间上被不公平地耗尽。</li>\n</ul>\n</li>\n<li><p>稳态公平性：</p>\n<ul>\n<li>CFS旨在实现稳态公平性，这意味着在更长的时间内，每个进程都能获得其公平份额的CPU时间，而不考虑短期波动。</li>\n</ul>\n</li>\n<li><p>红黑树数据结构：</p>\n<ul>\n<li>CFS中的运行队列使用红黑树数据结构实现。这允许根据它们的虚拟运行时间有效地插入和删除进程。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/image-2.png\" alt=\"Alt text\"></p>\n<h2 id=\"5-Muti-core-Scheduling\"><a href=\"#5-Muti-core-Scheduling\" class=\"headerlink\" title=\"5. Muti-core Scheduling\"></a>5. Muti-core Scheduling</h2><blockquote>\n<p>由于多核处理器的兴起，多核调度成为必须。因为单单添加CPU的数量不会让一个应用程序执行地更快。我们需要重写应用程序以保证其能<strong>并行</strong>执行</p>\n</blockquote>\n<h3 id=\"5-1-单CPU-缓存-main-memory\"><a href=\"#5-1-单CPU-缓存-main-memory\" class=\"headerlink\" title=\"5.1 单CPU + 缓存 + main memory\"></a>5.1 单CPU + 缓存 + main memory</h3><p>CPU分出一篇区域给缓存，存放popular data found in main memory. 速度块，容量小<br>Main memory存放所有数据，从main memory获取数据的速度会比cache慢很多</p>\n<h3 id=\"5-2-多CPU情况\"><a href=\"#5-2-多CPU情况\" class=\"headerlink\" title=\"5.2 多CPU情况\"></a>5.2 多CPU情况</h3><p>简单来说，每个CPU都有一个缓存区域。那两个CPU加起来就有两块缓存区域了。</p>\n<p>同步不同缓存区域的内存看起来很简单： CPU0 将memory中的 数据放进了自己的缓存区，CPU1会读取CPU0的缓存区，同步数据。</p>\n<p>但是，有一种特殊情况：<br>    1. CPU 0 读内存放进缓存，CPU1 读到了共享。<br>    2. CPU 0 更新了缓存中的数据 同时 CPU 1 被schedule了<br>    3. 此时 CPU 1 中保存的还是过去的数据。<br>数据就不一致了</p>\n<p>解决方法很简单： Bus Snooping<br>    * 每个cache都会通过观察bus来注意到memory的更新<br>    * 当CPU注意到自身memory中的数据更新了，就会注意到这个变化</p>\n<h3 id=\"5-3-Cache-Affinity\"><a href=\"#5-3-Cache-Affinity\" class=\"headerlink\" title=\"5.3 Cache Affinity\"></a>5.3 Cache Affinity</h3><blockquote>\n<p>无论是多CPU还是单CPU，Scheduler都会尝试将一个进程放在同一个CPU上执行。因为当CPU在执行该线程时，会往缓存里加很多关于改进程的状态。那么等到改进程下次启动时，就会更快一点，因为缓存里已经有信息了</p>\n</blockquote>\n<p>实现方式：将所有需要scheduled的任务全部放在一个队列里面。每个CPU就从这个<strong>Globally Shared</strong>的队列里面拿job。</p>\n<p>坏处：<br>    1. 锁<br>    2. 扩展性缺少<br>    3. Cache Affinity<br>    4. 实现起来复杂</p>\n<h3 id=\"5-4-Multi-queue-Multiprocessor-Scheduling-MQMS\"><a href=\"#5-4-Multi-queue-Multiprocessor-Scheduling-MQMS\" class=\"headerlink\" title=\"5.4 Multi-queue Multiprocessor Scheduling (MQMS)\"></a>5.4 Multi-queue Multiprocessor Scheduling (MQMS)</h3><ul>\n<li>Contains Multiple Scheduling queues<ul>\n<li>每条队列都有自己的Scheduling Discipline</li>\n<li>当job进入系统的时候，只会放在一条队列上， 从而避免了信息共享（information sharing）和 同步（synchronization）的问题</li>\n</ul>\n</li>\n</ul>\n<p>MQMS with Round Robin<br><img src=\"/image-3.png\" alt=\"Alt text\"></p>\n<p>MQMS的问题： 需要通过跨内核迁移进程来平衡跨内核的负载</p>\n<h2 id=\"6-Virtualizing-Memory\"><a href=\"#6-Virtualizing-Memory\" class=\"headerlink\" title=\"6. Virtualizing Memory\"></a>6. Virtualizing Memory</h2><p>目标： </p>\n<ul>\n<li>Transparency<ul>\n<li>Processes are not aware that memory is shared</li>\n<li>Works regardless of number and&#x2F;or location of processes</li>\n</ul>\n</li>\n<li>Protection<ul>\n<li>Cannot corrupt OS or other processes</li>\n</ul>\n</li>\n<li>Privacy<ul>\n<li>Cannot read data of other processes</li>\n</ul>\n</li>\n<li>Efficiency<ul>\n<li>Do not waste memory resources (minimize fragmentation（碎片化）)</li>\n</ul>\n</li>\n<li>Sharing<ul>\n<li>Cooperating processes can share portions of address space</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-1-Abstraction-Address-Space\"><a href=\"#6-1-Abstraction-Address-Space\" class=\"headerlink\" title=\"6.1 Abstraction: Address Space\"></a>6.1 Abstraction: Address Space</h3><blockquote>\n<p>Address space: Each process has set of addresses that map to bytes</p>\n</blockquote>\n<p>问题是：OS是如何让每个Process觉得，自己有专用的地址空间的？</p>\n<p>** 回顾 Addresss Space 中都有什么？ **</p>\n<ol>\n<li>静态：<ul>\n<li>Code</li>\n<li>Global Variables</li>\n</ul>\n</li>\n<li>动态：<ul>\n<li>Stack</li>\n<li>Heap</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-1-1-为什么进程需要动态地分配资源？\"><a href=\"#6-1-1-为什么进程需要动态地分配资源？\" class=\"headerlink\" title=\"6.1.1 为什么进程需要动态地分配资源？\"></a>6.1.1 为什么进程需要动态地分配资源？</h4><blockquote>\n<ol>\n<li>不知道编译时需要的内存量. 静态分配内存时必须悲观, 为最坏的情况分配足够的资源;不高效地使用存储</li>\n<li>对于那些递归的步骤，不知道会嵌套多少次</li>\n<li>进程中会有复杂的数据结构，需要我们手动分配资源。</li>\n</ol>\n</blockquote>\n<h4 id=\"6-1-2-Stack用在哪里？\"><a href=\"#6-1-2-Stack用在哪里？\" class=\"headerlink\" title=\"6.1.2 Stack用在哪里？\"></a>6.1.2 Stack用在哪里？</h4><blockquote>\n<p>操作系统将Stack用于过程调用帧(procedure call frames), 存放local varibles and parameters<br>局部变量例子</p>\n</blockquote>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;\n\nvoid foo(int z);\n\nint main(int argc, char *argv[]) &#123;\n    int A = 0; \n    foo(A);\n    printf(&quot;A: %d\\n&quot;, A); //A: 0\n&#125;\n\nvoid foo(int z) &#123;\n    int A = 2;\n    z = 5;\n    printf(&quot;A: %d, Z: %d\\n&quot;, A, z); //A: 2, Z: 5\n&#125;\n</code></pre>\n<h4 id=\"6-1-3-Heap用在哪里？\"><a href=\"#6-1-3-Heap用在哪里？\" class=\"headerlink\" title=\"6.1.3 Heap用在哪里？\"></a>6.1.3 Heap用在哪里？</h4><blockquote>\n<p>任何位置的malloc(), new() 都会跑到heap里</p>\n<ul>\n<li>Heap memory consists of allocated area and free area</li>\n<li>Order of Allocation and free is unpredictable.</li>\n</ul>\n</blockquote>\n<p>pro：所有数据结构都是这样用的<br>cons:<br>    * Allocation can be slow<br>    * End up with small chunks of free spaces – Fragmentation(碎片化)</p>\n<h4 id=\"6-1-4-OS在managing-heap中的作用\"><a href=\"#6-1-4-OS在managing-heap中的作用\" class=\"headerlink\" title=\"6.1.4 OS在managing heap中的作用\"></a>6.1.4 OS在managing heap中的作用</h4><blockquote>\n<p>OS gives big chunk of free memory to process<br>OS provides library manages individual allocations</p>\n</blockquote>\n<p>代码中各个数据结构在address space中的分布<br><img src=\"/image-4.png\" alt=\"Alt text\"></p>\n"},{"title":"SQL查漏补缺","date":"2023-10-15T22:44:08.000Z","_content":"\n# SQL查漏补缺\n\n> 记录一下SQL刷题时候遇到的知识点漏洞\n\n## 1. SQL != 和 == 的适用场景\n\n> -- SQL 中，!= 和 == 只能用于数字判断，对于空值， 需要用 is， is not 来判断\n\n* [584. Find Customer Referee](https://leetcode.com/problems/find-customer-referee/)\n\n\n\n## 2. 计算日期差值\n\n```datediff(date1, date2)``` \n\n结果为date1 - date2\n\n* [197. Rising Temperature](https://leetcode.com/problems/rising-temperature/)\n\n\n\n## 3. left/right join必须要on条件，而inner join不需要\n\n\n\n## 4. where/having/join on区别\n\n先看一下SQL的执行流程：\n\n> 第一步：from 选择表\n>\n> 第二步：where 筛选条件，筛选对象--行\n>\n> 第三步：group by 将筛选出来的数据进行分组\n>\n> 第四步：having 筛选条件，筛选对象--组\n>\n> 第五步：select 选取最后的结果\n>\n> 第六步：order by 将结果按照特定顺序排列\n\n\n\n> “where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在**结果返回之前**起作用的，且Where中**不能使用**聚合函数。\n>\n> “Having”是一个过滤声明，是在查询返回**结果集**以后对查询结果进行的**过滤操作**，在Having中**可以使用**聚合函数。\n\n* Having里面**不能用列名**，只能用数值和聚合函数的对比。\n\n  > 在 SQL 查询中，当你使用 `GROUP BY` 语句对结果进行分组时，除了被聚合的列（使用聚合函数如 `MIN`、`MAX`、`AVG`、`SUM` 等）之外，其他列的值将不明确。这些未被聚合的列通常需要通过聚合函数或者放入 `GROUP BY` 子句中，以明确它们在每个分组内的值。\n  >\n  > 所以，当你在 `HAVING` 子句中使用 `order_date` 而不是聚合函数，就是指 `order_date` 是未被聚合的列。`HAVING` 子句用于过滤基于聚合的结果，而未被聚合的列在这个语境下不是直接可用的。\n\n  举例来说：\n\n  ```sql\n  -- 有效的查询，因为 COUNT 是一个聚合函数\n  SELECT customer_id\n  FROM Delivery\n  GROUP BY customer_id\n  HAVING COUNT(*) > 1;\n  ```\n\n  ```sql\n  -- 无效的查询，因为 order_date 是未被聚合的列\n  SELECT customer_id, order_date\n  FROM Delivery\n  GROUP BY customer_id\n  HAVING order_date = MIN(order_date);\n  ```\n\n  在第二个查询中，`order_date` 是未被聚合的列，而 `HAVING` 子句中的条件要求使用 `MIN(order_date)`，这就是为什么会报错的原因。解决方法通常是通过子查询或者连接操作来获取你需要的结果。\n\n\n\n### Mysql报错：group function is not allowed here\n\n在where和on中，我们**不能使用聚合函数**。因为on和where都是针对**行**的筛选。而聚合函数，很明显是对于**整张表上的数据的统计**。\n\n所以，当你将聚合函数的判定放在where和on中，会报错。因为你没办法对一个行进行统计。\n\n聚合函数的判定，放having里。因为having是用来对**结果集**进行筛选的\n\n* [570. Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/)\n\n\n\n\n\n## 5. Mysql中if的用法\n\n> 常用sum内嵌套if\n>\n> sum(if (aaa = 'xxx', 1, 0))\n>\n> \n\n\n\n### 算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\n\n> 使用nullif\n\nnullif(1/0,0)\n\n* [1934. Confirmation Rate](https://leetcode.com/problems/confirmation-rate/)\n\n\n\n## 6. 统计字符串长度\n\n> ```char_length```或者```len```\n\n* [1683. Invalid Tweets](https://leetcode.com/problems/invalid-tweets/)\n\n\n\n## 7. SQL判断字段奇偶\n\n> mod(字段, 2) = 1  或=0   \n\n* [620. Not Boring Movies](https://leetcode.com/problems/not-boring-movies/)\n\n\n\n## 8. SQL 判断日期是否在区间内\n\n>  两种办法\n>\n> 1. 用BETWEEN AND\n>\n> ```sql\n> SELECT *\n> FROM table_name\n> WHERE date_column_name BETWEEN start_date AND end_date;\n> ```\n>\n> 2. 用大于小于\n>\n> ```sql\n> SELECT *\n> FROM table_name\n> WHERE date_column_name >= start_date AND date_column_name <= end_date;\n> ```\n\n* [1251. Average Selling Price](https://leetcode.com/problems/average-selling-price/)\n\n\n\n## 9. Mysql中的sum\n\n> 通常配合groupby使用，在sum中，只要是对单行操作，都可以。比如可以是sum(同一行的价格 * 数量) , 就能求总价\n\n\n\n## 10. Mysql日期的截断\n\n> 正常datetime都是yy-mm-dd 这种格式构成的，如果我们只要yy-mm这一部分，怎么做呢。\n\n使用 DATE_FORMAT(get_date, '%Y-%m-%d') 函数截取。\n\n其中：get_date 是需要截取的字段名；'%Y-%m-%d' 是截取后的日期格式。\n\nselect date_format('1997-10-04 22:23:00','%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T');\n\n结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00\n\n```sql\n-- get_date = \"2006-12-07\"\nSELECT count(*) FROM t_get_video_temp Where DATE_FORMAT(get_date, '%Y-%m-%d')='2006-12-07'; \n```\n\n```sql\nSELECT count(*) FROM t_get_video_temp Where get_date like '2006%-07%';\n```\n\n* [1193. Monthly Transactions I](https://leetcode.com/problems/monthly-transactions-i/)\n\n\n\n## 11. Mysql中日期大小\n\n可以用min()取到最小日期\n\n\n\n## 12. where (字段) in (查询)\n\n[1174. Immediate Food Delivery II](https://leetcode.com/problems/immediate-food-delivery-ii/)\n\n对一张表的**重复操作**有奇效。先筛一次数据，然后对筛选结果进行汇总。\n\n\n\n### 13. 日期要用引号包裹。\n\n\n\n### 14. Round函数的使用\n\nround(值, 0) => 整数\n\nround(值, 1) => 一位小数\n\nround(值, 2) => 两位小数\n\n\n\n### 15. Union的使用\n\nUnion主要用于合并两个结果集. 简而言之就是在原先行的情况下往下追加行","source":"_posts/SQL 查漏补缺.md","raw":"---\ntitle: SQL查漏补缺\ndate: 2023-10-15 18:44:08\n---\n\n# SQL查漏补缺\n\n> 记录一下SQL刷题时候遇到的知识点漏洞\n\n## 1. SQL != 和 == 的适用场景\n\n> -- SQL 中，!= 和 == 只能用于数字判断，对于空值， 需要用 is， is not 来判断\n\n* [584. Find Customer Referee](https://leetcode.com/problems/find-customer-referee/)\n\n\n\n## 2. 计算日期差值\n\n```datediff(date1, date2)``` \n\n结果为date1 - date2\n\n* [197. Rising Temperature](https://leetcode.com/problems/rising-temperature/)\n\n\n\n## 3. left/right join必须要on条件，而inner join不需要\n\n\n\n## 4. where/having/join on区别\n\n先看一下SQL的执行流程：\n\n> 第一步：from 选择表\n>\n> 第二步：where 筛选条件，筛选对象--行\n>\n> 第三步：group by 将筛选出来的数据进行分组\n>\n> 第四步：having 筛选条件，筛选对象--组\n>\n> 第五步：select 选取最后的结果\n>\n> 第六步：order by 将结果按照特定顺序排列\n\n\n\n> “where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在**结果返回之前**起作用的，且Where中**不能使用**聚合函数。\n>\n> “Having”是一个过滤声明，是在查询返回**结果集**以后对查询结果进行的**过滤操作**，在Having中**可以使用**聚合函数。\n\n* Having里面**不能用列名**，只能用数值和聚合函数的对比。\n\n  > 在 SQL 查询中，当你使用 `GROUP BY` 语句对结果进行分组时，除了被聚合的列（使用聚合函数如 `MIN`、`MAX`、`AVG`、`SUM` 等）之外，其他列的值将不明确。这些未被聚合的列通常需要通过聚合函数或者放入 `GROUP BY` 子句中，以明确它们在每个分组内的值。\n  >\n  > 所以，当你在 `HAVING` 子句中使用 `order_date` 而不是聚合函数，就是指 `order_date` 是未被聚合的列。`HAVING` 子句用于过滤基于聚合的结果，而未被聚合的列在这个语境下不是直接可用的。\n\n  举例来说：\n\n  ```sql\n  -- 有效的查询，因为 COUNT 是一个聚合函数\n  SELECT customer_id\n  FROM Delivery\n  GROUP BY customer_id\n  HAVING COUNT(*) > 1;\n  ```\n\n  ```sql\n  -- 无效的查询，因为 order_date 是未被聚合的列\n  SELECT customer_id, order_date\n  FROM Delivery\n  GROUP BY customer_id\n  HAVING order_date = MIN(order_date);\n  ```\n\n  在第二个查询中，`order_date` 是未被聚合的列，而 `HAVING` 子句中的条件要求使用 `MIN(order_date)`，这就是为什么会报错的原因。解决方法通常是通过子查询或者连接操作来获取你需要的结果。\n\n\n\n### Mysql报错：group function is not allowed here\n\n在where和on中，我们**不能使用聚合函数**。因为on和where都是针对**行**的筛选。而聚合函数，很明显是对于**整张表上的数据的统计**。\n\n所以，当你将聚合函数的判定放在where和on中，会报错。因为你没办法对一个行进行统计。\n\n聚合函数的判定，放having里。因为having是用来对**结果集**进行筛选的\n\n* [570. Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/)\n\n\n\n\n\n## 5. Mysql中if的用法\n\n> 常用sum内嵌套if\n>\n> sum(if (aaa = 'xxx', 1, 0))\n>\n> \n\n\n\n### 算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\n\n> 使用nullif\n\nnullif(1/0,0)\n\n* [1934. Confirmation Rate](https://leetcode.com/problems/confirmation-rate/)\n\n\n\n## 6. 统计字符串长度\n\n> ```char_length```或者```len```\n\n* [1683. Invalid Tweets](https://leetcode.com/problems/invalid-tweets/)\n\n\n\n## 7. SQL判断字段奇偶\n\n> mod(字段, 2) = 1  或=0   \n\n* [620. Not Boring Movies](https://leetcode.com/problems/not-boring-movies/)\n\n\n\n## 8. SQL 判断日期是否在区间内\n\n>  两种办法\n>\n> 1. 用BETWEEN AND\n>\n> ```sql\n> SELECT *\n> FROM table_name\n> WHERE date_column_name BETWEEN start_date AND end_date;\n> ```\n>\n> 2. 用大于小于\n>\n> ```sql\n> SELECT *\n> FROM table_name\n> WHERE date_column_name >= start_date AND date_column_name <= end_date;\n> ```\n\n* [1251. Average Selling Price](https://leetcode.com/problems/average-selling-price/)\n\n\n\n## 9. Mysql中的sum\n\n> 通常配合groupby使用，在sum中，只要是对单行操作，都可以。比如可以是sum(同一行的价格 * 数量) , 就能求总价\n\n\n\n## 10. Mysql日期的截断\n\n> 正常datetime都是yy-mm-dd 这种格式构成的，如果我们只要yy-mm这一部分，怎么做呢。\n\n使用 DATE_FORMAT(get_date, '%Y-%m-%d') 函数截取。\n\n其中：get_date 是需要截取的字段名；'%Y-%m-%d' 是截取后的日期格式。\n\nselect date_format('1997-10-04 22:23:00','%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T');\n\n结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00\n\n```sql\n-- get_date = \"2006-12-07\"\nSELECT count(*) FROM t_get_video_temp Where DATE_FORMAT(get_date, '%Y-%m-%d')='2006-12-07'; \n```\n\n```sql\nSELECT count(*) FROM t_get_video_temp Where get_date like '2006%-07%';\n```\n\n* [1193. Monthly Transactions I](https://leetcode.com/problems/monthly-transactions-i/)\n\n\n\n## 11. Mysql中日期大小\n\n可以用min()取到最小日期\n\n\n\n## 12. where (字段) in (查询)\n\n[1174. Immediate Food Delivery II](https://leetcode.com/problems/immediate-food-delivery-ii/)\n\n对一张表的**重复操作**有奇效。先筛一次数据，然后对筛选结果进行汇总。\n\n\n\n### 13. 日期要用引号包裹。\n\n\n\n### 14. Round函数的使用\n\nround(值, 0) => 整数\n\nround(值, 1) => 一位小数\n\nround(值, 2) => 两位小数\n\n\n\n### 15. Union的使用\n\nUnion主要用于合并两个结果集. 简而言之就是在原先行的情况下往下追加行","slug":"SQL 查漏补缺","published":1,"updated":"2023-11-09T06:14:21.122Z","_id":"cloqsd82g0000myjp443ahgkt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"SQL查漏补缺\"><a href=\"#SQL查漏补缺\" class=\"headerlink\" title=\"SQL查漏补缺\"></a>SQL查漏补缺</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>记录一下SQL刷题时候遇到的知识点漏洞</p></blockquote>\n<h2 id=\"1-SQL-和-的适用场景\"><a href=\"#1-SQL-和-的适用场景\" class=\"headerlink\" title=\"1. SQL !&#x3D; 和 &#x3D;&#x3D; 的适用场景\"></a>1. SQL !&#x3D; 和 &#x3D;&#x3D; 的适用场景</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>– SQL 中，!&#x3D; 和 &#x3D;&#x3D; 只能用于数字判断，对于空值， 需要用 is， is not 来判断</p></blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/find-customer-referee/\">584. Find Customer Referee</a></li>\n</ul>\n<h2 id=\"2-计算日期差值\"><a href=\"#2-计算日期差值\" class=\"headerlink\" title=\"2. 计算日期差值\"></a>2. 计算日期差值</h2><p><code>datediff(date1, date2)</code> </p>\n<p>结果为date1 - date2</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/rising-temperature/\">197. Rising Temperature</a></li>\n</ul>\n<h2 id=\"3-left-right-join必须要on条件，而inner-join不需要\"><a href=\"#3-left-right-join必须要on条件，而inner-join不需要\" class=\"headerlink\" title=\"3. left&#x2F;right join必须要on条件，而inner join不需要\"></a>3. left&#x2F;right join必须要on条件，而inner join不需要</h2><h2 id=\"4-where-having-join-on区别\"><a href=\"#4-where-having-join-on区别\" class=\"headerlink\" title=\"4. where&#x2F;having&#x2F;join on区别\"></a>4. where&#x2F;having&#x2F;join on区别</h2><p>先看一下SQL的执行流程：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>第一步：from 选择表</p>\n<p>第二步：where 筛选条件，筛选对象–行</p>\n<p>第三步：group by 将筛选出来的数据进行分组</p>\n<p>第四步：having 筛选条件，筛选对象–组</p>\n<p>第五步：select 选取最后的结果</p>\n<p>第六步：order by 将结果按照特定顺序排列</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在<strong>结果返回之前</strong>起作用的，且Where中<strong>不能使用</strong>聚合函数。</p>\n<p>“Having”是一个过滤声明，是在查询返回<strong>结果集</strong>以后对查询结果进行的<strong>过滤操作</strong>，在Having中<strong>可以使用</strong>聚合函数。</p></blockquote>\n<ul>\n<li><p>Having里面<strong>不能用列名</strong>，只能用数值和聚合函数的对比。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 SQL 查询中，当你使用 <code>GROUP BY</code> 语句对结果进行分组时，除了被聚合的列（使用聚合函数如 <code>MIN</code>、<code>MAX</code>、<code>AVG</code>、<code>SUM</code> 等）之外，其他列的值将不明确。这些未被聚合的列通常需要通过聚合函数或者放入 <code>GROUP BY</code> 子句中，以明确它们在每个分组内的值。</p>\n<p>所以，当你在 <code>HAVING</code> 子句中使用 <code>order_date</code> 而不是聚合函数，就是指 <code>order_date</code> 是未被聚合的列。<code>HAVING</code> 子句用于过滤基于聚合的结果，而未被聚合的列在这个语境下不是直接可用的。</p></blockquote>\n<p>举例来说：</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> 有效的查询，因为 COUNT 是一个聚合函数</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> Delivery</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">GROUP BY</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">HAVING</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">COUNT</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">&gt;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">1</span><span style=\"color: #E0DEF4\">;</span></span></code></pre></div><div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> 无效的查询，因为 order_date 是未被聚合的列</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> customer_id, order_date</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> Delivery</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">GROUP BY</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">HAVING</span><span style=\"color: #E0DEF4\"> order_date </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">MIN</span><span style=\"color: #E0DEF4\">(order_date);</span></span></code></pre></div><p>在第二个查询中，<code>order_date</code> 是未被聚合的列，而 <code>HAVING</code> 子句中的条件要求使用 <code>MIN(order_date)</code>，这就是为什么会报错的原因。解决方法通常是通过子查询或者连接操作来获取你需要的结果。</p>\n</li>\n</ul>\n<h3 id=\"Mysql报错：group-function-is-not-allowed-here\"><a href=\"#Mysql报错：group-function-is-not-allowed-here\" class=\"headerlink\" title=\"Mysql报错：group function is not allowed here\"></a>Mysql报错：group function is not allowed here</h3><p>在where和on中，我们<strong>不能使用聚合函数</strong>。因为on和where都是针对<strong>行</strong>的筛选。而聚合函数，很明显是对于<strong>整张表上的数据的统计</strong>。</p>\n<p>所以，当你将聚合函数的判定放在where和on中，会报错。因为你没办法对一个行进行统计。</p>\n<p>聚合函数的判定，放having里。因为having是用来对<strong>结果集</strong>进行筛选的</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/managers-with-at-least-5-direct-reports/\">570. Managers with at Least 5 Direct Reports</a></li>\n</ul>\n<h2 id=\"5-Mysql中if的用法\"><a href=\"#5-Mysql中if的用法\" class=\"headerlink\" title=\"5. Mysql中if的用法\"></a>5. Mysql中if的用法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>常用sum内嵌套if</p>\n<p>sum(if (aaa &#x3D; ‘xxx’, 1, 0))</p></blockquote>\n<h3 id=\"算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\"><a href=\"#算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\" class=\"headerlink\" title=\"算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\"></a>算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用nullif</p></blockquote>\n<p>nullif(1&#x2F;0,0)</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/confirmation-rate/\">1934. Confirmation Rate</a></li>\n</ul>\n<h2 id=\"6-统计字符串长度\"><a href=\"#6-统计字符串长度\" class=\"headerlink\" title=\"6. 统计字符串长度\"></a>6. 统计字符串长度</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>char_length</code>或者<code>len</code></p></blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/invalid-tweets/\">1683. Invalid Tweets</a></li>\n</ul>\n<h2 id=\"7-SQL判断字段奇偶\"><a href=\"#7-SQL判断字段奇偶\" class=\"headerlink\" title=\"7. SQL判断字段奇偶\"></a>7. SQL判断字段奇偶</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>mod(字段, 2) &#x3D; 1  或&#x3D;0   </p></blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/not-boring-movies/\">620. Not Boring Movies</a></li>\n</ul>\n<h2 id=\"8-SQL-判断日期是否在区间内\"><a href=\"#8-SQL-判断日期是否在区间内\" class=\"headerlink\" title=\"8. SQL 判断日期是否在区间内\"></a>8. SQL 判断日期是否在区间内</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 两种办法</p>\n<ol>\n<li>用BETWEEN AND</li>\n</ol>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">*</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> table_name</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">BETWEEN</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">start_date</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">AND</span><span style=\"color: #E0DEF4\"> end_date;</span></span></code></pre></div><ol start=\"2\">\n<li>用大于小于</li>\n</ol>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">*</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> table_name</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">&gt;=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">start_date</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">AND</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">&lt;=</span><span style=\"color: #E0DEF4\"> end_date;</span></span></code></pre></div></blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/average-selling-price/\">1251. Average Selling Price</a></li>\n</ul>\n<h2 id=\"9-Mysql中的sum\"><a href=\"#9-Mysql中的sum\" class=\"headerlink\" title=\"9. Mysql中的sum\"></a>9. Mysql中的sum</h2><blockquote>\n<p>通常配合groupby使用，在sum中，只要是对单行操作，都可以。比如可以是sum(同一行的价格 * 数量) , 就能求总价</p></blockquote>\n<h2 id=\"10-Mysql日期的截断\"><a href=\"#10-Mysql日期的截断\" class=\"headerlink\" title=\"10. Mysql日期的截断\"></a>10. Mysql日期的截断</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>正常datetime都是yy-mm-dd 这种格式构成的，如果我们只要yy-mm这一部分，怎么做呢。</p></blockquote>\n<p>使用 DATE_FORMAT(get_date, ‘%Y-%m-%d’) 函数截取。</p>\n<p>其中：get_date 是需要截取的字段名；’%Y-%m-%d’ 是截取后的日期格式。</p>\n<p>select date_format(‘1997-10-04 22:23:00’,’%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T’);</p>\n<p>结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> get_date = &quot;2006-12-07&quot;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">count</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> t_get_video_temp </span><span style=\"color: #3E8FB0\">Where</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">DATE_FORMAT</span><span style=\"color: #E0DEF4\">(get_date, </span><span style=\"color: #F6C177\">&#39;%Y-%m-%d&#39;</span><span style=\"color: #E0DEF4\">)</span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #F6C177\">&#39;2006-12-07&#39;</span><span style=\"color: #E0DEF4\">; </span></span></code></pre></div><div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">count</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> t_get_video_temp </span><span style=\"color: #3E8FB0\">Where</span><span style=\"color: #E0DEF4\"> get_date </span><span style=\"color: #3E8FB0\">like</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&#39;2006%-07%&#39;</span><span style=\"color: #E0DEF4\">;</span></span></code></pre></div><ul>\n<li><a href=\"https://leetcode.com/problems/monthly-transactions-i/\">1193. Monthly Transactions I</a></li>\n</ul>\n<h2 id=\"11-Mysql中日期大小\"><a href=\"#11-Mysql中日期大小\" class=\"headerlink\" title=\"11. Mysql中日期大小\"></a>11. Mysql中日期大小</h2><p>可以用min()取到最小日期</p>\n<h2 id=\"12-where-字段-in-查询\"><a href=\"#12-where-字段-in-查询\" class=\"headerlink\" title=\"12. where (字段) in (查询)\"></a>12. where (字段) in (查询)</h2><p><a href=\"https://leetcode.com/problems/immediate-food-delivery-ii/\">1174. Immediate Food Delivery II</a></p>\n<p>对一张表的<strong>重复操作</strong>有奇效。先筛一次数据，然后对筛选结果进行汇总。</p>\n<h3 id=\"13-日期要用引号包裹。\"><a href=\"#13-日期要用引号包裹。\" class=\"headerlink\" title=\"13. 日期要用引号包裹。\"></a>13. 日期要用引号包裹。</h3><h3 id=\"14-Round函数的使用\"><a href=\"#14-Round函数的使用\" class=\"headerlink\" title=\"14. Round函数的使用\"></a>14. Round函数的使用</h3><p>round(值, 0) &#x3D;&gt; 整数</p>\n<p>round(值, 1) &#x3D;&gt; 一位小数</p>\n<p>round(值, 2) &#x3D;&gt; 两位小数</p>\n<h3 id=\"15-Union的使用\"><a href=\"#15-Union的使用\" class=\"headerlink\" title=\"15. Union的使用\"></a>15. Union的使用</h3><p>Union主要用于合并两个结果集. 简而言之就是在原先行的情况下往下追加行</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SQL查漏补缺\"><a href=\"#SQL查漏补缺\" class=\"headerlink\" title=\"SQL查漏补缺\"></a>SQL查漏补缺</h1><blockquote>\n<p>记录一下SQL刷题时候遇到的知识点漏洞</p>\n</blockquote>\n<h2 id=\"1-SQL-和-的适用场景\"><a href=\"#1-SQL-和-的适用场景\" class=\"headerlink\" title=\"1. SQL !&#x3D; 和 &#x3D;&#x3D; 的适用场景\"></a>1. SQL !&#x3D; 和 &#x3D;&#x3D; 的适用场景</h2><blockquote>\n<p>– SQL 中，!&#x3D; 和 &#x3D;&#x3D; 只能用于数字判断，对于空值， 需要用 is， is not 来判断</p>\n</blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/find-customer-referee/\">584. Find Customer Referee</a></li>\n</ul>\n<h2 id=\"2-计算日期差值\"><a href=\"#2-计算日期差值\" class=\"headerlink\" title=\"2. 计算日期差值\"></a>2. 计算日期差值</h2><p><code>datediff(date1, date2)</code> </p>\n<p>结果为date1 - date2</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/rising-temperature/\">197. Rising Temperature</a></li>\n</ul>\n<h2 id=\"3-left-right-join必须要on条件，而inner-join不需要\"><a href=\"#3-left-right-join必须要on条件，而inner-join不需要\" class=\"headerlink\" title=\"3. left&#x2F;right join必须要on条件，而inner join不需要\"></a>3. left&#x2F;right join必须要on条件，而inner join不需要</h2><h2 id=\"4-where-having-join-on区别\"><a href=\"#4-where-having-join-on区别\" class=\"headerlink\" title=\"4. where&#x2F;having&#x2F;join on区别\"></a>4. where&#x2F;having&#x2F;join on区别</h2><p>先看一下SQL的执行流程：</p>\n<blockquote>\n<p>第一步：from 选择表</p>\n<p>第二步：where 筛选条件，筛选对象–行</p>\n<p>第三步：group by 将筛选出来的数据进行分组</p>\n<p>第四步：having 筛选条件，筛选对象–组</p>\n<p>第五步：select 选取最后的结果</p>\n<p>第六步：order by 将结果按照特定顺序排列</p>\n</blockquote>\n<blockquote>\n<p>“where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在<strong>结果返回之前</strong>起作用的，且Where中<strong>不能使用</strong>聚合函数。</p>\n<p>“Having”是一个过滤声明，是在查询返回<strong>结果集</strong>以后对查询结果进行的<strong>过滤操作</strong>，在Having中<strong>可以使用</strong>聚合函数。</p>\n</blockquote>\n<ul>\n<li><p>Having里面<strong>不能用列名</strong>，只能用数值和聚合函数的对比。</p>\n<blockquote>\n<p>在 SQL 查询中，当你使用 <code>GROUP BY</code> 语句对结果进行分组时，除了被聚合的列（使用聚合函数如 <code>MIN</code>、<code>MAX</code>、<code>AVG</code>、<code>SUM</code> 等）之外，其他列的值将不明确。这些未被聚合的列通常需要通过聚合函数或者放入 <code>GROUP BY</code> 子句中，以明确它们在每个分组内的值。</p>\n<p>所以，当你在 <code>HAVING</code> 子句中使用 <code>order_date</code> 而不是聚合函数，就是指 <code>order_date</code> 是未被聚合的列。<code>HAVING</code> 子句用于过滤基于聚合的结果，而未被聚合的列在这个语境下不是直接可用的。</p>\n</blockquote>\n<p>举例来说：</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> 有效的查询，因为 COUNT 是一个聚合函数</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> Delivery</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">GROUP BY</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">HAVING</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">COUNT</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">&gt;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">1</span><span style=\"color: #E0DEF4\">;</span></span></code></pre></div><div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> 无效的查询，因为 order_date 是未被聚合的列</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> customer_id, order_date</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> Delivery</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">GROUP BY</span><span style=\"color: #E0DEF4\"> customer_id</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">HAVING</span><span style=\"color: #E0DEF4\"> order_date </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">MIN</span><span style=\"color: #E0DEF4\">(order_date);</span></span></code></pre></div><p>在第二个查询中，<code>order_date</code> 是未被聚合的列，而 <code>HAVING</code> 子句中的条件要求使用 <code>MIN(order_date)</code>，这就是为什么会报错的原因。解决方法通常是通过子查询或者连接操作来获取你需要的结果。</p>\n</li>\n</ul>\n<h3 id=\"Mysql报错：group-function-is-not-allowed-here\"><a href=\"#Mysql报错：group-function-is-not-allowed-here\" class=\"headerlink\" title=\"Mysql报错：group function is not allowed here\"></a>Mysql报错：group function is not allowed here</h3><p>在where和on中，我们<strong>不能使用聚合函数</strong>。因为on和where都是针对<strong>行</strong>的筛选。而聚合函数，很明显是对于<strong>整张表上的数据的统计</strong>。</p>\n<p>所以，当你将聚合函数的判定放在where和on中，会报错。因为你没办法对一个行进行统计。</p>\n<p>聚合函数的判定，放having里。因为having是用来对<strong>结果集</strong>进行筛选的</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/managers-with-at-least-5-direct-reports/\">570. Managers with at Least 5 Direct Reports</a></li>\n</ul>\n<h2 id=\"5-Mysql中if的用法\"><a href=\"#5-Mysql中if的用法\" class=\"headerlink\" title=\"5. Mysql中if的用法\"></a>5. Mysql中if的用法</h2><blockquote>\n<p>常用sum内嵌套if</p>\n<p>sum(if (aaa &#x3D; ‘xxx’, 1, 0))</p>\n</blockquote>\n<h3 id=\"算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\"><a href=\"#算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\" class=\"headerlink\" title=\"算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\"></a>算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？</h3><blockquote>\n<p>使用nullif</p>\n</blockquote>\n<p>nullif(1&#x2F;0,0)</p>\n<ul>\n<li><a href=\"https://leetcode.com/problems/confirmation-rate/\">1934. Confirmation Rate</a></li>\n</ul>\n<h2 id=\"6-统计字符串长度\"><a href=\"#6-统计字符串长度\" class=\"headerlink\" title=\"6. 统计字符串长度\"></a>6. 统计字符串长度</h2><blockquote>\n<p><code>char_length</code>或者<code>len</code></p>\n</blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/invalid-tweets/\">1683. Invalid Tweets</a></li>\n</ul>\n<h2 id=\"7-SQL判断字段奇偶\"><a href=\"#7-SQL判断字段奇偶\" class=\"headerlink\" title=\"7. SQL判断字段奇偶\"></a>7. SQL判断字段奇偶</h2><blockquote>\n<p>mod(字段, 2) &#x3D; 1  或&#x3D;0   </p>\n</blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/not-boring-movies/\">620. Not Boring Movies</a></li>\n</ul>\n<h2 id=\"8-SQL-判断日期是否在区间内\"><a href=\"#8-SQL-判断日期是否在区间内\" class=\"headerlink\" title=\"8. SQL 判断日期是否在区间内\"></a>8. SQL 判断日期是否在区间内</h2><blockquote>\n<p> 两种办法</p>\n<ol>\n<li>用BETWEEN AND</li>\n</ol>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">*</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> table_name</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">BETWEEN</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">start_date</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">AND</span><span style=\"color: #E0DEF4\"> end_date;</span></span></code></pre></div><ol start=\"2\">\n<li>用大于小于</li>\n</ol>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">*</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> table_name</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">&gt;=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">start_date</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">AND</span><span style=\"color: #E0DEF4\"> date_column_name </span><span style=\"color: #3E8FB0\">&lt;=</span><span style=\"color: #E0DEF4\"> end_date;</span></span></code></pre></div></blockquote>\n<ul>\n<li><a href=\"https://leetcode.com/problems/average-selling-price/\">1251. Average Selling Price</a></li>\n</ul>\n<h2 id=\"9-Mysql中的sum\"><a href=\"#9-Mysql中的sum\" class=\"headerlink\" title=\"9. Mysql中的sum\"></a>9. Mysql中的sum</h2><blockquote>\n<p>通常配合groupby使用，在sum中，只要是对单行操作，都可以。比如可以是sum(同一行的价格 * 数量) , 就能求总价</p>\n</blockquote>\n<h2 id=\"10-Mysql日期的截断\"><a href=\"#10-Mysql日期的截断\" class=\"headerlink\" title=\"10. Mysql日期的截断\"></a>10. Mysql日期的截断</h2><blockquote>\n<p>正常datetime都是yy-mm-dd 这种格式构成的，如果我们只要yy-mm这一部分，怎么做呢。</p>\n</blockquote>\n<p>使用 DATE_FORMAT(get_date, ‘%Y-%m-%d’) 函数截取。</p>\n<p>其中：get_date 是需要截取的字段名；’%Y-%m-%d’ 是截取后的日期格式。</p>\n<p>select date_format(‘1997-10-04 22:23:00’,’%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T’);</p>\n<p>结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00</p>\n<div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">--</span><span style=\"color: #6E6A86; font-style: italic\"> get_date = &quot;2006-12-07&quot;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">count</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> t_get_video_temp </span><span style=\"color: #3E8FB0\">Where</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">DATE_FORMAT</span><span style=\"color: #E0DEF4\">(get_date, </span><span style=\"color: #F6C177\">&#39;%Y-%m-%d&#39;</span><span style=\"color: #E0DEF4\">)</span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #F6C177\">&#39;2006-12-07&#39;</span><span style=\"color: #E0DEF4\">; </span></span></code></pre></div><div class=\"language-sql\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">sql</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">SELECT</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EB6F92; font-style: italic\">count</span><span style=\"color: #E0DEF4\">(</span><span style=\"color: #3E8FB0\">*</span><span style=\"color: #E0DEF4\">) </span><span style=\"color: #3E8FB0\">FROM</span><span style=\"color: #E0DEF4\"> t_get_video_temp </span><span style=\"color: #3E8FB0\">Where</span><span style=\"color: #E0DEF4\"> get_date </span><span style=\"color: #3E8FB0\">like</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&#39;2006%-07%&#39;</span><span style=\"color: #E0DEF4\">;</span></span></code></pre></div><ul>\n<li><a href=\"https://leetcode.com/problems/monthly-transactions-i/\">1193. Monthly Transactions I</a></li>\n</ul>\n<h2 id=\"11-Mysql中日期大小\"><a href=\"#11-Mysql中日期大小\" class=\"headerlink\" title=\"11. Mysql中日期大小\"></a>11. Mysql中日期大小</h2><p>可以用min()取到最小日期</p>\n<h2 id=\"12-where-字段-in-查询\"><a href=\"#12-where-字段-in-查询\" class=\"headerlink\" title=\"12. where (字段) in (查询)\"></a>12. where (字段) in (查询)</h2><p><a href=\"https://leetcode.com/problems/immediate-food-delivery-ii/\">1174. Immediate Food Delivery II</a></p>\n<p>对一张表的<strong>重复操作</strong>有奇效。先筛一次数据，然后对筛选结果进行汇总。</p>\n<h3 id=\"13-日期要用引号包裹。\"><a href=\"#13-日期要用引号包裹。\" class=\"headerlink\" title=\"13. 日期要用引号包裹。\"></a>13. 日期要用引号包裹。</h3><h3 id=\"14-Round函数的使用\"><a href=\"#14-Round函数的使用\" class=\"headerlink\" title=\"14. Round函数的使用\"></a>14. Round函数的使用</h3><p>round(值, 0) &#x3D;&gt; 整数</p>\n<p>round(值, 1) &#x3D;&gt; 一位小数</p>\n<p>round(值, 2) &#x3D;&gt; 两位小数</p>\n<h3 id=\"15-Union的使用\"><a href=\"#15-Union的使用\" class=\"headerlink\" title=\"15. Union的使用\"></a>15. Union的使用</h3><p>Union主要用于合并两个结果集. 简而言之就是在原先行的情况下往下追加行</p>\n"},{"title":"App手工测试要点","date":"2023-11-09T05:00:00.000Z","_content":"\n\n\n\n\n# 1. App 手工测试基础知识\n\n\n\n# 1.1 App架构\n\n* 基本和Web的后端服务器是相同的\n  * 表示层 应用层 数据库\n\n* 前后端也使用HTTP协议进行交互\n* App中, 前后端传值以json为主. 而Web端既可以是json, 也可以是文本\n  * KV\n    * 因为App的前端是写死(hardcoded)在App中的\n\n* APP是C/S结构,而Web浏览器是B/S结构\n  * 新版本要升级,但是web不用\n\n\n\n## 1.2 项目环境\n\n* 开发环境\n  * 开发人员进行开发时调试运行的环境\n* 测试环境\n  * 提供给测试人员使用,用于测试人员进行测试,回归缺陷\n* 预发布环境\n  * 连接到生产环境的数据库.使用生产环境的数据来进行测试\n  * 和测试环境的数据相比,数据更复杂.\n  * 涉及到写入数据库的业务操作时,只能用自己构造的数据.\n* 生产环境\n  * 正式提供对外服务的环境,产品的实际用户使用的环境\n\n\n\n> 灰度发布: 先对部分机器投放版本更新, 如果反馈没问题, 再将剩余一起投放更新. 如果新功能存在问题,则只需要回滚投放更新的那几台.\n>\n> 投放策略: 比如选择尾号为0的用户进行投放.\n>\n> 注意点:\n>\n> 1. 灰度机器不能太多\n> 2. 灰度时间一般在一周到一个约\n> 3. 灰度发布时不能影响用户的使用.\n> 4. 出现问题后,需要到测试环境里来复现问题. 如果问题非常严重, 则需要立马回滚\n\n\n\n## 1.3 APP发布\n\nAPP开发完成后,开发人员会将其打包, 由测试人员安装测试\n\n* 安卓: APK测试包\n* IOS: IPA测试包\n\n\n\n### 应用线上发布平台:\n\n安卓: google store\n\nIOS: App Store\n\n\n\n## 1.4 敏捷开发\n\n* 敏捷开发以用户的需求进化为核心,采用迭代,循序渐进的方法进行软件开发\n* 项目被分为若个子项目, 各个自项目的成果都经过测试, 具备可视,可集成,可运行使用的特征.\n\n\n\n### 1.4.1 瀑布模型\n\n> 线性地进行项目\n\n* 定义阶段\n  * 可行性\n  * 需求分析\n* 开发阶段\n  * 设计\n  * 编码\n  * 测试\n* 维护阶段\n  * 运行维护\n\n缺点: 开发周期长,迭代速度慢\n\n\n\n### 1.4.2 为什么采用敏捷开发\n\n* 互联网行业发展速度快,需求不断变化,产品更新迭代的频率高\n\n* 试错快\n\n```\n代表性的敏捷开发模型: Scrum\n```\n\n\n\n### 1.4.3 Scrum\n\n> 一个增量的, 迭代的开发过程. 在这个框架中,整个开发周期包括**若干个小的迭代周期.** 每个小的迭代周期被称为一个**Sprint**. 每个Sprint周期建议为**2~4周**. 在Scrum中,将产品Backlog(任务待办列表),按商业价值进行排序. 挑选出最有价值的需求进行开发, 开发完成后将产品推进市场,进行下一个版本的迭代.\n\n\n\n三种角色\n\n* Product Owner\n  * 定义产品功能, 决定发布内容和日期, 根据市场的变化对需要开发的功能排列优先顺序\n\n* Scrum Manager\n  * 确保团队不受外界影响\n  * 确保团队生产率\n\n* Dev Team\n  * 程序员\\测试员\\用户体验设计师\n  * 主要职责是实现用户需求\n\n\n\n开发流程:\n\n收集需求, 生成产品功能列表\n\n计划会: 确定优先级高的功能: 市场需求, 存在缺陷\n\n进行迭代(小瀑布)\n\n\n\n# 2. App测试流程\n\n1. 参与需求评审\n2. 制定测试计划: 项目的功能模块, 负责人, 环境,\n3. 设计编写测试用例: 根据需求编写用例, 评审用例, 紧张的话,就写测试点就行了.\n4. 执行用例,跟踪缺陷 : JIRA\n5. 版本测试报告: 测试的模块,用例数, 发现的bug,遗留的bug\n\n\n\n## 2.1 测试之前需要了解什么\n\n1. 项目的作用\n2. 了解项目的目标用户和角色\n3. 了解项目的功能\n4. 了解项目的技术架构\n\n\n\n## 2.2 APP测试要点\n\n对于APP项目的测试,一般是进行系统测试\n\n而系统测试主要包含:\n\n1. 功能测试(重点)\n2. 兼容性(不同系统, 不同厂商的手机)\n3. 安装\\卸载\\升级测试(因为是C\\S 结构)\n4. 交叉事件测试(被其他事件被打断了)\n5. PUSH测试(弹出某个消息提示后)\n\n6. 性能测试(CPU\\内存\\流量\\电量\\流畅度\\启动速度)\n7. 用户体验测试\n8. 稳定性测试 (运行时常,会不会崩)\n\n\n\n**显式需求**\n\n根据软件说明,设计文档,或用户需求验证App的各个功能的实现\n\n\n\n**隐式需求**\n\n被功能影响到的相关业务\n\n\n\n## 2.3 功能测试实践\n\n![image-20231109180125705](../img/app/image-20231109180125705.png)\n\n\n\n","source":"_posts/app.md","raw":"---\ntitle: App手工测试要点\ndate: 2023-11-9 00:00:00\n---\n\n\n\n\n\n# 1. App 手工测试基础知识\n\n\n\n# 1.1 App架构\n\n* 基本和Web的后端服务器是相同的\n  * 表示层 应用层 数据库\n\n* 前后端也使用HTTP协议进行交互\n* App中, 前后端传值以json为主. 而Web端既可以是json, 也可以是文本\n  * KV\n    * 因为App的前端是写死(hardcoded)在App中的\n\n* APP是C/S结构,而Web浏览器是B/S结构\n  * 新版本要升级,但是web不用\n\n\n\n## 1.2 项目环境\n\n* 开发环境\n  * 开发人员进行开发时调试运行的环境\n* 测试环境\n  * 提供给测试人员使用,用于测试人员进行测试,回归缺陷\n* 预发布环境\n  * 连接到生产环境的数据库.使用生产环境的数据来进行测试\n  * 和测试环境的数据相比,数据更复杂.\n  * 涉及到写入数据库的业务操作时,只能用自己构造的数据.\n* 生产环境\n  * 正式提供对外服务的环境,产品的实际用户使用的环境\n\n\n\n> 灰度发布: 先对部分机器投放版本更新, 如果反馈没问题, 再将剩余一起投放更新. 如果新功能存在问题,则只需要回滚投放更新的那几台.\n>\n> 投放策略: 比如选择尾号为0的用户进行投放.\n>\n> 注意点:\n>\n> 1. 灰度机器不能太多\n> 2. 灰度时间一般在一周到一个约\n> 3. 灰度发布时不能影响用户的使用.\n> 4. 出现问题后,需要到测试环境里来复现问题. 如果问题非常严重, 则需要立马回滚\n\n\n\n## 1.3 APP发布\n\nAPP开发完成后,开发人员会将其打包, 由测试人员安装测试\n\n* 安卓: APK测试包\n* IOS: IPA测试包\n\n\n\n### 应用线上发布平台:\n\n安卓: google store\n\nIOS: App Store\n\n\n\n## 1.4 敏捷开发\n\n* 敏捷开发以用户的需求进化为核心,采用迭代,循序渐进的方法进行软件开发\n* 项目被分为若个子项目, 各个自项目的成果都经过测试, 具备可视,可集成,可运行使用的特征.\n\n\n\n### 1.4.1 瀑布模型\n\n> 线性地进行项目\n\n* 定义阶段\n  * 可行性\n  * 需求分析\n* 开发阶段\n  * 设计\n  * 编码\n  * 测试\n* 维护阶段\n  * 运行维护\n\n缺点: 开发周期长,迭代速度慢\n\n\n\n### 1.4.2 为什么采用敏捷开发\n\n* 互联网行业发展速度快,需求不断变化,产品更新迭代的频率高\n\n* 试错快\n\n```\n代表性的敏捷开发模型: Scrum\n```\n\n\n\n### 1.4.3 Scrum\n\n> 一个增量的, 迭代的开发过程. 在这个框架中,整个开发周期包括**若干个小的迭代周期.** 每个小的迭代周期被称为一个**Sprint**. 每个Sprint周期建议为**2~4周**. 在Scrum中,将产品Backlog(任务待办列表),按商业价值进行排序. 挑选出最有价值的需求进行开发, 开发完成后将产品推进市场,进行下一个版本的迭代.\n\n\n\n三种角色\n\n* Product Owner\n  * 定义产品功能, 决定发布内容和日期, 根据市场的变化对需要开发的功能排列优先顺序\n\n* Scrum Manager\n  * 确保团队不受外界影响\n  * 确保团队生产率\n\n* Dev Team\n  * 程序员\\测试员\\用户体验设计师\n  * 主要职责是实现用户需求\n\n\n\n开发流程:\n\n收集需求, 生成产品功能列表\n\n计划会: 确定优先级高的功能: 市场需求, 存在缺陷\n\n进行迭代(小瀑布)\n\n\n\n# 2. App测试流程\n\n1. 参与需求评审\n2. 制定测试计划: 项目的功能模块, 负责人, 环境,\n3. 设计编写测试用例: 根据需求编写用例, 评审用例, 紧张的话,就写测试点就行了.\n4. 执行用例,跟踪缺陷 : JIRA\n5. 版本测试报告: 测试的模块,用例数, 发现的bug,遗留的bug\n\n\n\n## 2.1 测试之前需要了解什么\n\n1. 项目的作用\n2. 了解项目的目标用户和角色\n3. 了解项目的功能\n4. 了解项目的技术架构\n\n\n\n## 2.2 APP测试要点\n\n对于APP项目的测试,一般是进行系统测试\n\n而系统测试主要包含:\n\n1. 功能测试(重点)\n2. 兼容性(不同系统, 不同厂商的手机)\n3. 安装\\卸载\\升级测试(因为是C\\S 结构)\n4. 交叉事件测试(被其他事件被打断了)\n5. PUSH测试(弹出某个消息提示后)\n\n6. 性能测试(CPU\\内存\\流量\\电量\\流畅度\\启动速度)\n7. 用户体验测试\n8. 稳定性测试 (运行时常,会不会崩)\n\n\n\n**显式需求**\n\n根据软件说明,设计文档,或用户需求验证App的各个功能的实现\n\n\n\n**隐式需求**\n\n被功能影响到的相关业务\n\n\n\n## 2.3 功能测试实践\n\n![image-20231109180125705](../img/app/image-20231109180125705.png)\n\n\n\n","slug":"app","published":1,"updated":"2023-11-10T06:00:00.381Z","_id":"clorke6lu0000qmjpbp2o2d84","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-App-手工测试基础知识\"><a href=\"#1-App-手工测试基础知识\" class=\"headerlink\" title=\"1. App 手工测试基础知识\"></a>1. App 手工测试基础知识</h1><h1 id=\"1-1-App架构\"><a href=\"#1-1-App架构\" class=\"headerlink\" title=\"1.1 App架构\"></a>1.1 App架构</h1><ul>\n<li><p>基本和Web的后端服务器是相同的</p>\n<ul>\n<li>表示层 应用层 数据库</li>\n</ul>\n</li>\n<li><p>前后端也使用HTTP协议进行交互</p>\n</li>\n<li><p>App中, 前后端传值以json为主. 而Web端既可以是json, 也可以是文本</p>\n<ul>\n<li>KV<ul>\n<li>因为App的前端是写死(hardcoded)在App中的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>APP是C&#x2F;S结构,而Web浏览器是B&#x2F;S结构</p>\n<ul>\n<li>新版本要升级,但是web不用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-2-项目环境\"><a href=\"#1-2-项目环境\" class=\"headerlink\" title=\"1.2 项目环境\"></a>1.2 项目环境</h2><ul>\n<li>开发环境<ul>\n<li>开发人员进行开发时调试运行的环境</li>\n</ul>\n</li>\n<li>测试环境<ul>\n<li>提供给测试人员使用,用于测试人员进行测试,回归缺陷</li>\n</ul>\n</li>\n<li>预发布环境<ul>\n<li>连接到生产环境的数据库.使用生产环境的数据来进行测试</li>\n<li>和测试环境的数据相比,数据更复杂.</li>\n<li>涉及到写入数据库的业务操作时,只能用自己构造的数据.</li>\n</ul>\n</li>\n<li>生产环境<ul>\n<li>正式提供对外服务的环境,产品的实际用户使用的环境</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>灰度发布: 先对部分机器投放版本更新, 如果反馈没问题, 再将剩余一起投放更新. 如果新功能存在问题,则只需要回滚投放更新的那几台.</p>\n<p>投放策略: 比如选择尾号为0的用户进行投放.</p>\n<p>注意点:</p>\n<ol>\n<li>灰度机器不能太多</li>\n<li>灰度时间一般在一周到一个约</li>\n<li>灰度发布时不能影响用户的使用.</li>\n<li>出现问题后,需要到测试环境里来复现问题. 如果问题非常严重, 则需要立马回滚</li>\n</ol></blockquote>\n<h2 id=\"1-3-APP发布\"><a href=\"#1-3-APP发布\" class=\"headerlink\" title=\"1.3 APP发布\"></a>1.3 APP发布</h2><p>APP开发完成后,开发人员会将其打包, 由测试人员安装测试</p>\n<ul>\n<li>安卓: APK测试包</li>\n<li>IOS: IPA测试包</li>\n</ul>\n<h3 id=\"应用线上发布平台\"><a href=\"#应用线上发布平台\" class=\"headerlink\" title=\"应用线上发布平台:\"></a>应用线上发布平台:</h3><p>安卓: google store</p>\n<p>IOS: App Store</p>\n<h2 id=\"1-4-敏捷开发\"><a href=\"#1-4-敏捷开发\" class=\"headerlink\" title=\"1.4 敏捷开发\"></a>1.4 敏捷开发</h2><ul>\n<li>敏捷开发以用户的需求进化为核心,采用迭代,循序渐进的方法进行软件开发</li>\n<li>项目被分为若个子项目, 各个自项目的成果都经过测试, 具备可视,可集成,可运行使用的特征.</li>\n</ul>\n<h3 id=\"1-4-1-瀑布模型\"><a href=\"#1-4-1-瀑布模型\" class=\"headerlink\" title=\"1.4.1 瀑布模型\"></a>1.4.1 瀑布模型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>线性地进行项目</p></blockquote>\n<ul>\n<li>定义阶段<ul>\n<li>可行性</li>\n<li>需求分析</li>\n</ul>\n</li>\n<li>开发阶段<ul>\n<li>设计</li>\n<li>编码</li>\n<li>测试</li>\n</ul>\n</li>\n<li>维护阶段<ul>\n<li>运行维护</li>\n</ul>\n</li>\n</ul>\n<p>缺点: 开发周期长,迭代速度慢</p>\n<h3 id=\"1-4-2-为什么采用敏捷开发\"><a href=\"#1-4-2-为什么采用敏捷开发\" class=\"headerlink\" title=\"1.4.2 为什么采用敏捷开发\"></a>1.4.2 为什么采用敏捷开发</h3><ul>\n<li><p>互联网行业发展速度快,需求不断变化,产品更新迭代的频率高</p>\n</li>\n<li><p>试错快</p>\n</li>\n</ul>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">代表性的敏捷开发模型: Scrum</span></span></code></pre></div><h3 id=\"1-4-3-Scrum\"><a href=\"#1-4-3-Scrum\" class=\"headerlink\" title=\"1.4.3 Scrum\"></a>1.4.3 Scrum</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一个增量的, 迭代的开发过程. 在这个框架中,整个开发周期包括<strong>若干个小的迭代周期.</strong> 每个小的迭代周期被称为一个<strong>Sprint</strong>. 每个Sprint周期建议为<strong>2~4周</strong>. 在Scrum中,将产品Backlog(任务待办列表),按商业价值进行排序. 挑选出最有价值的需求进行开发, 开发完成后将产品推进市场,进行下一个版本的迭代.</p></blockquote>\n<p>三种角色</p>\n<ul>\n<li><p>Product Owner</p>\n<ul>\n<li>定义产品功能, 决定发布内容和日期, 根据市场的变化对需要开发的功能排列优先顺序</li>\n</ul>\n</li>\n<li><p>Scrum Manager</p>\n<ul>\n<li>确保团队不受外界影响</li>\n<li>确保团队生产率</li>\n</ul>\n</li>\n<li><p>Dev Team</p>\n<ul>\n<li>程序员\\测试员\\用户体验设计师</li>\n<li>主要职责是实现用户需求</li>\n</ul>\n</li>\n</ul>\n<p>开发流程:</p>\n<p>收集需求, 生成产品功能列表</p>\n<p>计划会: 确定优先级高的功能: 市场需求, 存在缺陷</p>\n<p>进行迭代(小瀑布)</p>\n<h1 id=\"2-App测试流程\"><a href=\"#2-App测试流程\" class=\"headerlink\" title=\"2. App测试流程\"></a>2. App测试流程</h1><ol>\n<li>参与需求评审</li>\n<li>制定测试计划: 项目的功能模块, 负责人, 环境,</li>\n<li>设计编写测试用例: 根据需求编写用例, 评审用例, 紧张的话,就写测试点就行了.</li>\n<li>执行用例,跟踪缺陷 : JIRA</li>\n<li>版本测试报告: 测试的模块,用例数, 发现的bug,遗留的bug</li>\n</ol>\n<h2 id=\"2-1-测试之前需要了解什么\"><a href=\"#2-1-测试之前需要了解什么\" class=\"headerlink\" title=\"2.1 测试之前需要了解什么\"></a>2.1 测试之前需要了解什么</h2><ol>\n<li>项目的作用</li>\n<li>了解项目的目标用户和角色</li>\n<li>了解项目的功能</li>\n<li>了解项目的技术架构</li>\n</ol>\n<h2 id=\"2-2-APP测试要点\"><a href=\"#2-2-APP测试要点\" class=\"headerlink\" title=\"2.2 APP测试要点\"></a>2.2 APP测试要点</h2><p>对于APP项目的测试,一般是进行系统测试</p>\n<p>而系统测试主要包含:</p>\n<ol>\n<li><p>功能测试(重点)</p>\n</li>\n<li><p>兼容性(不同系统, 不同厂商的手机)</p>\n</li>\n<li><p>安装\\卸载\\升级测试(因为是C\\S 结构)</p>\n</li>\n<li><p>交叉事件测试(被其他事件被打断了)</p>\n</li>\n<li><p>PUSH测试(弹出某个消息提示后)</p>\n</li>\n<li><p>性能测试(CPU\\内存\\流量\\电量\\流畅度\\启动速度)</p>\n</li>\n<li><p>用户体验测试</p>\n</li>\n<li><p>稳定性测试 (运行时常,会不会崩)</p>\n</li>\n</ol>\n<p><strong>显式需求</strong></p>\n<p>根据软件说明,设计文档,或用户需求验证App的各个功能的实现</p>\n<p><strong>隐式需求</strong></p>\n<p>被功能影响到的相关业务</p>\n<h2 id=\"2-3-功能测试实践\"><a href=\"#2-3-功能测试实践\" class=\"headerlink\" title=\"2.3 功能测试实践\"></a>2.3 功能测试实践</h2><p><img src=\"/../img/app/image-20231109180125705.png\" alt=\"image-20231109180125705\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-App-手工测试基础知识\"><a href=\"#1-App-手工测试基础知识\" class=\"headerlink\" title=\"1. App 手工测试基础知识\"></a>1. App 手工测试基础知识</h1><h1 id=\"1-1-App架构\"><a href=\"#1-1-App架构\" class=\"headerlink\" title=\"1.1 App架构\"></a>1.1 App架构</h1><ul>\n<li><p>基本和Web的后端服务器是相同的</p>\n<ul>\n<li>表示层 应用层 数据库</li>\n</ul>\n</li>\n<li><p>前后端也使用HTTP协议进行交互</p>\n</li>\n<li><p>App中, 前后端传值以json为主. 而Web端既可以是json, 也可以是文本</p>\n<ul>\n<li>KV<ul>\n<li>因为App的前端是写死(hardcoded)在App中的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>APP是C&#x2F;S结构,而Web浏览器是B&#x2F;S结构</p>\n<ul>\n<li>新版本要升级,但是web不用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1-2-项目环境\"><a href=\"#1-2-项目环境\" class=\"headerlink\" title=\"1.2 项目环境\"></a>1.2 项目环境</h2><ul>\n<li>开发环境<ul>\n<li>开发人员进行开发时调试运行的环境</li>\n</ul>\n</li>\n<li>测试环境<ul>\n<li>提供给测试人员使用,用于测试人员进行测试,回归缺陷</li>\n</ul>\n</li>\n<li>预发布环境<ul>\n<li>连接到生产环境的数据库.使用生产环境的数据来进行测试</li>\n<li>和测试环境的数据相比,数据更复杂.</li>\n<li>涉及到写入数据库的业务操作时,只能用自己构造的数据.</li>\n</ul>\n</li>\n<li>生产环境<ul>\n<li>正式提供对外服务的环境,产品的实际用户使用的环境</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>灰度发布: 先对部分机器投放版本更新, 如果反馈没问题, 再将剩余一起投放更新. 如果新功能存在问题,则只需要回滚投放更新的那几台.</p>\n<p>投放策略: 比如选择尾号为0的用户进行投放.</p>\n<p>注意点:</p>\n<ol>\n<li>灰度机器不能太多</li>\n<li>灰度时间一般在一周到一个约</li>\n<li>灰度发布时不能影响用户的使用.</li>\n<li>出现问题后,需要到测试环境里来复现问题. 如果问题非常严重, 则需要立马回滚</li>\n</ol>\n</blockquote>\n<h2 id=\"1-3-APP发布\"><a href=\"#1-3-APP发布\" class=\"headerlink\" title=\"1.3 APP发布\"></a>1.3 APP发布</h2><p>APP开发完成后,开发人员会将其打包, 由测试人员安装测试</p>\n<ul>\n<li>安卓: APK测试包</li>\n<li>IOS: IPA测试包</li>\n</ul>\n<h3 id=\"应用线上发布平台\"><a href=\"#应用线上发布平台\" class=\"headerlink\" title=\"应用线上发布平台:\"></a>应用线上发布平台:</h3><p>安卓: google store</p>\n<p>IOS: App Store</p>\n<h2 id=\"1-4-敏捷开发\"><a href=\"#1-4-敏捷开发\" class=\"headerlink\" title=\"1.4 敏捷开发\"></a>1.4 敏捷开发</h2><ul>\n<li>敏捷开发以用户的需求进化为核心,采用迭代,循序渐进的方法进行软件开发</li>\n<li>项目被分为若个子项目, 各个自项目的成果都经过测试, 具备可视,可集成,可运行使用的特征.</li>\n</ul>\n<h3 id=\"1-4-1-瀑布模型\"><a href=\"#1-4-1-瀑布模型\" class=\"headerlink\" title=\"1.4.1 瀑布模型\"></a>1.4.1 瀑布模型</h3><blockquote>\n<p>线性地进行项目</p>\n</blockquote>\n<ul>\n<li>定义阶段<ul>\n<li>可行性</li>\n<li>需求分析</li>\n</ul>\n</li>\n<li>开发阶段<ul>\n<li>设计</li>\n<li>编码</li>\n<li>测试</li>\n</ul>\n</li>\n<li>维护阶段<ul>\n<li>运行维护</li>\n</ul>\n</li>\n</ul>\n<p>缺点: 开发周期长,迭代速度慢</p>\n<h3 id=\"1-4-2-为什么采用敏捷开发\"><a href=\"#1-4-2-为什么采用敏捷开发\" class=\"headerlink\" title=\"1.4.2 为什么采用敏捷开发\"></a>1.4.2 为什么采用敏捷开发</h3><ul>\n<li><p>互联网行业发展速度快,需求不断变化,产品更新迭代的频率高</p>\n</li>\n<li><p>试错快</p>\n</li>\n</ul>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">代表性的敏捷开发模型: Scrum</span></span></code></pre></div><h3 id=\"1-4-3-Scrum\"><a href=\"#1-4-3-Scrum\" class=\"headerlink\" title=\"1.4.3 Scrum\"></a>1.4.3 Scrum</h3><blockquote>\n<p>一个增量的, 迭代的开发过程. 在这个框架中,整个开发周期包括<strong>若干个小的迭代周期.</strong> 每个小的迭代周期被称为一个<strong>Sprint</strong>. 每个Sprint周期建议为<strong>2~4周</strong>. 在Scrum中,将产品Backlog(任务待办列表),按商业价值进行排序. 挑选出最有价值的需求进行开发, 开发完成后将产品推进市场,进行下一个版本的迭代.</p>\n</blockquote>\n<p>三种角色</p>\n<ul>\n<li><p>Product Owner</p>\n<ul>\n<li>定义产品功能, 决定发布内容和日期, 根据市场的变化对需要开发的功能排列优先顺序</li>\n</ul>\n</li>\n<li><p>Scrum Manager</p>\n<ul>\n<li>确保团队不受外界影响</li>\n<li>确保团队生产率</li>\n</ul>\n</li>\n<li><p>Dev Team</p>\n<ul>\n<li>程序员\\测试员\\用户体验设计师</li>\n<li>主要职责是实现用户需求</li>\n</ul>\n</li>\n</ul>\n<p>开发流程:</p>\n<p>收集需求, 生成产品功能列表</p>\n<p>计划会: 确定优先级高的功能: 市场需求, 存在缺陷</p>\n<p>进行迭代(小瀑布)</p>\n<h1 id=\"2-App测试流程\"><a href=\"#2-App测试流程\" class=\"headerlink\" title=\"2. App测试流程\"></a>2. App测试流程</h1><ol>\n<li>参与需求评审</li>\n<li>制定测试计划: 项目的功能模块, 负责人, 环境,</li>\n<li>设计编写测试用例: 根据需求编写用例, 评审用例, 紧张的话,就写测试点就行了.</li>\n<li>执行用例,跟踪缺陷 : JIRA</li>\n<li>版本测试报告: 测试的模块,用例数, 发现的bug,遗留的bug</li>\n</ol>\n<h2 id=\"2-1-测试之前需要了解什么\"><a href=\"#2-1-测试之前需要了解什么\" class=\"headerlink\" title=\"2.1 测试之前需要了解什么\"></a>2.1 测试之前需要了解什么</h2><ol>\n<li>项目的作用</li>\n<li>了解项目的目标用户和角色</li>\n<li>了解项目的功能</li>\n<li>了解项目的技术架构</li>\n</ol>\n<h2 id=\"2-2-APP测试要点\"><a href=\"#2-2-APP测试要点\" class=\"headerlink\" title=\"2.2 APP测试要点\"></a>2.2 APP测试要点</h2><p>对于APP项目的测试,一般是进行系统测试</p>\n<p>而系统测试主要包含:</p>\n<ol>\n<li><p>功能测试(重点)</p>\n</li>\n<li><p>兼容性(不同系统, 不同厂商的手机)</p>\n</li>\n<li><p>安装\\卸载\\升级测试(因为是C\\S 结构)</p>\n</li>\n<li><p>交叉事件测试(被其他事件被打断了)</p>\n</li>\n<li><p>PUSH测试(弹出某个消息提示后)</p>\n</li>\n<li><p>性能测试(CPU\\内存\\流量\\电量\\流畅度\\启动速度)</p>\n</li>\n<li><p>用户体验测试</p>\n</li>\n<li><p>稳定性测试 (运行时常,会不会崩)</p>\n</li>\n</ol>\n<p><strong>显式需求</strong></p>\n<p>根据软件说明,设计文档,或用户需求验证App的各个功能的实现</p>\n<p><strong>隐式需求</strong></p>\n<p>被功能影响到的相关业务</p>\n<h2 id=\"2-3-功能测试实践\"><a href=\"#2-3-功能测试实践\" class=\"headerlink\" title=\"2.3 功能测试实践\"></a>2.3 功能测试实践</h2><p><img src=\"/../img/app/image-20231109180125705.png\" alt=\"image-20231109180125705\"></p>\n"},{"title":"Jira","date":"2023-11-10T17:56:54.000Z","_content":"\n\n\n\n\n# 1. 软件缺陷\n\n例子:计算器 屏幕不能显示结果\n\n![image-20231110013822136](../img/Jira/image-20231110013822136.png)\n\n​\t\n\n**缺陷的基本内容**\n\n1. 缺陷标题\n2. 预置条件\n3. 重现步骤\n4. 期望结果\n5. 实际结果\n\n\n\n**缺陷的状态**\n\n1. 新建\n2. 打开\n3. 修复\n4. 关闭\n\n\n\n**缺陷的严重程度**\n\n1. 致命 (无法打开)\n2. 严重 (主要功能缺失)\n3. 一般 (功能异常)\n4. 建议 (可改可不改)\n\n\n\n**缺陷的优先级**\n\n1.低\n\n2.中\n\n3.高\n\n\n\n> 测试人员只能对优先级提出建议, 真正决定其优先级的是项目经理/领导\n\n\n\n**软件缺陷的类型**\n\n1. 代码错误\n2. 设计缺陷\n3. 性能问题\n4. 安全相关\n\n\n\n**软件缺陷的跟踪流程**\n\n1. 提交 (测试)\n\n2. 确认 (开发)\n\n3. 打开 (缺陷状态)\n\n4. 修复 (开发)\n\n5. 回归 (测试)\n\n6. 关闭 (缺陷状态)\n\n\n\n# 2. Jira\n\n> 提高协作效率\n\n\n\n## 2.1 Jira的介绍\n\n> 由Atlassian开发的一款软件问题跟踪,管理工具\n\n* 支持多语言\n* 支持多平台运行\n* 配置灵活, 功能强大\n\n\n\n## 2.2 Jira的使用者\n\n1. 企业管理层\n2. 项目经理\n3. 软件测试人员\n4. 开发人员 \n5. 运维/设计\n\n\n\n## 2.3 Jira中的问题(Issue)\n\nIssue包括\n\n1. 缺陷\n2. 新功能\n3. 新人物\n4. 改进\n\n\n\n## 2.4 Jira中的工作流\n\nTo do -> In progress -> in review -> done\n\n(待办)-> 进行中->评审中->进行结束\n\n\n\n工作流: 问题的不同阶段\n\n也可以自己定义工作流.\n\n\n\n## 2.5 Jira的使用\n\n1. 测试提交\n\n2. 开发确认\n\n3. 开发修复\n\n4. 测试回归\n\n\n\n## 2.6 创建缺陷\n\n![image-20231110162340705](../img/Jira/image-20231110162340705.png)\n\n![image-20231110162600768](../img/Jira/image-20231110162600768.png)\n","source":"_posts/Jira.md","raw":"---\ntitle: Jira\ndate: 2023-11-10 12:56:54\n---\n\n\n\n\n\n# 1. 软件缺陷\n\n例子:计算器 屏幕不能显示结果\n\n![image-20231110013822136](../img/Jira/image-20231110013822136.png)\n\n​\t\n\n**缺陷的基本内容**\n\n1. 缺陷标题\n2. 预置条件\n3. 重现步骤\n4. 期望结果\n5. 实际结果\n\n\n\n**缺陷的状态**\n\n1. 新建\n2. 打开\n3. 修复\n4. 关闭\n\n\n\n**缺陷的严重程度**\n\n1. 致命 (无法打开)\n2. 严重 (主要功能缺失)\n3. 一般 (功能异常)\n4. 建议 (可改可不改)\n\n\n\n**缺陷的优先级**\n\n1.低\n\n2.中\n\n3.高\n\n\n\n> 测试人员只能对优先级提出建议, 真正决定其优先级的是项目经理/领导\n\n\n\n**软件缺陷的类型**\n\n1. 代码错误\n2. 设计缺陷\n3. 性能问题\n4. 安全相关\n\n\n\n**软件缺陷的跟踪流程**\n\n1. 提交 (测试)\n\n2. 确认 (开发)\n\n3. 打开 (缺陷状态)\n\n4. 修复 (开发)\n\n5. 回归 (测试)\n\n6. 关闭 (缺陷状态)\n\n\n\n# 2. Jira\n\n> 提高协作效率\n\n\n\n## 2.1 Jira的介绍\n\n> 由Atlassian开发的一款软件问题跟踪,管理工具\n\n* 支持多语言\n* 支持多平台运行\n* 配置灵活, 功能强大\n\n\n\n## 2.2 Jira的使用者\n\n1. 企业管理层\n2. 项目经理\n3. 软件测试人员\n4. 开发人员 \n5. 运维/设计\n\n\n\n## 2.3 Jira中的问题(Issue)\n\nIssue包括\n\n1. 缺陷\n2. 新功能\n3. 新人物\n4. 改进\n\n\n\n## 2.4 Jira中的工作流\n\nTo do -> In progress -> in review -> done\n\n(待办)-> 进行中->评审中->进行结束\n\n\n\n工作流: 问题的不同阶段\n\n也可以自己定义工作流.\n\n\n\n## 2.5 Jira的使用\n\n1. 测试提交\n\n2. 开发确认\n\n3. 开发修复\n\n4. 测试回归\n\n\n\n## 2.6 创建缺陷\n\n![image-20231110162340705](../img/Jira/image-20231110162340705.png)\n\n![image-20231110162600768](../img/Jira/image-20231110162600768.png)\n","slug":"Jira","published":1,"updated":"2023-11-10T21:29:54.130Z","_id":"clos7jbxr0000wmjp86287vej","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-软件缺陷\"><a href=\"#1-软件缺陷\" class=\"headerlink\" title=\"1. 软件缺陷\"></a>1. 软件缺陷</h1><p>例子:计算器 屏幕不能显示结果</p>\n<p><img src=\"/../img/Jira/image-20231110013822136.png\" alt=\"image-20231110013822136\"></p>\n<p>​\t</p>\n<p><strong>缺陷的基本内容</strong></p>\n<ol>\n<li>缺陷标题</li>\n<li>预置条件</li>\n<li>重现步骤</li>\n<li>期望结果</li>\n<li>实际结果</li>\n</ol>\n<p><strong>缺陷的状态</strong></p>\n<ol>\n<li>新建</li>\n<li>打开</li>\n<li>修复</li>\n<li>关闭</li>\n</ol>\n<p><strong>缺陷的严重程度</strong></p>\n<ol>\n<li>致命 (无法打开)</li>\n<li>严重 (主要功能缺失)</li>\n<li>一般 (功能异常)</li>\n<li>建议 (可改可不改)</li>\n</ol>\n<p><strong>缺陷的优先级</strong></p>\n<p>1.低</p>\n<p>2.中</p>\n<p>3.高</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>测试人员只能对优先级提出建议, 真正决定其优先级的是项目经理&#x2F;领导</p></blockquote>\n<p><strong>软件缺陷的类型</strong></p>\n<ol>\n<li>代码错误</li>\n<li>设计缺陷</li>\n<li>性能问题</li>\n<li>安全相关</li>\n</ol>\n<p><strong>软件缺陷的跟踪流程</strong></p>\n<ol>\n<li><p>提交 (测试)</p>\n</li>\n<li><p>确认 (开发)</p>\n</li>\n<li><p>打开 (缺陷状态)</p>\n</li>\n<li><p>修复 (开发)</p>\n</li>\n<li><p>回归 (测试)</p>\n</li>\n<li><p>关闭 (缺陷状态)</p>\n</li>\n</ol>\n<h1 id=\"2-Jira\"><a href=\"#2-Jira\" class=\"headerlink\" title=\"2. Jira\"></a>2. Jira</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>提高协作效率</p></blockquote>\n<h2 id=\"2-1-Jira的介绍\"><a href=\"#2-1-Jira的介绍\" class=\"headerlink\" title=\"2.1 Jira的介绍\"></a>2.1 Jira的介绍</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由Atlassian开发的一款软件问题跟踪,管理工具</p></blockquote>\n<ul>\n<li>支持多语言</li>\n<li>支持多平台运行</li>\n<li>配置灵活, 功能强大</li>\n</ul>\n<h2 id=\"2-2-Jira的使用者\"><a href=\"#2-2-Jira的使用者\" class=\"headerlink\" title=\"2.2 Jira的使用者\"></a>2.2 Jira的使用者</h2><ol>\n<li>企业管理层</li>\n<li>项目经理</li>\n<li>软件测试人员</li>\n<li>开发人员 </li>\n<li>运维&#x2F;设计</li>\n</ol>\n<h2 id=\"2-3-Jira中的问题-Issue\"><a href=\"#2-3-Jira中的问题-Issue\" class=\"headerlink\" title=\"2.3 Jira中的问题(Issue)\"></a>2.3 Jira中的问题(Issue)</h2><p>Issue包括</p>\n<ol>\n<li>缺陷</li>\n<li>新功能</li>\n<li>新人物</li>\n<li>改进</li>\n</ol>\n<h2 id=\"2-4-Jira中的工作流\"><a href=\"#2-4-Jira中的工作流\" class=\"headerlink\" title=\"2.4 Jira中的工作流\"></a>2.4 Jira中的工作流</h2><p>To do -&gt; In progress -&gt; in review -&gt; done</p>\n<p>(待办)-&gt; 进行中-&gt;评审中-&gt;进行结束</p>\n<p>工作流: 问题的不同阶段</p>\n<p>也可以自己定义工作流.</p>\n<h2 id=\"2-5-Jira的使用\"><a href=\"#2-5-Jira的使用\" class=\"headerlink\" title=\"2.5 Jira的使用\"></a>2.5 Jira的使用</h2><ol>\n<li><p>测试提交</p>\n</li>\n<li><p>开发确认</p>\n</li>\n<li><p>开发修复</p>\n</li>\n<li><p>测试回归</p>\n</li>\n</ol>\n<h2 id=\"2-6-创建缺陷\"><a href=\"#2-6-创建缺陷\" class=\"headerlink\" title=\"2.6 创建缺陷\"></a>2.6 创建缺陷</h2><p><img src=\"/../img/Jira/image-20231110162340705.png\" alt=\"image-20231110162340705\"></p>\n<p><img src=\"/../img/Jira/image-20231110162600768.png\" alt=\"image-20231110162600768\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-软件缺陷\"><a href=\"#1-软件缺陷\" class=\"headerlink\" title=\"1. 软件缺陷\"></a>1. 软件缺陷</h1><p>例子:计算器 屏幕不能显示结果</p>\n<p><img src=\"/../img/Jira/image-20231110013822136.png\" alt=\"image-20231110013822136\"></p>\n<p>​\t</p>\n<p><strong>缺陷的基本内容</strong></p>\n<ol>\n<li>缺陷标题</li>\n<li>预置条件</li>\n<li>重现步骤</li>\n<li>期望结果</li>\n<li>实际结果</li>\n</ol>\n<p><strong>缺陷的状态</strong></p>\n<ol>\n<li>新建</li>\n<li>打开</li>\n<li>修复</li>\n<li>关闭</li>\n</ol>\n<p><strong>缺陷的严重程度</strong></p>\n<ol>\n<li>致命 (无法打开)</li>\n<li>严重 (主要功能缺失)</li>\n<li>一般 (功能异常)</li>\n<li>建议 (可改可不改)</li>\n</ol>\n<p><strong>缺陷的优先级</strong></p>\n<p>1.低</p>\n<p>2.中</p>\n<p>3.高</p>\n<blockquote>\n<p>测试人员只能对优先级提出建议, 真正决定其优先级的是项目经理&#x2F;领导</p>\n</blockquote>\n<p><strong>软件缺陷的类型</strong></p>\n<ol>\n<li>代码错误</li>\n<li>设计缺陷</li>\n<li>性能问题</li>\n<li>安全相关</li>\n</ol>\n<p><strong>软件缺陷的跟踪流程</strong></p>\n<ol>\n<li><p>提交 (测试)</p>\n</li>\n<li><p>确认 (开发)</p>\n</li>\n<li><p>打开 (缺陷状态)</p>\n</li>\n<li><p>修复 (开发)</p>\n</li>\n<li><p>回归 (测试)</p>\n</li>\n<li><p>关闭 (缺陷状态)</p>\n</li>\n</ol>\n<h1 id=\"2-Jira\"><a href=\"#2-Jira\" class=\"headerlink\" title=\"2. Jira\"></a>2. Jira</h1><blockquote>\n<p>提高协作效率</p>\n</blockquote>\n<h2 id=\"2-1-Jira的介绍\"><a href=\"#2-1-Jira的介绍\" class=\"headerlink\" title=\"2.1 Jira的介绍\"></a>2.1 Jira的介绍</h2><blockquote>\n<p>由Atlassian开发的一款软件问题跟踪,管理工具</p>\n</blockquote>\n<ul>\n<li>支持多语言</li>\n<li>支持多平台运行</li>\n<li>配置灵活, 功能强大</li>\n</ul>\n<h2 id=\"2-2-Jira的使用者\"><a href=\"#2-2-Jira的使用者\" class=\"headerlink\" title=\"2.2 Jira的使用者\"></a>2.2 Jira的使用者</h2><ol>\n<li>企业管理层</li>\n<li>项目经理</li>\n<li>软件测试人员</li>\n<li>开发人员 </li>\n<li>运维&#x2F;设计</li>\n</ol>\n<h2 id=\"2-3-Jira中的问题-Issue\"><a href=\"#2-3-Jira中的问题-Issue\" class=\"headerlink\" title=\"2.3 Jira中的问题(Issue)\"></a>2.3 Jira中的问题(Issue)</h2><p>Issue包括</p>\n<ol>\n<li>缺陷</li>\n<li>新功能</li>\n<li>新人物</li>\n<li>改进</li>\n</ol>\n<h2 id=\"2-4-Jira中的工作流\"><a href=\"#2-4-Jira中的工作流\" class=\"headerlink\" title=\"2.4 Jira中的工作流\"></a>2.4 Jira中的工作流</h2><p>To do -&gt; In progress -&gt; in review -&gt; done</p>\n<p>(待办)-&gt; 进行中-&gt;评审中-&gt;进行结束</p>\n<p>工作流: 问题的不同阶段</p>\n<p>也可以自己定义工作流.</p>\n<h2 id=\"2-5-Jira的使用\"><a href=\"#2-5-Jira的使用\" class=\"headerlink\" title=\"2.5 Jira的使用\"></a>2.5 Jira的使用</h2><ol>\n<li><p>测试提交</p>\n</li>\n<li><p>开发确认</p>\n</li>\n<li><p>开发修复</p>\n</li>\n<li><p>测试回归</p>\n</li>\n</ol>\n<h2 id=\"2-6-创建缺陷\"><a href=\"#2-6-创建缺陷\" class=\"headerlink\" title=\"2.6 创建缺陷\"></a>2.6 创建缺陷</h2><p><img src=\"/../img/Jira/image-20231110162340705.png\" alt=\"image-20231110162340705\"></p>\n<p><img src=\"/../img/Jira/image-20231110162600768.png\" alt=\"image-20231110162600768\"></p>\n"},{"title":"探索LCU","date":"2023-07-11T04:00:00.000Z","_content":"\n\n\n# LeagueWare--仿照Wegame从零构建第三方英雄联盟客户端助手\n\n**项目依赖**\n\n```xml\n<!--JSON转Map依赖-->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.13.0</version>\n</dependency>\n```\n\n```xml\n<!--Lombok依赖-->\n<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.30</version>\n    <scope>provided</scope>\n</dependency>\n\n```\n\n\n\n**注意, 不同于Web项目, JavaFX项目在引入maven依赖后, 还需要将依赖放入module-info中**\n\n比如这样子\n\n```java\nmodule com.anicaaz.leaguewarefx {\n    requires javafx.controls;\n    requires javafx.fxml;\n    requires lombok;\n    requires com.fasterxml.jackson.databind;\n\n    opens com.anicaaz.leaguewarefx to javafx.fxml;\n    exports com.anicaaz.leaguewarefx;\n    exports com.anicaaz.leaguewarefx.controller;\n    opens com.anicaaz.leaguewarefx.controller to javafx.fxml;\n}\n```\n\n\n\n**一些有用的资源**\n\n1. 所有版本的资源文件: https://raw.communitydragon.org/   \n\n\n\n\n\n## 1. 获取remote-Auth-token 和 app-port\n\n> 当英雄联盟客户端正在运行时, 它会向我们的localhost暴露一个端口. 我们可以通过remote\n\n\n\nWindows下(需要提权)\n\n```powershell\nwmic PROCESS WHERE name='LeagueClientUx.exe' GET commandline \n```\n\nLinux下\n\n```bash\nps -eo pid,cmd | grep 'LeagueClientUx.exe'\n```\n\n- `ps -eo pid,cmd`: 列出所有进程的进程ID（pid）和命令行（cmd）信息。\n  - ps: process state的简称\n  - eo: 表示你可以制定你要的列\n  - cmd则是命令\n- `grep 'LeagueClientUx.exe'`: 使用 `grep` 过滤出包含 'LeagueClientUx.exe' 的行，即与你指定的进程相关的信息。\n\n\n\n然后就会得到下面这样子一长串的键值对\n\n```\n-riotclient-auth-token=E4z7AQD982BWJO09cYzLrA --riotclient-app-port=40465 --no-rads --disable-self-update --region=NA --locale=en_US --client-config-url=https://clientconfig.rpg.riotgames.com --riotgamesapi-standalone --riotgamesapi-settings=eyJjbGllbnQtY29uZmlnIjp7InVybCI6Imh0dHBzOi8vY2xpZW50Y29uZmlnLnJwZy5yaW90Z2FtZXMuY29tIn0sImRlZmF1bHRfcmVnaW9uIjoiTkEiLCJnbG9iYWxzIjp7InNlc3Npb24taWQiOiIxZWY1NDUxMS03OGQ2LTU3NGUtOTY1MC1lMTFiOTUyMzgwOTQifSwicGF0Y2hsaW5lX2lkIjoibGl2ZSIsInByb2R1Y3QtaW50ZWdyYXRpb24iOnsiYXBwLXVwZGF0ZS1zdGF0dXMiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS51cGRhdGUtc3RhdHVzLmpzb24iLCJoZWFydGJlYXQiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL1Jpb3QgQ2xpZW50L0RhdGEvU2Vzc2lvbnMvMWVmNTQ1MTEtNzhkNi01NzRlLTk2NTAtZTExYjk1MjM4MDk0L0U0ejdBUUQ5ODJCV0pPMDljWXpMckEuaGVhcnRiZWF0Lmpzb24iLCJsb2NrZmlsZSI6IkM6L1Byb2dyYW1EYXRhL1Jpb3QgR2FtZXMvTWV0YWRhdGEvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS9sZWFndWVfb2ZfbGVnZW5kcy5saXZlLmxvY2tmaWxlIiwic2V0dGluZ3MiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS5wcm9kdWN0X3NldHRpbmdzLnlhbWwifSwicHJvZHVjdF9pZCI6ImxlYWd1ZV9vZl9sZWdlbmRzIiwicHVibGlzaGVyIjoicmlvdCIsInJlZ2lvbl9kYXRhIjp7Ik5BIjp7ImF2YWlsYWJsZV9sb2NhbGVzIjpbImNzX0NaIiwiZGVfREUiLCJlbF9HUiIsImVuX0FVIiwiZW5fR0IiLCJlbl9QSCIsImVuX1NHIiwiZW5fVVMiLCJlc19BUiIsImVzX0VTIiwiZXNfTVgiLCJmcl9GUiIsImh1X0hVIiwiaXRfSVQiLCJqYV9KUCIsImtvX0tSIiwicGxfUEwiLCJwdF9CUiIsInJvX1JPIiwicnVfUlUiLCJ0aF9USCIsInRyX1RSIiwidmlfVk4iLCJ6aF9NWSIsInpoX1RXIl0sImRlZmF1bHRfbG9jYWxlIjoiZW5fVVMiLCJyc28iOnsiY2xpZW50IjoibG9sIn19fSwicmlvdGNsaWVudCI6eyJhcHAtcG9ydCI6IjQwNDY1IiwiYXV0aC10b2tlbiI6IkU0ejdBUUQ5ODJCV0pPMDljWXpMckEifSwicmlvdGdhbWVzYXBpIjp7InBlcnNpc3RlbmNlLXBhdGgiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL0xlYWd1ZSBvZiBMZWdlbmRzIn0sInJzb19hdXRoIjp7ImF1dGhvcml6YXRpb24ta2V5IjoiZXcwS0lDQWdJQ0pqYjJSbElqb2dJbVJZWTNoUGJGSnBUMVZXTUZWdFpISlZhMHAzV2xSYWVGVkZhRTFVUjA1U1RVWkZkVmxYYkVWaFdFWklVVmQzTUU5WFJrSmFNbWh6WTBSR1NtTnFiRU5hZHowOUlpd05DaUFnSUNBaVkyOWtaVjkyWlhKcFptbGxjaUk2SUNJNFNVWkxWVk4xVGs5WWFqaHpTM0p0V0RJNGVHSm5aMUkwUmxrNWVtaG9ObVk0VkZReFFuZDJaa3BVZVZCMGJqZGpWbUpvVEZKT2VrdEVVa2RvUkhWVk5sQjVhRnBmV0RKWGRsVlhVMmQzTjFjMFkxVldaeUlOQ24wPSJ9fQ== --rga-lite --remoting-auth-token=WMQXBHuk7kPpoS-QyqXm5A --respawn-command=LeagueClient.exe --respawn-display-name=League of Legends --app-port=40703 --install-directory=C:\\Riot Games\\League of Legends --app-name=LeagueClient --ux-name=LeagueClientUx --ux-helper-name=LeagueClientUxHelper --log-dir=LeagueClient Logs --crash-reporting= --crash-environment=NA1 --app-log-file-path=C:/Riot Games/League of Legends/Logs/LeagueClient Logs/2023-11-10T20-45-00_1740_LeagueClient.log --app-pid=1740 --output-base-dir=C:\\Riot Games\\League of Legends --no-proxy-server --ignore-certificate-errors\n\n```\n\n\n\n拿到了以上输出之后, 我们就可以开始对其进行字符串处理了.\n\n在使用java的情况下, 我们可以用`ProcessBuilder`类的start方法来创建一个进程, 执行获取正在运行的英雄联盟客户端的参数.\n\n```java\npackage com.anicaaz.leaguewarefx.utils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\n\npublic class ExecuteCommand {\n\n    /**\n     * Get the token of current running lcu process.\n     * @return The Remoting-Auth-Token of cmdline output.\n     */\n    public static String getRemoteAuthToken() {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", \"ps -eo cmd | grep 'LeagueClientUx.exe'\");\n        String remoteAuthToken = null;\n        try {\n            Process lcuProcess = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(lcuProcess.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(\"--remoting-auth-token\")) {\n                    remoteAuthToken = line.split(\"--remoting-auth-token=\")[1].split(\" \")[0];\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return remoteAuthToken;\n    }\n\n    /**\n     * Get the port that current lcu in running on\n     * @return The port that current lcu in running on\n     */\n    public static String getAppPort() {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", \"ps -eo cmd | grep 'LeagueClientUx.exe'\");\n        String appPort = null;\n        try {\n            Process process = processBuilder.start();\n            String line;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            while ((line = reader.readLine())!= null) {\n                if (line.contains(\"--app-port\")) {\n                    appPort = line.split(\"--app-port=\")[1].split(\" \")[0];\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return appPort;\n    }\n}\n\n```\n\n\n\n注意这里拿到了token后, 还需要\n\n1. 先使用base64加密\n2. 再在前面加上 `Basic ` 注意Basic后面需要有一个空格\n\n\n\n这样,我们就获取好了向LCU API发送请求的请求参数了.\n\n\n\n## 2. LCU Api文档\n\n> https://lcu.vivide.re/\n\n\n\n## 3. 向LCU API发送第一个请求.\n\n请求参数: Authorization: 处理好的token\n\nurl: https://localhost:{portnumber}/apixxx\n\n注意 请求必须是https协议\n\n```\nhttps://127.0.0.1:40703/lol-summoner/v1/current-summoner\n```\n\n![image-20231110232752929](../img/2023-07-11-探索LCU/image-20231110232752929.png)\n\n\n\n访问接口测试通过后, 就可以用httpclient来模拟请求了.\n\n\n\nHttp请求工具类\n\n```\npackage com.anicaaz.leaguewarefx.utils;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class HttpsUtils {\n\n    private String apiUrl;\n    private String requestMethod;\n\n    public Map<String, Object> sendHttpRequest(String authorizationToken) throws IOException {\n        // 设置请求地址\n        URL url = new URL(apiUrl);\n        disableSslVerification();\n        // 打开连接\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // 设置请求方法\n        connection.setRequestMethod(requestMethod);\n\n        // 添加请求头，设置Authorization参数\n        connection.setRequestProperty(\"Authorization\", authorizationToken);\n\n        // 获取响应码\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n\n        // 读取响应内容并将其映射到Map\n        ObjectMapper objectMapper = new ObjectMapper();\n        Map<String, Object> responseMap = objectMapper.readValue(connection.getInputStream(), Map.class);\n\n        // 关闭连接\n        connection.disconnect();\n\n        // 返回响应的Map\n        return responseMap;\n    }\n\n    public static String constructUrl(String baseUrl, String appPort, String requestUrl) {\n        return baseUrl + appPort + \"/\" + requestUrl;\n    }\n\n    private void disableSslVerification() {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            }};\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n注意, 这里需要**禁用ssl验证**. 否则会因为没有证书而一直无法发送请求.","source":"_posts/2023-07-11-探索LCU.md","raw":"---\ntitle: 探索LCU\ndate: 2023-07-11\n---\n\n\n\n# LeagueWare--仿照Wegame从零构建第三方英雄联盟客户端助手\n\n**项目依赖**\n\n```xml\n<!--JSON转Map依赖-->\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>2.13.0</version>\n</dependency>\n```\n\n```xml\n<!--Lombok依赖-->\n<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <version>1.18.30</version>\n    <scope>provided</scope>\n</dependency>\n\n```\n\n\n\n**注意, 不同于Web项目, JavaFX项目在引入maven依赖后, 还需要将依赖放入module-info中**\n\n比如这样子\n\n```java\nmodule com.anicaaz.leaguewarefx {\n    requires javafx.controls;\n    requires javafx.fxml;\n    requires lombok;\n    requires com.fasterxml.jackson.databind;\n\n    opens com.anicaaz.leaguewarefx to javafx.fxml;\n    exports com.anicaaz.leaguewarefx;\n    exports com.anicaaz.leaguewarefx.controller;\n    opens com.anicaaz.leaguewarefx.controller to javafx.fxml;\n}\n```\n\n\n\n**一些有用的资源**\n\n1. 所有版本的资源文件: https://raw.communitydragon.org/   \n\n\n\n\n\n## 1. 获取remote-Auth-token 和 app-port\n\n> 当英雄联盟客户端正在运行时, 它会向我们的localhost暴露一个端口. 我们可以通过remote\n\n\n\nWindows下(需要提权)\n\n```powershell\nwmic PROCESS WHERE name='LeagueClientUx.exe' GET commandline \n```\n\nLinux下\n\n```bash\nps -eo pid,cmd | grep 'LeagueClientUx.exe'\n```\n\n- `ps -eo pid,cmd`: 列出所有进程的进程ID（pid）和命令行（cmd）信息。\n  - ps: process state的简称\n  - eo: 表示你可以制定你要的列\n  - cmd则是命令\n- `grep 'LeagueClientUx.exe'`: 使用 `grep` 过滤出包含 'LeagueClientUx.exe' 的行，即与你指定的进程相关的信息。\n\n\n\n然后就会得到下面这样子一长串的键值对\n\n```\n-riotclient-auth-token=E4z7AQD982BWJO09cYzLrA --riotclient-app-port=40465 --no-rads --disable-self-update --region=NA --locale=en_US --client-config-url=https://clientconfig.rpg.riotgames.com --riotgamesapi-standalone --riotgamesapi-settings=eyJjbGllbnQtY29uZmlnIjp7InVybCI6Imh0dHBzOi8vY2xpZW50Y29uZmlnLnJwZy5yaW90Z2FtZXMuY29tIn0sImRlZmF1bHRfcmVnaW9uIjoiTkEiLCJnbG9iYWxzIjp7InNlc3Npb24taWQiOiIxZWY1NDUxMS03OGQ2LTU3NGUtOTY1MC1lMTFiOTUyMzgwOTQifSwicGF0Y2hsaW5lX2lkIjoibGl2ZSIsInByb2R1Y3QtaW50ZWdyYXRpb24iOnsiYXBwLXVwZGF0ZS1zdGF0dXMiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS51cGRhdGUtc3RhdHVzLmpzb24iLCJoZWFydGJlYXQiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL1Jpb3QgQ2xpZW50L0RhdGEvU2Vzc2lvbnMvMWVmNTQ1MTEtNzhkNi01NzRlLTk2NTAtZTExYjk1MjM4MDk0L0U0ejdBUUQ5ODJCV0pPMDljWXpMckEuaGVhcnRiZWF0Lmpzb24iLCJsb2NrZmlsZSI6IkM6L1Byb2dyYW1EYXRhL1Jpb3QgR2FtZXMvTWV0YWRhdGEvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS9sZWFndWVfb2ZfbGVnZW5kcy5saXZlLmxvY2tmaWxlIiwic2V0dGluZ3MiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS5wcm9kdWN0X3NldHRpbmdzLnlhbWwifSwicHJvZHVjdF9pZCI6ImxlYWd1ZV9vZl9sZWdlbmRzIiwicHVibGlzaGVyIjoicmlvdCIsInJlZ2lvbl9kYXRhIjp7Ik5BIjp7ImF2YWlsYWJsZV9sb2NhbGVzIjpbImNzX0NaIiwiZGVfREUiLCJlbF9HUiIsImVuX0FVIiwiZW5fR0IiLCJlbl9QSCIsImVuX1NHIiwiZW5fVVMiLCJlc19BUiIsImVzX0VTIiwiZXNfTVgiLCJmcl9GUiIsImh1X0hVIiwiaXRfSVQiLCJqYV9KUCIsImtvX0tSIiwicGxfUEwiLCJwdF9CUiIsInJvX1JPIiwicnVfUlUiLCJ0aF9USCIsInRyX1RSIiwidmlfVk4iLCJ6aF9NWSIsInpoX1RXIl0sImRlZmF1bHRfbG9jYWxlIjoiZW5fVVMiLCJyc28iOnsiY2xpZW50IjoibG9sIn19fSwicmlvdGNsaWVudCI6eyJhcHAtcG9ydCI6IjQwNDY1IiwiYXV0aC10b2tlbiI6IkU0ejdBUUQ5ODJCV0pPMDljWXpMckEifSwicmlvdGdhbWVzYXBpIjp7InBlcnNpc3RlbmNlLXBhdGgiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL0xlYWd1ZSBvZiBMZWdlbmRzIn0sInJzb19hdXRoIjp7ImF1dGhvcml6YXRpb24ta2V5IjoiZXcwS0lDQWdJQ0pqYjJSbElqb2dJbVJZWTNoUGJGSnBUMVZXTUZWdFpISlZhMHAzV2xSYWVGVkZhRTFVUjA1U1RVWkZkVmxYYkVWaFdFWklVVmQzTUU5WFJrSmFNbWh6WTBSR1NtTnFiRU5hZHowOUlpd05DaUFnSUNBaVkyOWtaVjkyWlhKcFptbGxjaUk2SUNJNFNVWkxWVk4xVGs5WWFqaHpTM0p0V0RJNGVHSm5aMUkwUmxrNWVtaG9ObVk0VkZReFFuZDJaa3BVZVZCMGJqZGpWbUpvVEZKT2VrdEVVa2RvUkhWVk5sQjVhRnBmV0RKWGRsVlhVMmQzTjFjMFkxVldaeUlOQ24wPSJ9fQ== --rga-lite --remoting-auth-token=WMQXBHuk7kPpoS-QyqXm5A --respawn-command=LeagueClient.exe --respawn-display-name=League of Legends --app-port=40703 --install-directory=C:\\Riot Games\\League of Legends --app-name=LeagueClient --ux-name=LeagueClientUx --ux-helper-name=LeagueClientUxHelper --log-dir=LeagueClient Logs --crash-reporting= --crash-environment=NA1 --app-log-file-path=C:/Riot Games/League of Legends/Logs/LeagueClient Logs/2023-11-10T20-45-00_1740_LeagueClient.log --app-pid=1740 --output-base-dir=C:\\Riot Games\\League of Legends --no-proxy-server --ignore-certificate-errors\n\n```\n\n\n\n拿到了以上输出之后, 我们就可以开始对其进行字符串处理了.\n\n在使用java的情况下, 我们可以用`ProcessBuilder`类的start方法来创建一个进程, 执行获取正在运行的英雄联盟客户端的参数.\n\n```java\npackage com.anicaaz.leaguewarefx.utils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\n\npublic class ExecuteCommand {\n\n    /**\n     * Get the token of current running lcu process.\n     * @return The Remoting-Auth-Token of cmdline output.\n     */\n    public static String getRemoteAuthToken() {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", \"ps -eo cmd | grep 'LeagueClientUx.exe'\");\n        String remoteAuthToken = null;\n        try {\n            Process lcuProcess = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(lcuProcess.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.contains(\"--remoting-auth-token\")) {\n                    remoteAuthToken = line.split(\"--remoting-auth-token=\")[1].split(\" \")[0];\n                    break;\n                }\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return remoteAuthToken;\n    }\n\n    /**\n     * Get the port that current lcu in running on\n     * @return The port that current lcu in running on\n     */\n    public static String getAppPort() {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", \"ps -eo cmd | grep 'LeagueClientUx.exe'\");\n        String appPort = null;\n        try {\n            Process process = processBuilder.start();\n            String line;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            while ((line = reader.readLine())!= null) {\n                if (line.contains(\"--app-port\")) {\n                    appPort = line.split(\"--app-port=\")[1].split(\" \")[0];\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return appPort;\n    }\n}\n\n```\n\n\n\n注意这里拿到了token后, 还需要\n\n1. 先使用base64加密\n2. 再在前面加上 `Basic ` 注意Basic后面需要有一个空格\n\n\n\n这样,我们就获取好了向LCU API发送请求的请求参数了.\n\n\n\n## 2. LCU Api文档\n\n> https://lcu.vivide.re/\n\n\n\n## 3. 向LCU API发送第一个请求.\n\n请求参数: Authorization: 处理好的token\n\nurl: https://localhost:{portnumber}/apixxx\n\n注意 请求必须是https协议\n\n```\nhttps://127.0.0.1:40703/lol-summoner/v1/current-summoner\n```\n\n![image-20231110232752929](../img/2023-07-11-探索LCU/image-20231110232752929.png)\n\n\n\n访问接口测试通过后, 就可以用httpclient来模拟请求了.\n\n\n\nHttp请求工具类\n\n```\npackage com.anicaaz.leaguewarefx.utils;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class HttpsUtils {\n\n    private String apiUrl;\n    private String requestMethod;\n\n    public Map<String, Object> sendHttpRequest(String authorizationToken) throws IOException {\n        // 设置请求地址\n        URL url = new URL(apiUrl);\n        disableSslVerification();\n        // 打开连接\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // 设置请求方法\n        connection.setRequestMethod(requestMethod);\n\n        // 添加请求头，设置Authorization参数\n        connection.setRequestProperty(\"Authorization\", authorizationToken);\n\n        // 获取响应码\n        int responseCode = connection.getResponseCode();\n        System.out.println(\"Response Code: \" + responseCode);\n\n        // 读取响应内容并将其映射到Map\n        ObjectMapper objectMapper = new ObjectMapper();\n        Map<String, Object> responseMap = objectMapper.readValue(connection.getInputStream(), Map.class);\n\n        // 关闭连接\n        connection.disconnect();\n\n        // 返回响应的Map\n        return responseMap;\n    }\n\n    public static String constructUrl(String baseUrl, String appPort, String requestUrl) {\n        return baseUrl + appPort + \"/\" + requestUrl;\n    }\n\n    private void disableSslVerification() {\n        try {\n            TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                    return null;\n                }\n\n                public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                }\n\n                public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) {\n                }\n            }};\n\n            SSLContext sc = SSLContext.getInstance(\"SSL\");\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n注意, 这里需要**禁用ssl验证**. 否则会因为没有证书而一直无法发送请求.","slug":"2023-07-11-探索LCU","published":1,"updated":"2023-11-11T06:01:35.703Z","_id":"clotk2lxi0000j9jp3u73hen7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\"><a href=\"#LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\" class=\"headerlink\" title=\"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\"></a>LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手</h1><p><strong>项目依赖</strong></p>\n<div class=\"language-xml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">xml</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\">JSON转Map依赖</span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">com.fasterxml.jackson.core</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">jackson-databind</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">2.13.0</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span></code></pre></div><div class=\"language-xml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">xml</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\">Lombok依赖</span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\"> https://mvnrepository.com/artifact/org.projectlombok/lombok </span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">org.projectlombok</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">lombok</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">1.18.30</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">scope</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">provided</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">scope</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"></span></code></pre></div><p><strong>注意, 不同于Web项目, JavaFX项目在引入maven依赖后, 还需要将依赖放入module-info中</strong></p>\n<p>比如这样子</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">module</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #9CCFD8\">com</span><span style=\"color: #E0DEF4\">.anicaaz.leaguewarefx </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> javafx.controls;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> lombok;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> com.fasterxml.jackson.databind;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">opens</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx </span><span style=\"color: #3E8FB0\">to</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">exports</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">exports</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx.controller;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">opens</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx.controller </span><span style=\"color: #3E8FB0\">to</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA\">&#125;</span></span></code></pre></div><p><strong>一些有用的资源</strong></p>\n<ol>\n<li>所有版本的资源文件: <a href=\"https://raw.communitydragon.org/\">https://raw.communitydragon.org/</a></li>\n</ol>\n<h2 id=\"1-获取remote-Auth-token-和-app-port\"><a href=\"#1-获取remote-Auth-token-和-app-port\" class=\"headerlink\" title=\"1. 获取remote-Auth-token 和 app-port\"></a>1. 获取remote-Auth-token 和 app-port</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当英雄联盟客户端正在运行时, 它会向我们的localhost暴露一个端口. 我们可以通过remote</p></blockquote>\n<p>Windows下(需要提权)</p>\n<div class=\"language-powershell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">powershell</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E0DEF4\">wmic </span><span style=\"color: #3E8FB0\">PROCESS</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> name</span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #F6C177\">&#39;LeagueClientUx.exe&#39;</span><span style=\"color: #E0DEF4\"> GET commandline </span></span></code></pre></div><p>Linux下</p>\n<div class=\"language-bash\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">bash</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #EA9A97\">ps</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">-eo</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">pid,cmd</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">|</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">grep</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&#39;LeagueClientUx.exe&#39;</span></span></code></pre></div><ul>\n<li><code>ps -eo pid,cmd</code>: 列出所有进程的进程ID（pid）和命令行（cmd）信息。<ul>\n<li>ps: process state的简称</li>\n<li>eo: 表示你可以制定你要的列</li>\n<li>cmd则是命令</li>\n</ul>\n</li>\n<li><code>grep &#39;LeagueClientUx.exe&#39;</code>: 使用 <code>grep</code> 过滤出包含 ‘LeagueClientUx.exe’ 的行，即与你指定的进程相关的信息。</li>\n</ul>\n<p>然后就会得到下面这样子一长串的键值对</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">-riotclient-auth-token=E4z7AQD982BWJO09cYzLrA --riotclient-app-port=40465 --no-rads --disable-self-update --region=NA --locale=en_US --client-config-url=https://clientconfig.rpg.riotgames.com --riotgamesapi-standalone --riotgamesapi-settings=eyJjbGllbnQtY29uZmlnIjp7InVybCI6Imh0dHBzOi8vY2xpZW50Y29uZmlnLnJwZy5yaW90Z2FtZXMuY29tIn0sImRlZmF1bHRfcmVnaW9uIjoiTkEiLCJnbG9iYWxzIjp7InNlc3Npb24taWQiOiIxZWY1NDUxMS03OGQ2LTU3NGUtOTY1MC1lMTFiOTUyMzgwOTQifSwicGF0Y2hsaW5lX2lkIjoibGl2ZSIsInByb2R1Y3QtaW50ZWdyYXRpb24iOnsiYXBwLXVwZGF0ZS1zdGF0dXMiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS51cGRhdGUtc3RhdHVzLmpzb24iLCJoZWFydGJlYXQiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL1Jpb3QgQ2xpZW50L0RhdGEvU2Vzc2lvbnMvMWVmNTQ1MTEtNzhkNi01NzRlLTk2NTAtZTExYjk1MjM4MDk0L0U0ejdBUUQ5ODJCV0pPMDljWXpMckEuaGVhcnRiZWF0Lmpzb24iLCJsb2NrZmlsZSI6IkM6L1Byb2dyYW1EYXRhL1Jpb3QgR2FtZXMvTWV0YWRhdGEvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS9sZWFndWVfb2ZfbGVnZW5kcy5saXZlLmxvY2tmaWxlIiwic2V0dGluZ3MiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS5wcm9kdWN0X3NldHRpbmdzLnlhbWwifSwicHJvZHVjdF9pZCI6ImxlYWd1ZV9vZl9sZWdlbmRzIiwicHVibGlzaGVyIjoicmlvdCIsInJlZ2lvbl9kYXRhIjp7Ik5BIjp7ImF2YWlsYWJsZV9sb2NhbGVzIjpbImNzX0NaIiwiZGVfREUiLCJlbF9HUiIsImVuX0FVIiwiZW5fR0IiLCJlbl9QSCIsImVuX1NHIiwiZW5fVVMiLCJlc19BUiIsImVzX0VTIiwiZXNfTVgiLCJmcl9GUiIsImh1X0hVIiwiaXRfSVQiLCJqYV9KUCIsImtvX0tSIiwicGxfUEwiLCJwdF9CUiIsInJvX1JPIiwicnVfUlUiLCJ0aF9USCIsInRyX1RSIiwidmlfVk4iLCJ6aF9NWSIsInpoX1RXIl0sImRlZmF1bHRfbG9jYWxlIjoiZW5fVVMiLCJyc28iOnsiY2xpZW50IjoibG9sIn19fSwicmlvdGNsaWVudCI6eyJhcHAtcG9ydCI6IjQwNDY1IiwiYXV0aC10b2tlbiI6IkU0ejdBUUQ5ODJCV0pPMDljWXpMckEifSwicmlvdGdhbWVzYXBpIjp7InBlcnNpc3RlbmNlLXBhdGgiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL0xlYWd1ZSBvZiBMZWdlbmRzIn0sInJzb19hdXRoIjp7ImF1dGhvcml6YXRpb24ta2V5IjoiZXcwS0lDQWdJQ0pqYjJSbElqb2dJbVJZWTNoUGJGSnBUMVZXTUZWdFpISlZhMHAzV2xSYWVGVkZhRTFVUjA1U1RVWkZkVmxYYkVWaFdFWklVVmQzTUU5WFJrSmFNbWh6WTBSR1NtTnFiRU5hZHowOUlpd05DaUFnSUNBaVkyOWtaVjkyWlhKcFptbGxjaUk2SUNJNFNVWkxWVk4xVGs5WWFqaHpTM0p0V0RJNGVHSm5aMUkwUmxrNWVtaG9ObVk0VkZReFFuZDJaa3BVZVZCMGJqZGpWbUpvVEZKT2VrdEVVa2RvUkhWVk5sQjVhRnBmV0RKWGRsVlhVMmQzTjFjMFkxVldaeUlOQ24wPSJ9fQ== --rga-lite --remoting-auth-token=WMQXBHuk7kPpoS-QyqXm5A --respawn-command=LeagueClient.exe --respawn-display-name=League of Legends --app-port=40703 --install-directory=C:\\Riot Games\\League of Legends --app-name=LeagueClient --ux-name=LeagueClientUx --ux-helper-name=LeagueClientUxHelper --log-dir=LeagueClient Logs --crash-reporting= --crash-environment=NA1 --app-log-file-path=C:/Riot Games/League of Legends/Logs/LeagueClient Logs/2023-11-10T20-45-00_1740_LeagueClient.log --app-pid=1740 --output-base-dir=C:\\Riot Games\\League of Legends --no-proxy-server --ignore-certificate-errors</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span></code></pre></div><p>拿到了以上输出之后, 我们就可以开始对其进行字符串处理了.</p>\n<p>在使用java的情况下, 我们可以用<code>ProcessBuilder</code>类的start方法来创建一个进程, 执行获取正在运行的英雄联盟客户端的参数.</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">package</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">com</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">anicaaz</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">leaguewarefx</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">utils</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">IOException</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">InputStreamReader</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">util</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">List</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">class</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #9CCFD8\">ExecuteCommand</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">    </span><span style=\"color: #908CAA; font-style: italic\">/**</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * Get the token of current running lcu process.</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * </span><span style=\"color: #3E8FB0; font-style: italic\">@return</span><span style=\"color: #6E6A86; font-style: italic\"> The Remoting-Auth-Token of cmdline output.</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     </span><span style=\"color: #908CAA; font-style: italic\">*/</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">static</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">getRemoteAuthToken</span><span style=\"color: #908CAA\">()</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">ProcessBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">ProcessBuilder</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;bash&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;-c&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">remoteAuthToken</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">try</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">Process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">lcuProcess</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">start</span><span style=\"color: #908CAA\">();</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">BufferedReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">InputStreamReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">lcuProcess</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">getInputStream</span><span style=\"color: #908CAA\">()));</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">while</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">((</span><span style=\"color: #E0DEF4\">line </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">readLine</span><span style=\"color: #908CAA\">())</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">!=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #3E8FB0\">if</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">contains</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--remoting-auth-token&quot;</span><span style=\"color: #908CAA\">))</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    remoteAuthToken </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--remoting-auth-token=&quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">1</span><span style=\"color: #908CAA\">].</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot; &quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">0</span><span style=\"color: #908CAA\">];</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    </span><span style=\"color: #3E8FB0\">break</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">catch</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">IOException</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #C4A7E7; font-style: italic\">e</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">throw</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">RuntimeException</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4\">e</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">return</span><span style=\"color: #E0DEF4\"> remoteAuthToken</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">    </span><span style=\"color: #908CAA; font-style: italic\">/**</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * Get the port that current lcu in running on</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * </span><span style=\"color: #3E8FB0; font-style: italic\">@return</span><span style=\"color: #6E6A86; font-style: italic\"> The port that current lcu in running on</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     </span><span style=\"color: #908CAA; font-style: italic\">*/</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">static</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">getAppPort</span><span style=\"color: #908CAA\">()</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">ProcessBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">ProcessBuilder</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;bash&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;-c&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">appPort</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">try</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">Process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">start</span><span style=\"color: #908CAA\">();</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">BufferedReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">InputStreamReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">process</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">getInputStream</span><span style=\"color: #908CAA\">()));</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">while</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">((</span><span style=\"color: #E0DEF4\">line </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">readLine</span><span style=\"color: #908CAA\">())</span><span style=\"color: #3E8FB0\">!=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #3E8FB0\">if</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">contains</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--app-port&quot;</span><span style=\"color: #908CAA\">))</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    appPort </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--app-port=&quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">1</span><span style=\"color: #908CAA\">].</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot; &quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">0</span><span style=\"color: #908CAA\">];</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    </span><span style=\"color: #3E8FB0\">break</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">catch</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">Exception</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #C4A7E7; font-style: italic\">e</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">throw</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">RuntimeException</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4\">e</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">return</span><span style=\"color: #E0DEF4\"> appPort</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"></span></code></pre></div><p>注意这里拿到了token后, 还需要</p>\n<ol>\n<li>先使用base64加密</li>\n<li>再在前面加上 <code>Basic </code> 注意Basic后面需要有一个空格</li>\n</ol>\n<p>这样,我们就获取好了向LCU API发送请求的请求参数了.</p>\n<h2 id=\"2-LCU-Api文档\"><a href=\"#2-LCU-Api文档\" class=\"headerlink\" title=\"2. LCU Api文档\"></a>2. LCU Api文档</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://lcu.vivide.re/\">https://lcu.vivide.re/</a></p></blockquote>\n<h2 id=\"3-向LCU-API发送第一个请求\"><a href=\"#3-向LCU-API发送第一个请求\" class=\"headerlink\" title=\"3. 向LCU API发送第一个请求.\"></a>3. 向LCU API发送第一个请求.</h2><p>请求参数: Authorization: 处理好的token</p>\n<p>url: <a href=\"https://localhost:{portnumber}/apixxx\">https://localhost:{portnumber}/apixxx</a></p>\n<p>注意 请求必须是https协议</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">https://127.0.0.1:40703/lol-summoner/v1/current-summoner</span></span></code></pre></div><p><img src=\"/../img/2023-07-11-%E6%8E%A2%E7%B4%A2LCU/image-20231110232752929.png\" alt=\"image-20231110232752929\"></p>\n<p>访问接口测试通过后, 就可以用httpclient来模拟请求了.</p>\n<p>Http请求工具类</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">package com.anicaaz.leaguewarefx.utils;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import com.fasterxml.jackson.databind.ObjectMapper;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.AllArgsConstructor;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.Data;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.NoArgsConstructor;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.HttpsURLConnection;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.SSLContext;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.TrustManager;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.X509TrustManager;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.net.HttpURLConnection;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.net.URL;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.util.Map;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@Data</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@AllArgsConstructor</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@NoArgsConstructor</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">public class HttpsUtils &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private String apiUrl;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private String requestMethod;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    public Map&lt;String, Object&gt; sendHttpRequest(String authorizationToken) throws IOException &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 设置请求地址</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        URL url = new URL(apiUrl);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        disableSslVerification();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 打开连接</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 设置请求方法</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.setRequestMethod(requestMethod);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 添加请求头，设置Authorization参数</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.setRequestProperty(&quot;Authorization&quot;, authorizationToken);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 获取响应码</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        int responseCode = connection.getResponseCode();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        System.out.println(&quot;Response Code: &quot; + responseCode);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 读取响应内容并将其映射到Map</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        ObjectMapper objectMapper = new ObjectMapper();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        Map&lt;String, Object&gt; responseMap = objectMapper.readValue(connection.getInputStream(), Map.class);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 关闭连接</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.disconnect();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 返回响应的Map</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        return responseMap;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    public static String constructUrl(String baseUrl, String appPort, String requestUrl) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        return baseUrl + appPort + &quot;/&quot; + requestUrl;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private void disableSslVerification() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        try &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            TrustManager[] trustAllCerts = new TrustManager[]&#123;new X509TrustManager() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                    return null;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public void checkClientTrusted(</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                        java.security.cert.X509Certificate[] certs, String authType) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public void checkServerTrusted(</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                        java.security.cert.X509Certificate[] certs, String authType) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            &#125;&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            sc.init(null, trustAllCerts, new java.security.SecureRandom());</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        &#125; catch (Exception e) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            e.printStackTrace();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span></code></pre></div><p>注意, 这里需要<strong>禁用ssl验证</strong>. 否则会因为没有证书而一直无法发送请求.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\"><a href=\"#LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\" class=\"headerlink\" title=\"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手\"></a>LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手</h1><p><strong>项目依赖</strong></p>\n<div class=\"language-xml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">xml</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\">JSON转Map依赖</span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">com.fasterxml.jackson.core</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">jackson-databind</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">2.13.0</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span></code></pre></div><div class=\"language-xml\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">xml</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\">Lombok依赖</span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA; font-style: italic\">&lt;!--</span><span style=\"color: #6E6A86; font-style: italic\"> https://mvnrepository.com/artifact/org.projectlombok/lombok </span><span style=\"color: #908CAA; font-style: italic\">--&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">org.projectlombok</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">groupId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">lombok</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">artifactId</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">1.18.30</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">version</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #6E6A86\">&lt;</span><span style=\"color: #9CCFD8\">scope</span><span style=\"color: #6E6A86\">&gt;</span><span style=\"color: #E0DEF4\">provided</span><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">scope</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86\">&lt;/</span><span style=\"color: #9CCFD8\">dependency</span><span style=\"color: #6E6A86\">&gt;</span></span>\n<span class=\"line\"></span></code></pre></div><p><strong>注意, 不同于Web项目, JavaFX项目在引入maven依赖后, 还需要将依赖放入module-info中</strong></p>\n<p>比如这样子</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">module</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #9CCFD8\">com</span><span style=\"color: #E0DEF4\">.anicaaz.leaguewarefx </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> javafx.controls;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> lombok;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">requires</span><span style=\"color: #E0DEF4\"> com.fasterxml.jackson.databind;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">opens</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx </span><span style=\"color: #3E8FB0\">to</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">exports</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">exports</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx.controller;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">opens</span><span style=\"color: #E0DEF4\"> com.anicaaz.leaguewarefx.controller </span><span style=\"color: #3E8FB0\">to</span><span style=\"color: #E0DEF4\"> javafx.fxml;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA\">&#125;</span></span></code></pre></div><p><strong>一些有用的资源</strong></p>\n<ol>\n<li>所有版本的资源文件: <a href=\"https://raw.communitydragon.org/\">https://raw.communitydragon.org/</a></li>\n</ol>\n<h2 id=\"1-获取remote-Auth-token-和-app-port\"><a href=\"#1-获取remote-Auth-token-和-app-port\" class=\"headerlink\" title=\"1. 获取remote-Auth-token 和 app-port\"></a>1. 获取remote-Auth-token 和 app-port</h2><blockquote>\n<p>当英雄联盟客户端正在运行时, 它会向我们的localhost暴露一个端口. 我们可以通过remote</p>\n</blockquote>\n<p>Windows下(需要提权)</p>\n<div class=\"language-powershell\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">powershell</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E0DEF4\">wmic </span><span style=\"color: #3E8FB0\">PROCESS</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">WHERE</span><span style=\"color: #E0DEF4\"> name</span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #F6C177\">&#39;LeagueClientUx.exe&#39;</span><span style=\"color: #E0DEF4\"> GET commandline </span></span></code></pre></div><p>Linux下</p>\n<div class=\"language-bash\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">bash</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #EA9A97\">ps</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">-eo</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">pid,cmd</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">|</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">grep</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&#39;LeagueClientUx.exe&#39;</span></span></code></pre></div><ul>\n<li><code>ps -eo pid,cmd</code>: 列出所有进程的进程ID（pid）和命令行（cmd）信息。<ul>\n<li>ps: process state的简称</li>\n<li>eo: 表示你可以制定你要的列</li>\n<li>cmd则是命令</li>\n</ul>\n</li>\n<li><code>grep &#39;LeagueClientUx.exe&#39;</code>: 使用 <code>grep</code> 过滤出包含 ‘LeagueClientUx.exe’ 的行，即与你指定的进程相关的信息。</li>\n</ul>\n<p>然后就会得到下面这样子一长串的键值对</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">-riotclient-auth-token=E4z7AQD982BWJO09cYzLrA --riotclient-app-port=40465 --no-rads --disable-self-update --region=NA --locale=en_US --client-config-url=https://clientconfig.rpg.riotgames.com --riotgamesapi-standalone --riotgamesapi-settings=eyJjbGllbnQtY29uZmlnIjp7InVybCI6Imh0dHBzOi8vY2xpZW50Y29uZmlnLnJwZy5yaW90Z2FtZXMuY29tIn0sImRlZmF1bHRfcmVnaW9uIjoiTkEiLCJnbG9iYWxzIjp7InNlc3Npb24taWQiOiIxZWY1NDUxMS03OGQ2LTU3NGUtOTY1MC1lMTFiOTUyMzgwOTQifSwicGF0Y2hsaW5lX2lkIjoibGl2ZSIsInByb2R1Y3QtaW50ZWdyYXRpb24iOnsiYXBwLXVwZGF0ZS1zdGF0dXMiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS51cGRhdGUtc3RhdHVzLmpzb24iLCJoZWFydGJlYXQiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL1Jpb3QgQ2xpZW50L0RhdGEvU2Vzc2lvbnMvMWVmNTQ1MTEtNzhkNi01NzRlLTk2NTAtZTExYjk1MjM4MDk0L0U0ejdBUUQ5ODJCV0pPMDljWXpMckEuaGVhcnRiZWF0Lmpzb24iLCJsb2NrZmlsZSI6IkM6L1Byb2dyYW1EYXRhL1Jpb3QgR2FtZXMvTWV0YWRhdGEvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS9sZWFndWVfb2ZfbGVnZW5kcy5saXZlLmxvY2tmaWxlIiwic2V0dGluZ3MiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS5wcm9kdWN0X3NldHRpbmdzLnlhbWwifSwicHJvZHVjdF9pZCI6ImxlYWd1ZV9vZl9sZWdlbmRzIiwicHVibGlzaGVyIjoicmlvdCIsInJlZ2lvbl9kYXRhIjp7Ik5BIjp7ImF2YWlsYWJsZV9sb2NhbGVzIjpbImNzX0NaIiwiZGVfREUiLCJlbF9HUiIsImVuX0FVIiwiZW5fR0IiLCJlbl9QSCIsImVuX1NHIiwiZW5fVVMiLCJlc19BUiIsImVzX0VTIiwiZXNfTVgiLCJmcl9GUiIsImh1X0hVIiwiaXRfSVQiLCJqYV9KUCIsImtvX0tSIiwicGxfUEwiLCJwdF9CUiIsInJvX1JPIiwicnVfUlUiLCJ0aF9USCIsInRyX1RSIiwidmlfVk4iLCJ6aF9NWSIsInpoX1RXIl0sImRlZmF1bHRfbG9jYWxlIjoiZW5fVVMiLCJyc28iOnsiY2xpZW50IjoibG9sIn19fSwicmlvdGNsaWVudCI6eyJhcHAtcG9ydCI6IjQwNDY1IiwiYXV0aC10b2tlbiI6IkU0ejdBUUQ5ODJCV0pPMDljWXpMckEifSwicmlvdGdhbWVzYXBpIjp7InBlcnNpc3RlbmNlLXBhdGgiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL0xlYWd1ZSBvZiBMZWdlbmRzIn0sInJzb19hdXRoIjp7ImF1dGhvcml6YXRpb24ta2V5IjoiZXcwS0lDQWdJQ0pqYjJSbElqb2dJbVJZWTNoUGJGSnBUMVZXTUZWdFpISlZhMHAzV2xSYWVGVkZhRTFVUjA1U1RVWkZkVmxYYkVWaFdFWklVVmQzTUU5WFJrSmFNbWh6WTBSR1NtTnFiRU5hZHowOUlpd05DaUFnSUNBaVkyOWtaVjkyWlhKcFptbGxjaUk2SUNJNFNVWkxWVk4xVGs5WWFqaHpTM0p0V0RJNGVHSm5aMUkwUmxrNWVtaG9ObVk0VkZReFFuZDJaa3BVZVZCMGJqZGpWbUpvVEZKT2VrdEVVa2RvUkhWVk5sQjVhRnBmV0RKWGRsVlhVMmQzTjFjMFkxVldaeUlOQ24wPSJ9fQ== --rga-lite --remoting-auth-token=WMQXBHuk7kPpoS-QyqXm5A --respawn-command=LeagueClient.exe --respawn-display-name=League of Legends --app-port=40703 --install-directory=C:\\Riot Games\\League of Legends --app-name=LeagueClient --ux-name=LeagueClientUx --ux-helper-name=LeagueClientUxHelper --log-dir=LeagueClient Logs --crash-reporting= --crash-environment=NA1 --app-log-file-path=C:/Riot Games/League of Legends/Logs/LeagueClient Logs/2023-11-10T20-45-00_1740_LeagueClient.log --app-pid=1740 --output-base-dir=C:\\Riot Games\\League of Legends --no-proxy-server --ignore-certificate-errors</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span></code></pre></div><p>拿到了以上输出之后, 我们就可以开始对其进行字符串处理了.</p>\n<p>在使用java的情况下, 我们可以用<code>ProcessBuilder</code>类的start方法来创建一个进程, 执行获取正在运行的英雄联盟客户端的参数.</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #3E8FB0\">package</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">com</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">anicaaz</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">leaguewarefx</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">utils</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">IOException</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">io</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">InputStreamReader</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">import java</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">util</span><span style=\"color: #908CAA\">.</span><span style=\"color: #3E8FB0\">List</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">class</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #9CCFD8\">ExecuteCommand</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">    </span><span style=\"color: #908CAA; font-style: italic\">/**</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * Get the token of current running lcu process.</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * </span><span style=\"color: #3E8FB0; font-style: italic\">@return</span><span style=\"color: #6E6A86; font-style: italic\"> The Remoting-Auth-Token of cmdline output.</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     </span><span style=\"color: #908CAA; font-style: italic\">*/</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">static</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">getRemoteAuthToken</span><span style=\"color: #908CAA\">()</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">ProcessBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">ProcessBuilder</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;bash&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;-c&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">remoteAuthToken</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">try</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">Process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">lcuProcess</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">start</span><span style=\"color: #908CAA\">();</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">BufferedReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">InputStreamReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">lcuProcess</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">getInputStream</span><span style=\"color: #908CAA\">()));</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">while</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">((</span><span style=\"color: #E0DEF4\">line </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">readLine</span><span style=\"color: #908CAA\">())</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">!=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #3E8FB0\">if</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">contains</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--remoting-auth-token&quot;</span><span style=\"color: #908CAA\">))</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    remoteAuthToken </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--remoting-auth-token=&quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">1</span><span style=\"color: #908CAA\">].</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot; &quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">0</span><span style=\"color: #908CAA\">];</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    </span><span style=\"color: #3E8FB0\">break</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">catch</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">IOException</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #C4A7E7; font-style: italic\">e</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">throw</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">RuntimeException</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4\">e</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">return</span><span style=\"color: #E0DEF4\"> remoteAuthToken</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">    </span><span style=\"color: #908CAA; font-style: italic\">/**</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * Get the port that current lcu in running on</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     * </span><span style=\"color: #3E8FB0; font-style: italic\">@return</span><span style=\"color: #6E6A86; font-style: italic\"> The port that current lcu in running on</span></span>\n<span class=\"line\"><span style=\"color: #6E6A86; font-style: italic\">     </span><span style=\"color: #908CAA; font-style: italic\">*/</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #3E8FB0\">public</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">static</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">getAppPort</span><span style=\"color: #908CAA\">()</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">ProcessBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">ProcessBuilder</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;bash&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;-c&quot;</span><span style=\"color: #908CAA\">,</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #F6C177\">&quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">appPort</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">try</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">Process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">process</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">processBuilder</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">start</span><span style=\"color: #908CAA\">();</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">String</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">BufferedReader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">BufferedReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">InputStreamReader</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">process</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">getInputStream</span><span style=\"color: #908CAA\">()));</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">while</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">((</span><span style=\"color: #E0DEF4\">line </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">reader</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">readLine</span><span style=\"color: #908CAA\">())</span><span style=\"color: #3E8FB0\">!=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">null</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #3E8FB0\">if</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">contains</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--app-port&quot;</span><span style=\"color: #908CAA\">))</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    appPort </span><span style=\"color: #3E8FB0\">=</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #E0DEF4; font-style: italic\">line</span><span style=\"color: #908CAA\">.</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot;--app-port=&quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">1</span><span style=\"color: #908CAA\">].</span><span style=\"color: #EA9A97\">split</span><span style=\"color: #908CAA\">(</span><span style=\"color: #F6C177\">&quot; &quot;</span><span style=\"color: #908CAA\">)[</span><span style=\"color: #EA9A97\">0</span><span style=\"color: #908CAA\">];</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                    </span><span style=\"color: #3E8FB0\">break</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">                </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">catch</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">(</span><span style=\"color: #3E8FB0\">Exception</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #C4A7E7; font-style: italic\">e</span><span style=\"color: #908CAA\">)</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #908CAA\">&#123;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">            </span><span style=\"color: #3E8FB0\">throw</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #3E8FB0\">new</span><span style=\"color: #E0DEF4\"> </span><span style=\"color: #EA9A97\">RuntimeException</span><span style=\"color: #908CAA\">(</span><span style=\"color: #E0DEF4\">e</span><span style=\"color: #908CAA\">);</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">        </span><span style=\"color: #3E8FB0\">return</span><span style=\"color: #E0DEF4\"> appPort</span><span style=\"color: #908CAA\">;</span></span>\n<span class=\"line\"><span style=\"color: #E0DEF4\">    </span><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #908CAA\">&#125;</span></span>\n<span class=\"line\"></span></code></pre></div><p>注意这里拿到了token后, 还需要</p>\n<ol>\n<li>先使用base64加密</li>\n<li>再在前面加上 <code>Basic </code> 注意Basic后面需要有一个空格</li>\n</ol>\n<p>这样,我们就获取好了向LCU API发送请求的请求参数了.</p>\n<h2 id=\"2-LCU-Api文档\"><a href=\"#2-LCU-Api文档\" class=\"headerlink\" title=\"2. LCU Api文档\"></a>2. LCU Api文档</h2><blockquote>\n<p><a href=\"https://lcu.vivide.re/\">https://lcu.vivide.re/</a></p>\n</blockquote>\n<h2 id=\"3-向LCU-API发送第一个请求\"><a href=\"#3-向LCU-API发送第一个请求\" class=\"headerlink\" title=\"3. 向LCU API发送第一个请求.\"></a>3. 向LCU API发送第一个请求.</h2><p>请求参数: Authorization: 处理好的token</p>\n<p>url: <a href=\"https://localhost:{portnumber}/apixxx\">https://localhost:{portnumber}/apixxx</a></p>\n<p>注意 请求必须是https协议</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">https://127.0.0.1:40703/lol-summoner/v1/current-summoner</span></span></code></pre></div><p><img src=\"/../img/2023-07-11-%E6%8E%A2%E7%B4%A2LCU/image-20231110232752929.png\" alt=\"image-20231110232752929\"></p>\n<p>访问接口测试通过后, 就可以用httpclient来模拟请求了.</p>\n<p>Http请求工具类</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">package com.anicaaz.leaguewarefx.utils;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import com.fasterxml.jackson.databind.ObjectMapper;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.AllArgsConstructor;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.Data;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import lombok.NoArgsConstructor;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.HttpsURLConnection;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.SSLContext;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.TrustManager;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import javax.net.ssl.X509TrustManager;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.io.IOException;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.net.HttpURLConnection;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.net.URL;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">import java.util.Map;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@Data</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@AllArgsConstructor</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@NoArgsConstructor</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">public class HttpsUtils &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private String apiUrl;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private String requestMethod;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    public Map&lt;String, Object&gt; sendHttpRequest(String authorizationToken) throws IOException &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 设置请求地址</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        URL url = new URL(apiUrl);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        disableSslVerification();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 打开连接</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 设置请求方法</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.setRequestMethod(requestMethod);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 添加请求头，设置Authorization参数</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.setRequestProperty(&quot;Authorization&quot;, authorizationToken);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 获取响应码</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        int responseCode = connection.getResponseCode();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        System.out.println(&quot;Response Code: &quot; + responseCode);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 读取响应内容并将其映射到Map</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        ObjectMapper objectMapper = new ObjectMapper();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        Map&lt;String, Object&gt; responseMap = objectMapper.readValue(connection.getInputStream(), Map.class);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 关闭连接</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        connection.disconnect();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        // 返回响应的Map</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        return responseMap;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    public static String constructUrl(String baseUrl, String appPort, String requestUrl) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        return baseUrl + appPort + &quot;/&quot; + requestUrl;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    private void disableSslVerification() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        try &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            TrustManager[] trustAllCerts = new TrustManager[]&#123;new X509TrustManager() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                    return null;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public void checkClientTrusted(</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                        java.security.cert.X509Certificate[] certs, String authType) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                public void checkServerTrusted(</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                        java.security.cert.X509Certificate[] certs, String authType) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">                &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            &#125;&#125;;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;);</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            sc.init(null, trustAllCerts, new java.security.SecureRandom());</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        &#125; catch (Exception e) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">            e.printStackTrace();</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"></span></span></code></pre></div><p>注意, 这里需要<strong>禁用ssl验证</strong>. 否则会因为没有证书而一直无法发送请求.</p>\n"},{"title":"键盘上的符号对应的英文名称","date":"2023-11-10T05:00:00.000Z","_content":"\n> 一次惨痛的交流经历: 写算法时候得边写边讲解, 结果不知道键盘上的诸多符号怎么用英文表达. 遂搜了一下常见的符号用英文的表达方式.\n\n\n\n```\n! 叹号 exclamation mark/bang\n? 问号 question mark\n, 逗号 comma\n. 点号 dot/period/point\n: 冒号 colon\n; 分号 semicolon\n” 双引号 quotation marks/double quote\n‘ 单引号/撇号 apostrophe/single quote\n` 重音号 backquote/grave accent\n* 星号 asterisk/star\n+ 加号 plus sign\n- 减号/横线 hyphen/dash/minus sign/\n= 等号 equal sign\n/ 斜线 slash\n\\ 反斜线 backslash/escape\n| 竖线 bar/pipe/vertical bar\n_ 下划线 underline/underscore\n$ 美元符号 dollar sign\n@ at at sign\n# 井号 crosshatch/sharp/hash\n% 百分号 percent sign/mod\n& and/和/兼 and/ampersand\n^ 折音号 circumflex/caret\n~ 波浪号 tilde\n{} （左右）花括号/大括号 (left/right|open/close) braces\n[] （左右）方括号/中括号 (left/right|open/close) brackets\n() （左右）圆括号/小括号 (left/right|open/close) parentheses\n<> 尖括号 angle brackets\n< 大于号 less than\n> 小于号 greater than\n```\n\n\n\n来源:https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu键盘上所有特殊符号的英文读法 ","source":"_posts/键盘上的符号对应的英文名称.md","raw":"---\ntitle: 键盘上的符号对应的英文名称\ndate: 2023-11-10\n---\n\n> 一次惨痛的交流经历: 写算法时候得边写边讲解, 结果不知道键盘上的诸多符号怎么用英文表达. 遂搜了一下常见的符号用英文的表达方式.\n\n\n\n```\n! 叹号 exclamation mark/bang\n? 问号 question mark\n, 逗号 comma\n. 点号 dot/period/point\n: 冒号 colon\n; 分号 semicolon\n” 双引号 quotation marks/double quote\n‘ 单引号/撇号 apostrophe/single quote\n` 重音号 backquote/grave accent\n* 星号 asterisk/star\n+ 加号 plus sign\n- 减号/横线 hyphen/dash/minus sign/\n= 等号 equal sign\n/ 斜线 slash\n\\ 反斜线 backslash/escape\n| 竖线 bar/pipe/vertical bar\n_ 下划线 underline/underscore\n$ 美元符号 dollar sign\n@ at at sign\n# 井号 crosshatch/sharp/hash\n% 百分号 percent sign/mod\n& and/和/兼 and/ampersand\n^ 折音号 circumflex/caret\n~ 波浪号 tilde\n{} （左右）花括号/大括号 (left/right|open/close) braces\n[] （左右）方括号/中括号 (left/right|open/close) brackets\n() （左右）圆括号/小括号 (left/right|open/close) parentheses\n<> 尖括号 angle brackets\n< 大于号 less than\n> 小于号 greater than\n```\n\n\n\n来源:https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu键盘上所有特殊符号的英文读法 ","slug":"键盘上的符号对应的英文名称","published":1,"updated":"2023-11-11T04:37:06.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clotk2lxm0001j9jp3w0m8zbh","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一次惨痛的交流经历: 写算法时候得边写边讲解, 结果不知道键盘上的诸多符号怎么用英文表达. 遂搜了一下常见的符号用英文的表达方式.</p></blockquote>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">! 叹号 exclamation mark/bang</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">? 问号 question mark</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">, 逗号 comma</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">. 点号 dot/period/point</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">: 冒号 colon</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">; 分号 semicolon</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">” 双引号 quotation marks/double quote</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">‘ 单引号/撇号 apostrophe/single quote</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">` 重音号 backquote/grave accent</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">* 星号 asterisk/star</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">+ 加号 plus sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">- 减号/横线 hyphen/dash/minus sign/</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">= 等号 equal sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">/ 斜线 slash</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">\\ 反斜线 backslash/escape</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">| 竖线 bar/pipe/vertical bar</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">_ 下划线 underline/underscore</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">$ 美元符号 dollar sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@ at at sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"># 井号 crosshatch/sharp/hash</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">% 百分号 percent sign/mod</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&amp; and/和/兼 and/ampersand</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">^ 折音号 circumflex/caret</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">~ 波浪号 tilde</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">[] （左右）方括号/中括号 (left/right|open/close) brackets</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">() （左右）圆括号/小括号 (left/right|open/close) parentheses</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&lt;&gt; 尖括号 angle brackets</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&lt; 大于号 less than</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&gt; 小于号 greater than</span></span></code></pre></div><p>来源:<a href=\"https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu%E9%94%AE%E7%9B%98%E4%B8%8A%E6%89%80%E6%9C%89%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E8%AF%BB%E6%B3%95\">https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu键盘上所有特殊符号的英文读法</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一次惨痛的交流经历: 写算法时候得边写边讲解, 结果不知道键盘上的诸多符号怎么用英文表达. 遂搜了一下常见的符号用英文的表达方式.</p>\n</blockquote>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">! 叹号 exclamation mark/bang</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">? 问号 question mark</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">, 逗号 comma</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">. 点号 dot/period/point</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">: 冒号 colon</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">; 分号 semicolon</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">” 双引号 quotation marks/double quote</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">‘ 单引号/撇号 apostrophe/single quote</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">` 重音号 backquote/grave accent</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">* 星号 asterisk/star</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">+ 加号 plus sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">- 减号/横线 hyphen/dash/minus sign/</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">= 等号 equal sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">/ 斜线 slash</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">\\ 反斜线 backslash/escape</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">| 竖线 bar/pipe/vertical bar</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">_ 下划线 underline/underscore</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">$ 美元符号 dollar sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">@ at at sign</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"># 井号 crosshatch/sharp/hash</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">% 百分号 percent sign/mod</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&amp; and/和/兼 and/ampersand</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">^ 折音号 circumflex/caret</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">~ 波浪号 tilde</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">[] （左右）方括号/中括号 (left/right|open/close) brackets</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">() （左右）圆括号/小括号 (left/right|open/close) parentheses</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&lt;&gt; 尖括号 angle brackets</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&lt; 大于号 less than</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">&gt; 小于号 greater than</span></span></code></pre></div><p>来源:<a href=\"https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu%E9%94%AE%E7%9B%98%E4%B8%8A%E6%89%80%E6%9C%89%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%8B%B1%E6%96%87%E8%AF%BB%E6%B3%95\">https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu键盘上所有特殊符号的英文读法</a> </p>\n"},{"title":"Leetcode刷题日记","date":"2023-11-10T05:00:00.000Z","_content":"\n> 金鱼似的大脑实在是容纳不了太长的记忆曲线:fish:. 这几天在回顾前面刷的前150道LC, 发现除了easy以外的,还有少数medium, 其他的要么不是bug free要么就是完全没头绪. 从今天开始, :calendar:每天保持10道LC + 解析, 方便日后重新捡起.\n\n","source":"_posts/leetcode刷题日记.md","raw":"---\ntitle: Leetcode刷题日记\ndate: 2023-11-10\n---\n\n> 金鱼似的大脑实在是容纳不了太长的记忆曲线:fish:. 这几天在回顾前面刷的前150道LC, 发现除了easy以外的,还有少数medium, 其他的要么不是bug free要么就是完全没头绪. 从今天开始, :calendar:每天保持10道LC + 解析, 方便日后重新捡起.\n\n","slug":"leetcode刷题日记","published":1,"updated":"2023-11-13T23:06:15.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloxikmym00005tjp03inb5jw","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>金鱼似的大脑实在是容纳不了太长的记忆曲线:fish:. 这几天在回顾前面刷的前150道LC, 发现除了easy以外的,还有少数medium, 其他的要么不是bug free要么就是完全没头绪. 从今天开始, :calendar:每天保持10道LC + 解析, 方便日后重新捡起.</p></blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>金鱼似的大脑实在是容纳不了太长的记忆曲线:fish:. 这几天在回顾前面刷的前150道LC, 发现除了easy以外的,还有少数medium, 其他的要么不是bug free要么就是完全没头绪. 从今天开始, :calendar:每天保持10道LC + 解析, 方便日后重新捡起.</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cln44k4un0006awhzcq6mbvan","category_id":"cln44k4uj0003awhza2tj9a8s","_id":"cln44k4ut000cawhz36tv58lk"},{"post_id":"cln44k4u90000awhz59cd0ya0","category_id":"cln44k4uj0003awhza2tj9a8s","_id":"cln44k4ut000fawhz0ht8hbqi"},{"post_id":"cln44k4uh0002awhz8q097wnl","category_id":"cln44k4up0008awhz4ycq8i2i","_id":"cln44k4uu000hawhz9x4v80u3"},{"post_id":"cln44k4um0005awhzgxun60y3","category_id":"cln44k4ut000dawhzbljg1vrr","_id":"cln44k4uw000mawhz2lju932q"},{"post_id":"cln44k4ur000bawhzbmaza1d4","category_id":"cln44k4uw000lawhzej8a7t7v","_id":"cln44k4uy000rawhzbrry6g7p"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4up0008awhz4ycq8i2i","_id":"cln44k4v5001aawhzb7ijbsw3"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4ux000pawhz4bxc6w3c","_id":"cln44k4v6001cawhz668n6h15"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4uy000tawhz66ha5aan","_id":"cln44k4v6001dawhz084b4qus"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4uz000vawhz9kqefp0m","_id":"cln44k4v6001fawhzglnx48bb"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4v0000yawhz2tq0bk3j","_id":"cln44k4v6001gawhz2ma99yv6"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4v10010awhzgy0g9osq","_id":"cln44k4v7001iawhz48y1ber8"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4v30013awhzfr8qdu5u","_id":"cln44k4v7001kawhz8641987y"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4v30015awhz3fl1f8y7","_id":"cln44k4v7001mawhz7y5bdkv5"},{"post_id":"cln44k4uo0007awhz1ecxe44t","category_id":"cln44k4v40018awhz2fe35x60","_id":"cln44k4v8001oawhzeerv9szu"},{"post_id":"clnier4pp0000i8hzh2cw7i8q","category_id":"cln44k4uj0003awhza2tj9a8s","_id":"clnier4px0002i8hzcjnlddpd"},{"post_id":"clnmsn9i40000yohz2w6h1823","category_id":"cln44k4uj0003awhza2tj9a8s","_id":"clnmsn9i90002yohzelr66qip"},{"post_id":"clnmsn9ib0003yohz9qoj4rtb","category_id":"cln44k4up0008awhz4ycq8i2i","_id":"clnmsn9ie0005yohz0ggw6gmw"}],"PostTag":[{"post_id":"cln44k4u90000awhz59cd0ya0","tag_id":"cln44k4ul0004awhz2j0z2gqv","_id":"cln44k4ur000aawhz83ezc37j"},{"post_id":"cln44k4uh0002awhz8q097wnl","tag_id":"cln44k4uq0009awhz9gzu0vn8","_id":"cln44k4ut000gawhz3xju5z5o"},{"post_id":"cln44k4um0005awhzgxun60y3","tag_id":"cln44k4ut000eawhzabl120w8","_id":"cln44k4uv000kawhzct628f3o"},{"post_id":"cln44k4un0006awhzcq6mbvan","tag_id":"cln44k4uu000jawhz01lrfylc","_id":"cln44k4ux000oawhz2iqi20p0"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4ut000eawhzabl120w8","_id":"cln44k4v7001jawhz9hwn3yb0"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4ux000qawhz7g1da602","_id":"cln44k4v7001lawhz0fm3hiz7"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4uy000sawhzd2xef5i3","_id":"cln44k4v7001nawhz8vbo7hc7"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4uz000uawhz27wf1ihe","_id":"cln44k4v8001pawhz4as95sdh"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v0000wawhz7tc8cm6v","_id":"cln44k4v8001qawhzboxlfob5"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v0000xawhz65bngm65","_id":"cln44k4v8001rawhzbzpo0q2g"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v1000zawhz93pb0aey","_id":"cln44k4v8001sawhzf84ueuqz"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v20011awhzhlbsdsj3","_id":"cln44k4v8001tawhzfayzdsyb"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v20012awhz5r3o45yi","_id":"cln44k4v8001uawhzfydlgxoa"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v30014awhzcuozaxvc","_id":"cln44k4v8001vawhz8gm77n2b"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v40016awhzac1q1rsw","_id":"cln44k4v8001wawhz3l1zfi3j"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v40017awhz3rpqhscx","_id":"cln44k4v8001xawhzg20yfw06"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v50019awhz8u8beyye","_id":"cln44k4v8001yawhzd97w0t3o"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v5001bawhz9vzh9vm5","_id":"cln44k4v8001zawhz04zsc20k"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4v6001eawhz2lvo6nnh","_id":"cln44k4v80020awhz10p3emj7"},{"post_id":"cln44k4uo0007awhz1ecxe44t","tag_id":"cln44k4ul0004awhz2j0z2gqv","_id":"cln44k4v80021awhzet0d5uyb"},{"post_id":"cln44k4ur000bawhzbmaza1d4","tag_id":"cln44k4uz000uawhz27wf1ihe","_id":"cln44k4v80022awhzhz5l4bwg"},{"post_id":"clnier4pp0000i8hzh2cw7i8q","tag_id":"clnier4pv0001i8hzhutfdrks","_id":"clnier4py0003i8hzgl135tl7"},{"post_id":"clnmsn9i40000yohz2w6h1823","tag_id":"clnier4pv0001i8hzhutfdrks","_id":"clnmsn9i90001yohz8ubxc1zs"},{"post_id":"clnmsn9ib0003yohz9qoj4rtb","tag_id":"clnmsn9ic0004yohz76qe84wi","_id":"clnmsn9ig0008yohz63et1ae2"},{"post_id":"clnmsn9ib0003yohz9qoj4rtb","tag_id":"clnmsn9if0006yohzcxg7eu74","_id":"clnmsn9ig0009yohz4lt6fz7x"},{"post_id":"clnmsn9ib0003yohz9qoj4rtb","tag_id":"clnmsn9if0007yohzf8ek6u82","_id":"clnmsn9ig000ayohzfhwtgo3q"}],"Tag":[{"name":"Selenium","_id":"cln44k4ul0004awhz2j0z2gqv"},{"name":"Java多线程","_id":"cln44k4uq0009awhz9gzu0vn8"},{"name":"Spring","_id":"cln44k4ut000eawhzabl120w8"},{"name":"TestNG","_id":"cln44k4uu000jawhz01lrfylc"},{"name":"SpringBoot","_id":"cln44k4ux000qawhz7g1da602"},{"name":"Mybatis(Plus)","_id":"cln44k4uy000sawhzd2xef5i3"},{"name":"Mysql","_id":"cln44k4uz000uawhz27wf1ihe"},{"name":"Redis","_id":"cln44k4v0000wawhz7tc8cm6v"},{"name":"Rabbitmq","_id":"cln44k4v0000xawhz65bngm65"},{"name":"Kafka","_id":"cln44k4v1000zawhz93pb0aey"},{"name":"Docker","_id":"cln44k4v20011awhzhlbsdsj3"},{"name":"K8s","_id":"cln44k4v20012awhz5r3o45yi"},{"name":"xxl-job","_id":"cln44k4v30014awhzcuozaxvc"},{"name":"Javascript基础","_id":"cln44k4v40016awhzac1q1rsw"},{"name":"Vue2","_id":"cln44k4v40017awhz3rpqhscx"},{"name":"React.js","_id":"cln44k4v50019awhz8u8beyye"},{"name":"Electron.js","_id":"cln44k4v5001bawhz9vzh9vm5"},{"name":"Flutter","_id":"cln44k4v6001eawhz2lvo6nnh"},{"name":"软件测试","_id":"clnier4pv0001i8hzhutfdrks"},{"name":"Java基础","_id":"clnmsn9ic0004yohz76qe84wi"},{"name":"Java","_id":"clnmsn9if0006yohzcxg7eu74"},{"name":"Lambda表达式","_id":"clnmsn9if0007yohzf8ek6u82"}]}}