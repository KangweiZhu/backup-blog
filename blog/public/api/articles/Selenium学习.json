{"title":"Web自动化测试快速入门(Java + Selenium 4)","uid":"d6d38527940b56c092c8f8da1f15978f","slug":"Selenium学习","date":"2023-09-28T01:19:00.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/Selenium学习.json","keywords":"Kangwei Zhu's Blog","cover":[],"content":"<h2 id=\"1-Selenium官方文档\"><a href=\"#1-Selenium官方文档\" class=\"headerlink\" title=\"1. Selenium官方文档\"></a>1. Selenium官方文档</h2><blockquote>\n<p><a href=\"https://www.selenium.dev/documentation/\">https://www.selenium.dev/documentation/</a></p>\n</blockquote>\n<h2 id=\"2-第一个Selenium测试案例\"><a href=\"#2-第一个Selenium测试案例\" class=\"headerlink\" title=\"2. 第一个Selenium测试案例\"></a>2. 第一个Selenium测试案例</h2><p>使用idea，新建maven项目，导入junit和selenium依赖。</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.anicaaz&lt;/groupId&gt;\n    &lt;artifactId&gt;Selenium-Learning&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;!-- &lt;=左键点这里的selenium-Java --&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n            &lt;version&gt;5.10.0&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n<p>网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被<artifactId>标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-ie-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-safari-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n</code></pre>\n<blockquote>\n<p>第一个测试案例，测试title名称。</p>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest &#123;\n\n    @Test\n    public void firstTest() &#123;\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(&quot;https://www.baidu.com&quot;);//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, &quot;百度一下，你就知道&quot;);//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"3-元素定位方式\"><a href=\"#3-元素定位方式\" class=\"headerlink\" title=\"3. 元素定位方式\"></a>3. 元素定位方式</h2><blockquote>\n<p>在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：</p>\n<ol>\n<li>找到要测试的元素</li>\n<li>对其进行测试</li>\n</ol>\n</blockquote>\n<p>在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。</p>\n<ul>\n<li>找什么： 找属性、标签、层级、路径</li>\n<li>怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。</li>\n</ul>\n<p><strong>在Selenium中，元素定位方式，标准来讲，是以下八种</strong></p>\n<h3 id=\"3-1-id-（元素属性）\"><a href=\"#3-1-id-（元素属性）\" class=\"headerlink\" title=\"3.1 id （元素属性）\"></a>3.1 id （元素属性）</h3><p>id定位就是通过元素的id属性来定位元素。</p>\n<p>HTML规定id属性在整个Html文档中是<strong>唯一</strong>的</p>\n<p>使用id定位的前提是元素<strong>得有id属性</strong>。</p>\n<p>具体怎么用，直接看源码。</p>\n<p><img src=\"/../img/image-20230924004300712.png\" alt=\"image-20230924004300712\"></p>\n<p>所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：</p>\n<p><img src=\"/../img/image-20230924004452513.png\" alt=\"image-20230924004452513\"></p>\n<p>我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？</p>\n<p><img src=\"/./../img/image-20230924004606568.png\" alt=\"image-20230924004606568\"></p>\n<p>粗略看了一眼，By类是一个抽象类，By的具体实现应该是<strong>静态内部类</strong>实现的。以后分析。</p>\n<p>找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行<strong>click，sendkeys</strong>等操作。我们用.var来看一下这个对象的名字是什么。<img src=\"/../img/image-20230924004941048.png\" alt=\"image-20230924004941048\"></p>\n<p>结果发现是WebElement接口，点进去，把方法看明白就行。</p>\n<p><img src=\"/../img/image-20230924005037622.png\" alt=\"image-20230924005037622\"></p>\n<p>完整demo</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo &#123;\n    //通过\n    @Test\n    public void idTest() throws InterruptedException &#123;\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        //查找用户名元素\n        By by = By.id(&quot;userA&quot;);\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(&quot;passwordA&quot;));\n        //用户名输入框，输入admin\n        username.sendKeys(&quot;admin&quot;);\n        //密码输入框，输入123456\n        password.sendKeys(&quot;123456&quot;);\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>链式写会更简洁。</p>\n<h3 id=\"3-2-name-（元素属性）\"><a href=\"#3-2-name-（元素属性）\" class=\"headerlink\" title=\"3.2 name （元素属性）\"></a>3.2 name （元素属性）</h3><p>name在html中可重复。</p>\n<p>使用前提是元素得有name属性。</p>\n<pre><code class=\"java\">    @Test\n    public void nameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        driver.findElement(By.name(&quot;userA&quot;)).sendKeys(&quot;admin&quot;);\n        driver.findElement(By.name(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-3-class-name-（元素属性）\"><a href=\"#3-3-class-name-（元素属性）\" class=\"headerlink\" title=\"3.3 class_name （元素属性）\"></a>3.3 class_name （元素属性）</h3><p>和name、id方式几乎一致</p>\n<p>如果class有多个属性值，只能使用其中一个。</p>\n<pre><code class=\"java\">    @Test\n    public void classTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(&quot;telA&quot;)).sendKeys(&quot;18611111111&quot;);\n        /*driver.findElement(By.className(&quot;emailA&quot;)).sendKeys(&quot;anicaazhu@gmail.com&quot;);*/\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-4-tag-name-（标签名称）\"><a href=\"#3-4-tag-name-（标签名称）\" class=\"headerlink\" title=\"3.4 tag_name （标签名称）\"></a>3.4 tag_name （标签名称）</h3><p>和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。</p>\n<p>当然还是有办法可以找到第二个相同类型的tag的。<code>driver.findElements(By by)</code>会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。</p>\n<pre><code class=\"java\">    @Test\n    public void tagNameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(&quot;input&quot;)).sendKeys(&quot;TagName Test&quot;);\n        driver.findElements(By.tagName(&quot;input&quot;)).get(1).sendKeys(&quot;Second Input Tag Test&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-5-link-text-（超链接）\"><a href=\"#3-5-link-text-（超链接）\" class=\"headerlink\" title=\"3.5 link_text （超链接）\"></a>3.5 link_text （<a>超链接）</h3><p>文本必须为全部匹配</p>\n<p>必须只能定位a标签</p>\n<pre><code class=\"html\">&lt;a&gt;aaaa&lt;/a&gt;\n</code></pre>\n<p>匹配的就是这个”aaaa’</p>\n<pre><code class=\"java\">    @Test\n    public void linkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-6-partial-link-text-超链接，模糊查找\"><a href=\"#3-6-partial-link-text-超链接，模糊查找\" class=\"headerlink\" title=\"3.6 partial_link_text (超链接，模糊查找)\"></a>3.6 partial_link_text (<a>超链接，模糊查找)</h3><p>和link_text唯一区别就是可以模糊查。</p>\n<p>模糊查并不是出现过相同字符就可以。必须是<strong>缺少</strong>才行。这么说可能有点抽象，举个例子：</p>\n<blockquote>\n<p>我们要找的linktext是 “aaaaa”.</p>\n<p>那么。partialLinkText可以为“aaaaa”(完全一致)，也可以为”a”, “aaa”, “aa”, “aaaa”. 但是，不可以是“aaaaaa”或”aab”这种。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void partialLinkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(&quot;访问 新浪网站&quot;)).click();//不可以\n        driver.findElement(By.partialLinkText(&quot;访问&quot;)).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"3-7-XPath-（基于元素路径）\"><a href=\"#3-7-XPath-（基于元素路径）\" class=\"headerlink\" title=\"3.7 XPath （基于元素路径）\"></a>3.7 XPath （基于元素路径）</h3><p>之所以用XPath和CSS，是因为万一<strong>前六种情况都不能用</strong>，就白瞎了。</p>\n<p>比如这种情况</p>\n<p><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</code></p>\n<p>没有id，没有name，没有class。</p>\n<p>tag吧，万一他不是该页面第一次出现的，也不好找。</p>\n<p>link_text和partiall_link_text，专门给a标签用的，input不对口。</p>\n<p>所以只能能用XPath和CSS方法来定位。</p>\n<blockquote>\n<p>XPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。</p>\n<p>HTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。</p>\n<p>各种文件的作用：</p>\n<ul>\n<li>XML的重点在于数据的存储和传递。常用于软件配置。</li>\n<li>HTML显示元素</li>\n<li>CSS控制显示元素的样式</li>\n</ul>\n</blockquote>\n<p>XPath偷懒，不手写：</p>\n<p>​\t<img src=\"/../img/image-20230924203236506.png\" alt=\"image-20230924203236506\"></p>\n<h4 id=\"3-7-1-路径定位：绝对路径\"><a href=\"#3-7-1-路径定位：绝对路径\" class=\"headerlink\" title=\"3.7.1 路径定位：绝对路径\"></a>3.7.1 路径定位：绝对路径</h4><blockquote>\n<p>必须从html开始。格式：<code>/html/.../...</code></p>\n</blockquote>\n<h4 id=\"3-7-2-路径定位：相对路径\"><a href=\"#3-7-2-路径定位：相对路径\" class=\"headerlink\" title=\"3.7.2 路径定位：相对路径\"></a>3.7.2 路径定位：相对路径</h4><blockquote>\n<p>必须以<code>//元素名</code>开头</p>\n<p>不知道元素名，用*代替</p>\n<p>开发时建议相对路径：如果层级变化，绝对路径大概率会失效。</p>\n</blockquote>\n<pre><code class=\"java\">    @Test\n    public void xPathTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = &quot;/html/body/form/div/fieldset/p[1]/input&quot;;\n        driver.findElement(By.xpath(absPath)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = &quot;//p[@id=&#39;p1&#39;]/input&quot;;//\n       //p[@id=&quot;p1&quot;]/input  这样可以    //*[@id=&quot;userA&quot;]也可以  注意java“”中的“”要用\\\\隔开。即\\&quot;p1\\&quot;，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-7-3-XPath扩展\"><a href=\"#3-7-3-XPath扩展\" class=\"headerlink\" title=\"3.7.3 XPath扩展\"></a>3.7.3 XPath扩展</h4><blockquote>\n<p>对于被标签夹着的文本。可以用<code>//*[text()=&#39;字符&#39;]</code>来定位</p>\n</blockquote>\n<blockquote>\n<p>对于属性中含有xxx元素，可以用&#x2F;&#x2F;<code>*[contains(@attribute, &#39;属性名&#39;)]</code>. 属性名可以模糊。</p>\n<p>对于属性以xxx开头的元素，可以用<code>//*[start-with(@属性类型, &#39;属性名&#39;)]</code>. 可以模糊。</p>\n</blockquote>\n<h3 id=\"3-8-CSS-（元素选择器）\"><a href=\"#3-8-CSS-（元素选择器）\" class=\"headerlink\" title=\"3.8 CSS （元素选择器）\"></a>3.8 CSS （元素选择器）</h3><h4 id=\"3-8-1-id选择器\"><a href=\"#3-8-1-id选择器\" class=\"headerlink\" title=\"3.8.1 id选择器\"></a>3.8.1 id选择器</h4><p>根据id属性名来选择</p>\n<p>格式：#属性名</p>\n<h4 id=\"3-8-2-class选择器\"><a href=\"#3-8-2-class选择器\" class=\"headerlink\" title=\"3.8.2 class选择器\"></a>3.8.2 class选择器</h4><p>根据class属性名来选择</p>\n<p>格式：.属性名</p>\n<h4 id=\"3-8-3-元素选择器\"><a href=\"#3-8-3-元素选择器\" class=\"headerlink\" title=\"3.8.3 元素选择器\"></a>3.8.3 元素选择器</h4><p>根据元素的标签名称来选择</p>\n<p>格式：标签名</p>\n<h4 id=\"3-8-4-属性选择器\"><a href=\"#3-8-4-属性选择器\" class=\"headerlink\" title=\"3.8.4 属性选择器\"></a>3.8.4 属性选择器</h4><p>格式[属性&#x3D;‘属性名’] </p>\n<p>e.g. [id&#x3D;’passwordA’]</p>\n<h4 id=\"3-8-5-层级选择器\"><a href=\"#3-8-5-层级选择器\" class=\"headerlink\" title=\"3.8.5 层级选择器\"></a>3.8.5 层级选择器</h4><p><code>&gt;</code>找直接子集，只能找下一级</p>\n<p><code>空格</code>找后代</p>\n<pre><code class=\"java\">    @Test\n    public void cssSelectorTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(&quot;#userA&quot;)).sendKeys(&quot;admin&quot;);//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(&quot;[id=&#39;passwordA&#39;]&quot;)).sendKeys(&quot;123456&quot;);//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(&quot;.telA&quot;)).sendKeys(&quot;110&quot;);//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(&quot;span&quot;)).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(&quot;p&gt;input[type=&#39;emailA&#39;]&quot;)).sendKeys(&quot;123@qq.com&quot;);//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;\n</code></pre>\n<h4 id=\"3-8-6-CSS扩展\"><a href=\"#3-8-6-CSS扩展\" class=\"headerlink\" title=\"3.8.6 CSS扩展\"></a>3.8.6 CSS扩展</h4><p>input[type^&#x3D;’p’] 以p开头的元素</p>\n<p>input[type$&#x3D;’d’] 以d结尾的元素</p>\n<p>input[type*&#x3D;’w’] 包含w的元素</p>\n<h2 id=\"4-元素操作\"><a href=\"#4-元素操作\" class=\"headerlink\" title=\"4. 元素操作\"></a>4. 元素操作</h2><h3 id=\"4-1-元素操作常用方法\"><a href=\"#4-1-元素操作常用方法\" class=\"headerlink\" title=\"4.1 元素操作常用方法\"></a>4.1 元素操作常用方法</h3><p> click( ) 单击元素</p>\n<p> clear() 清除文本</p>\n<p>send_key(value) 输入文本</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void elementOperations() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(&quot;userA&quot;));\n        userA.sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;telA\\&quot;]&quot;)).sendKeys(&quot;1861111111111&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[4]/input&quot;)).sendKeys(&quot;123@qq.com&quot;);\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(&quot;18600000000&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;zc\\&quot;]/fieldset/button&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>文件上传案例：</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).click();//这样写是错误的\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).sendKeys(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-2-操作浏览器常用方法\"><a href=\"#4-2-操作浏览器常用方法\" class=\"headerlink\" title=\"4.2 操作浏览器常用方法\"></a>4.2 操作浏览器常用方法</h3><p>Selenium 4.0操作浏览器API变了。</p>\n<pre><code>//https://www.selenium.dev/documentation/webdriver/interactions/windows\n</code></pre>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testOps() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<p>注意，close永远是关闭主窗口。</p>\n<pre><code>    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;user\\&quot;]&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        System.out.println(&quot;关闭主窗口之前的标题&quot; +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h3 id=\"4-3-获取元素信息\"><a href=\"#4-3-获取元素信息\" class=\"headerlink\" title=\"4.3 获取元素信息\"></a>4.3 获取元素信息</h3><p>方法均来自于WebElement接口的对象。均以getXxx()开头。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).getSize();\n        System.out.println(&quot;Size: &quot; + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;));\n        String text = element.getText();\n        System.out.println(&quot;超链接文本: &quot; + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(&quot;href&quot;);\n        System.out.println(&quot;超链接地址: &quot; + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[5]/span&quot;));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? &quot;可见&quot; : &quot;不可见&quot;);\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[5]&quot;)).isEnabled();\n        System.out.println(enabled ? &quot;可用&quot; : &quot;不可用&quot;);\n        //6).判断页面中&#39;旅游&#39;对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[3]&quot;)).isSelected();\n        System.out.println(selected ? &quot;选中&quot; : &quot;未选中&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"5-鼠标和键盘操作\"><a href=\"#5-鼠标和键盘操作\" class=\"headerlink\" title=\"5. 鼠标和键盘操作\"></a>5. 鼠标和键盘操作</h2><h3 id=\"5-1-鼠标操作\"><a href=\"#5-1-鼠标操作\" class=\"headerlink\" title=\"5.1 鼠标操作\"></a>5.1 鼠标操作</h3><blockquote>\n<p>鼠标操作官方文档： <a href=\"https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\">https://www.selenium.dev/documentation/webdriver/actions_api/mouse/</a></p>\n</blockquote>\n<p>Actions对象的创建需要传入webdriver。</p>\n<p>通过调用Actions对象方法，来编写鼠标操作</p>\n<p>并用<code>perform()</code>来执行操作。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(&quot;admin&quot;);\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/button&quot;));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>拖拽操作demo：</p>\n<p>将red区块覆盖掉green区块。</p>\n<pre><code>    @Test\n    public void testDragAndDrop() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div1\\&quot;]&quot;));\n        WebElement green = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div2\\&quot;]&quot;));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<p>上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用</p>\n<p><code>actions.dragAndDropBy(Webelement element, int xOffset, int yOffset)</code>来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。</p>\n<p>拖拽的实现，其实可以细分成以下动作：</p>\n<ol>\n<li>鼠标悬停到指定区，</li>\n<li>按住鼠标左键</li>\n<li>将鼠标悬停到目标区块</li>\n<li>松开鼠标</li>\n</ol>\n<h3 id=\"5-2-键盘操作\"><a href=\"#5-2-键盘操作\" class=\"headerlink\" title=\"5.2 键盘操作\"></a>5.2 键盘操作</h3><p>Selenium的键盘操作全部封装在Keys这个enum类中。</p>\n<p><img src=\"/../img/image-20230926224301341.png\" alt=\"image-20230926224301341\"></p>\n<p>通过<code>webDriver.sendKeys(Keys.XXX)</code>来调用</p>\n<p>Demo:</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        usernameInput.sendKeys(&quot;admin1&quot;);//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, &quot;a&quot;);//全选\n        usernameInput.sendKeys(Keys.CONTROL, &quot;c&quot;);//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, &quot;v&quot;);//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"6-元素等待\"><a href=\"#6-元素等待\" class=\"headerlink\" title=\"6.元素等待\"></a>6.元素等待</h2><blockquote>\n<p>可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常</p>\n<p>举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。</p>\n<p>为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。</p>\n<p>具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。</p>\n</blockquote>\n<h3 id=\"6-1显示等待\"><a href=\"#6-1显示等待\" class=\"headerlink\" title=\"6.1显示等待\"></a>6.1显示等待</h3><blockquote>\n<p>定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。</p>\n<p>只针对单个元素有效</p>\n</blockquote>\n<p>官方文档：<a href=\"https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\">https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits</a></p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -&gt; d.findElement(By.id(&quot;userAA&quot;)));//故意写错的\n        element.sendKeys(&quot;admin&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"/../img/image-20230927033247981.png\" alt=\"image-20230927033247981\"></p>\n<p>这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。</p>\n<p>因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。</p>\n<p><img src=\"/../img/image-20230927033542151.png\" alt=\"image-20230927033542151\"></p>\n<h3 id=\"6-2隐式等待\"><a href=\"#6-2隐式等待\" class=\"headerlink\" title=\"6.2隐式等待\"></a>6.2隐式等待</h3><blockquote>\n<p>定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。</p>\n<p>隐式等待对所有元素都有效</p>\n</blockquote>\n<pre><code>package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(&quot;aaa&quot;));\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<p>可以把<code>webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);</code>注释掉，对比一下，是不是真的等了10秒钟。</p>\n<p>implicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法已经是deprecated的了。</p>\n<h2 id=\"7-下拉选择框\"><a href=\"#7-下拉选择框\" class=\"headerlink\" title=\"7. 下拉选择框\"></a>7. 下拉选择框</h2><p>html下拉框是<code>&lt;select&gt;</code>元素</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select/option[2]&quot;)).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n\n&#125;\n</code></pre>\n<h3 id=\"7-1-Select类\"><a href=\"#7-1-Select类\" class=\"headerlink\" title=\"7.1 Select类\"></a>7.1 Select类</h3><p>如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。</p>\n<p>select类创建时需要将select标签的webelement作为参数传进去。</p>\n<p>具体看注释。写的很清楚了</p>\n<pre><code class=\"java\">    @Test\n    public void testSelectClass() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select&quot;));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(&quot;gz&quot;);//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(&quot;A重庆&quot;);//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n</code></pre>\n<h2 id=\"8-弹出框\"><a href=\"#8-弹出框\" class=\"headerlink\" title=\"8. 弹出框\"></a>8. 弹出框</h2><p>常用三种：</p>\n<ol>\n<li><p>alert 警告框</p>\n</li>\n<li><p>confirm 确认框</p>\n</li>\n<li><p>prompt 提示框</p>\n</li>\n</ol>\n<p>处理方式都一样。</p>\n<ul>\n<li><p>如果点击警告框后不处理，那么后面的操作都无法执行。</p>\n</li>\n<li><p>处理方法：</p>\n<ol>\n<li>切换到对话框</li>\n<li>alert.text() &#x2F; alert.dismiss() &#x2F; alert.accept()</li>\n</ol>\n</li>\n</ul>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[6]&quot;)).click();//点击\n        Thread.sleep(5000);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"9-滚动条操作\"><a href=\"#9-滚动条操作\" class=\"headerlink\" title=\"9. 滚动条操作\"></a>9. 滚动条操作</h2><blockquote>\n<p>滚动条菜单使用场景</p>\n<ol>\n<li>在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 </li>\n<li>页面注册同意条款，需要滚动条到最底层，才能点击同意</li>\n</ol>\n</blockquote>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly&quot;);\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(&quot;window.scrollTo(0,10000)&quot;);//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"10-Frame切换\"><a href=\"#10-Frame切换\" class=\"headerlink\" title=\"10. Frame切换\"></a>10. Frame切换</h2><blockquote>\n<p>官网文档： <a href=\"https://www.selenium.dev/documentation/webdriver/interactions/frames/\">https://www.selenium.dev/documentation/webdriver/interactions/frames/</a></p>\n</blockquote>\n<p>多种办法。swtich完了记得switch回来。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(&quot;myframe1&quot;);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin1&quot;);//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"11-多窗口切换\"><a href=\"#11-多窗口切换\" class=\"headerlink\" title=\"11. 多窗口切换\"></a>11. 多窗口切换</h2><p>三个api：</p>\n<ol>\n<li>webDriver.switch().window(String handleName) 切换到指定句柄名的窗口<ul>\n<li>之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。</li>\n</ul>\n</li>\n<li>webDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄</li>\n<li>webDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄</li>\n</ol>\n<p>代码注释很清楚了。</p>\n<pre><code class=\"java\">package scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set&lt;String&gt; windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) &#123;\n            System.out.println(s);\n        &#125;\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) &#123;\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) &#123;\n                webDriver.switchTo().window(s);\n            &#125;\n        &#125;\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"12-截屏\"><a href=\"#12-截屏\" class=\"headerlink\" title=\"12.截屏\"></a>12.截屏</h2><pre><code>package scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException, IOException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.google.com&quot;);\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(&quot;./resources/image.png&quot;));\n    &#125;\n&#125;\n</code></pre>\n<p>Selenium入门完结。</p>\n<hr>\n","text":"1. Selenium官方文档 https://www.selenium.dev/documentation/ 2. 第一个Selenium测试案例使用idea...","permalink":"/post/Selenium学习","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[{"name":"软件测试","slug":"软件测试","count":4,"path":"api/categories/软件测试.json"}],"tags":[{"name":"Selenium","slug":"Selenium","count":2,"path":"api/tags/Selenium.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Selenium%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3\"><span class=\"toc-text\">1. Selenium官方文档</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%AC%AC%E4%B8%80%E4%B8%AASelenium%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 第一个Selenium测试案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. 元素定位方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-id-%EF%BC%88%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">3.1 id （元素属性）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-name-%EF%BC%88%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">3.2 name （元素属性）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-class-name-%EF%BC%88%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">3.3 class_name （元素属性）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-tag-name-%EF%BC%88%E6%A0%87%E7%AD%BE%E5%90%8D%E7%A7%B0%EF%BC%89\"><span class=\"toc-text\">3.4 tag_name （标签名称）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-link-text-%EF%BC%88%E8%B6%85%E9%93%BE%E6%8E%A5%EF%BC%89\"><span class=\"toc-text\">3.5 link_text （超链接）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-partial-link-text-%E8%B6%85%E9%93%BE%E6%8E%A5%EF%BC%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">3.6 partial_link_text (超链接，模糊查找)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-7-XPath-%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%85%83%E7%B4%A0%E8%B7%AF%E5%BE%84%EF%BC%89\"><span class=\"toc-text\">3.7 XPath （基于元素路径）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-7-1-%E8%B7%AF%E5%BE%84%E5%AE%9A%E4%BD%8D%EF%BC%9A%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">3.7.1 路径定位：绝对路径</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-7-2-%E8%B7%AF%E5%BE%84%E5%AE%9A%E4%BD%8D%EF%BC%9A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">3.7.2 路径定位：相对路径</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-7-3-XPath%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">3.7.3 XPath扩展</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-8-CSS-%EF%BC%88%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89\"><span class=\"toc-text\">3.8 CSS （元素选择器）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-1-id%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">3.8.1 id选择器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-2-class%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">3.8.2 class选择器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-3-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">3.8.3 元素选择器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-4-%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">3.8.4 属性选择器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-5-%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">3.8.5 层级选择器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-8-6-CSS%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">3.8.6 CSS扩展</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">4. 元素操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.1 元素操作常用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%93%8D%E4%BD%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.2 操作浏览器常用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">4.3 获取元素信息</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5. 鼠标和键盘操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5.1 鼠标操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5.2 键盘操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%85%83%E7%B4%A0%E7%AD%89%E5%BE%85\"><span class=\"toc-text\">6.元素等待</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1%E6%98%BE%E7%A4%BA%E7%AD%89%E5%BE%85\"><span class=\"toc-text\">6.1显示等待</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2%E9%9A%90%E5%BC%8F%E7%AD%89%E5%BE%85\"><span class=\"toc-text\">6.2隐式等待</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E4%B8%8B%E6%8B%89%E9%80%89%E6%8B%A9%E6%A1%86\"><span class=\"toc-text\">7. 下拉选择框</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1-Select%E7%B1%BB\"><span class=\"toc-text\">7.1 Select类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%BC%B9%E5%87%BA%E6%A1%86\"><span class=\"toc-text\">8. 弹出框</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">9. 滚动条操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-Frame%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">10. Frame切换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E5%A4%9A%E7%AA%97%E5%8F%A3%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">11. 多窗口切换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E6%88%AA%E5%B1%8F\"><span class=\"toc-text\">12.截屏</span></a></li></ol>","author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"测试基础回顾","uid":"836018e6b061b33a02925aab024ae1c6","slug":"测试理论","date":"2023-10-09T04:36:00.000Z","updated":"2023-11-08T23:11:26.285Z","comments":true,"path":"api/articles/测试理论.json","keywords":"Kangwei Zhu's Blog","cover":"/img/cake.jpg","text":"1. 主流测试技术1.1 功能测试 验证程序的功能是否能满足需求 1.2 自动化测试 使用代码或工具代替手工，对项目进行测试 1.3 接口测试 测接口。 1.4...","permalink":"/post/测试理论","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"软件测试","slug":"软件测试","count":4,"path":"api/categories/软件测试.json"}],"tags":[{"name":"软件测试","slug":"软件测试","count":2,"path":"api/tags/软件测试.json"}],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}},"next_post":{"title":"速通TestNG","uid":"c4b37ef49fa66d2e8dcfeb1e2c791dc4","slug":"TestNG学习","date":"2023-09-28T01:19:00.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/TestNG学习.json","keywords":"Kangwei Zhu's Blog","cover":[],"text":"TestNG1. TestNG官方文档： https://testng.org/doc/documentation-main.html 2. 什么是TestNG...","permalink":"/post/TestNG学习","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"软件测试","slug":"软件测试","count":4,"path":"api/categories/软件测试.json"}],"tags":[{"name":"TestNG","slug":"TestNG","count":1,"path":"api/tags/TestNG.json"}],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}}}