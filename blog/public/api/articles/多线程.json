{"title":"多线程笔记","uid":"a8cb7e5b0948656e80258acbb14ae2c8","slug":"多线程","date":"2023-03-12T10:02:04.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/多线程.json","keywords":"Kangwei Zhu's Blog","cover":"/img/cake.jpg","content":"<h2 id=\"Thread的三种创建方式\"><a href=\"#Thread的三种创建方式\" class=\"headerlink\" title=\"Thread的三种创建方式\"></a>Thread的三种创建方式</h2><h3 id=\"1-继承Thread类\"><a href=\"#1-继承Thread类\" class=\"headerlink\" title=\"1. 继承Thread类\"></a>1. 继承Thread类</h3><blockquote>\n<p>重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。</p>\n</blockquote>\n<ul>\n<li>调用run()方法，<strong>必然先执行</strong>run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会<strong>交替执行</strong>run内部代码以及run后面的代码。</li>\n<li>这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看<strong>CPU调度</strong>.</li>\n<li>Demo: MyThread &amp; MutiThreadDownloadDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyThread extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start方法被执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread&#123;\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) &#123;\n        this.url = url;\n        this.filename = filename;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(&quot;下载了文件名&quot; + this.filename);\n    &#125;\n\n    public static void main(String[] args)&#123;\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;1.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;2.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;3.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;4.jpg&quot;);\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader&#123;\n    public void download(String url, String filename) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;URL对象创建失败&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"2-实现Runnable接口\"><a href=\"#2-实现Runnable接口\" class=\"headerlink\" title=\"2. 实现Runnable接口\"></a>2. 实现Runnable接口</h3><blockquote>\n<p>定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对<br>象时的参数。最后调用thread对象的start()方法，开启线程</p>\n</blockquote>\n<ul>\n<li>本质是代理的思想。</li>\n<li>Thread类其实也实现了Runnable接口。</li>\n<li>Demo: MyRunnable</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start后面的代码执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li>思考：将MutiThreadDownload改造成实现Runnable接口方式</li>\n</ul>\n<h4 id=\"2-1-两种创建方式的对比\"><a href=\"#2-1-两种创建方式的对比\" class=\"headerlink\" title=\"2.1 两种创建方式的对比\"></a>2.1 两种创建方式的对比</h4><blockquote>\n<p>和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。<br>继承了Thread类，那么别的类就继承不了了。</p>\n</blockquote>\n<h4 id=\"2-2-初识并发问题\"><a href=\"#2-2-初识并发问题\" class=\"headerlink\" title=\"2.2 初识并发问题\"></a>2.2 初识并发问题</h4><blockquote>\n<p>火车票，多人抢了同一张票。</p>\n</blockquote>\n<ul>\n<li>Demo: TrainTicketDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable &#123;\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNumber &lt;= 0) &#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了第&quot; + ticketNumber-- + &quot;张票&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, &quot;小明&quot;);\n        Thread xiaofang = new Thread(train, &quot;小芳&quot;);\n        Thread xiaoli = new Thread(train, &quot;小李&quot;);\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"3-实现Callable接口\"><a href=\"#3-实现Callable接口\" class=\"headerlink\" title=\"3. 实现Callable接口\"></a>3. 实现Callable接口</h3><blockquote>\n<p>创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后<br>调用submit()方法提交执行，并启动该线程。可以用Future&lt;&gt;来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。</p>\n</blockquote>\n<ul>\n<li>Demo: MyCallable</li>\n</ul>\n<pre><code class=\"java\">    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable&lt;Boolean&gt; &#123;\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) &#123;\n        this.url = url;\n        this.fileName = fileName;\n    &#125;\n\n    @Override\n    public Boolean call() throws Exception &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(&quot;下载了&quot; + url + &quot; 地址的&quot; + fileName + &quot;文件&quot;);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        MyCallable myCallable1 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;1.png&quot;);\n        MyCallable myCallable2 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;2.png&quot;);\n        MyCallable myCallable3 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;3.png&quot;);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future&lt;Boolean&gt; f1 = executorService.submit(myCallable1);\n        Future&lt;Boolean&gt; f2 = executorService.submit(myCallable2);\n        Future&lt;Boolean&gt; f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"补票：-静态代理模式\"><a href=\"#补票：-静态代理模式\" class=\"headerlink\" title=\"补票： 静态代理模式\"></a>补票： 静态代理模式</h3><blockquote>\n<p>其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。</p>\n</blockquote>\n<ul>\n<li>Runnable接口实现类和Thread的关系</li>\n<li>Demo： StaticProxyDemo</li>\n</ul>\n<pre><code class=\"java\">package com.anicaaz.thread;\n\npublic class StaticProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void getMarried();\n&#125;\n\nclass You implements Marry &#123;\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;你结婚了&quot;);\n    &#125;\n&#125;\n\nclass WeddingCompany implements Marry &#123;\n    private You you;\n\n    public WeddingCompany(You you) &#123;\n        this.you = you;\n    &#125;\n\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;定酒店&quot;);\n        System.out.println(&quot;布置&quot;);\n        you.getMarried();\n        System.out.println(&quot;收拾&quot;);\n        System.out.println(&quot;结账&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-Lamda表达式-package-lambda\"><a href=\"#4-Lamda表达式-package-lambda\" class=\"headerlink\" title=\"4. Lamda表达式 (package: lambda)\"></a>4. Lamda表达式 (package: lambda)</h3><blockquote>\n<p>任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();</p>\n</blockquote>\n<pre><code class=\"java\">public interface MyRunnable &#123;\n    public abstract void run(); // =&gt; void run();\n&#125;\n</code></pre>\n<p>对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。</p>\n<h4 id=\"4-1-Lambda的演化过程\"><a href=\"#4-1-Lambda的演化过程\" class=\"headerlink\" title=\"4.1 Lambda的演化过程:\"></a>4.1 Lambda的演化过程:</h4><h5 id=\"4-1-1-传统写法：创建实现类对象，调用接口方法。\"><a href=\"#4-1-1-传统写法：创建实现类对象，调用接口方法。\" class=\"headerlink\" title=\"4.1.1 传统写法：创建实现类对象，调用接口方法。\"></a>4.1.1 传统写法：创建实现类对象，调用接口方法。</h5><pre><code class=\"java\">public class TestLambda1 implements MyRunnable&#123;\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;标准的实现方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-2-静态内部类写法\"><a href=\"#4-1-2-静态内部类写法\" class=\"headerlink\" title=\"4.1.2 静态内部类写法\"></a>4.1.2 静态内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda2 &#123;\n\n    static class MyRunnableImpl implements MyRunnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;静态内部类实现&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n\n&#125;\n</code></pre>\n<h5 id=\"4-1-3-局部内部类写法\"><a href=\"#4-1-3-局部内部类写法\" class=\"headerlink\" title=\"4.1.3 局部内部类写法\"></a>4.1.3 局部内部类写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda3 &#123;\n\n    public static void main(String[] args) &#123;\n        class MyRunnableImpl implements MyRunnable &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;局部内部类写法&quot;);\n            &#125;\n        &#125;\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-4-匿名内部类写法\"><a href=\"#4-1-4-匿名内部类写法\" class=\"headerlink\" title=\"4.1.4 匿名内部类写法\"></a>4.1.4 匿名内部类写法</h5><p>没有类的名字</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda4 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;匿名内部类写法&quot;);\n            &#125;\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<h5 id=\"4-1-5-Lambda写法\"><a href=\"#4-1-5-Lambda写法\" class=\"headerlink\" title=\"4.1.5 Lambda写法\"></a>4.1.5 Lambda写法</h5><pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class TestLambda5 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = () -&gt; &#123;\n            System.out.println(&quot;Lambda 写法&quot;);\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;\n</code></pre>\n<p>Lambda的主要作用是<strong>避免内部类过多</strong></p>\n<p>Lambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果<strong>参数只有一个</strong>，可以省略括号。如果<strong>行数只有一行</strong>，可以省略大括号。</p>\n<pre><code class=\"java\">package com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 &#123;\n\n    public static void main(String[] args) &#123;\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1 , 2);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-线程状态-package-threadState\"><a href=\"#5-线程状态-package-threadState\" class=\"headerlink\" title=\"5. 线程状态  (package: threadState)\"></a>5. 线程状态  (package: threadState)</h3><ol>\n<li>新生<blockquote>\n<p>线程的创建</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"java\">Thread thread = new Thread();\n</code></pre>\n<ol start=\"2\">\n<li>就绪</li>\n</ol>\n<pre><code class=\"java\">thread.start();\n</code></pre>\n<ol start=\"3\">\n<li>运行<br>start之后，抢占到cpu资源。cpu调度开始执行。</li>\n<li>阻塞<br>调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行</li>\n<li>死亡<br>线程中断或结束，就进入死亡状态，无法重新启动。</li>\n</ol>\n<h4 id=\"5-1-如何停止线程\"><a href=\"#5-1-如何停止线程\" class=\"headerlink\" title=\"5.1 如何停止线程\"></a>5.1 如何停止线程</h4><blockquote>\n<p>建议使用flag停止线程。不建议使用destory()、stop()进行停止。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable&#123;\n\n    private boolean flag;\n\n    @Override\n    public void run() &#123;\n        while (flag) &#123;\n            System.out.println(&quot;线程正在运行&quot;);\n        &#125;\n    &#125;\n\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            if (i == 900) &#123;\n                runnable.stop();\n                System.out.println(&quot;线程停止了&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;main&quot; + i);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-2-Sleep-线程阻塞-休眠\"><a href=\"#5-2-Sleep-线程阻塞-休眠\" class=\"headerlink\" title=\"5.2 Sleep 线程阻塞(休眠)\"></a>5.2 Sleep 线程阻塞(休眠)</h4><ul>\n<li>sleep中的参数指的是当前线程阻塞的毫秒数</li>\n<li>需要抛InterruptedException</li>\n<li>sleep之间到达之后线程进入阻塞状态</li>\n<li><strong>每个对象都有一个锁</strong>，sleep不会释放锁</li>\n</ul>\n<p>Demo： 打表</p>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-3-Yield，线程礼让\"><a href=\"#5-3-Yield，线程礼让\" class=\"headerlink\" title=\"5.3 Yield，线程礼让\"></a>5.3 Yield，线程礼让</h4><blockquote>\n<p>礼让线程，让当前正在执行的线程暂停，但不阻塞<br>让线程从<strong>运行状态</strong>转为<strong>就绪状态</strong><br>让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现<strong>不成功</strong>的现象</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;\n</code></pre>\n<h4 id=\"5-4-join线程强制执行\"><a href=\"#5-4-join线程强制执行\" class=\"headerlink\" title=\"5.4 join线程强制执行\"></a>5.4 join线程强制执行</h4><blockquote>\n<p>可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。</p>\n</blockquote>\n<pre><code class=\"java\">package com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 300; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, &quot;vip&quot;);\n        thread.start();\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n            if (i == 100) &#123;\n                try &#123;\n                    thread.join();\n                &#125; catch (InterruptedException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","text":"Thread的三种创建方式1. 继承Thread类 重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()...","permalink":"/post/多线程","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Java基础","slug":"Java基础","count":3,"path":"api/categories/Java基础.json"}],"tags":[{"name":"Java多线程","slug":"Java多线程","count":1,"path":"api/tags/Java多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Thread%E7%9A%84%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">Thread的三种创建方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB\"><span class=\"toc-text\">1. 继承Thread类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2. 实现Runnable接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">2.1 两种创建方式的对比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E5%88%9D%E8%AF%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.2 初识并发问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">3. 实现Callable接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E7%A5%A8%EF%BC%9A-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">补票： 静态代理模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F-package-lambda\"><span class=\"toc-text\">4. Lamda表达式 (package: lambda)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-Lambda%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">4.1 Lambda的演化过程:</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-1-%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E3%80%82\"><span class=\"toc-text\">4.1.1 传统写法：创建实现类对象，调用接口方法。</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95\"><span class=\"toc-text\">4.1.2 静态内部类写法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95\"><span class=\"toc-text\">4.1.3 局部内部类写法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%99%E6%B3%95\"><span class=\"toc-text\">4.1.4 匿名内部类写法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-5-Lambda%E5%86%99%E6%B3%95\"><span class=\"toc-text\">4.1.5 Lambda写法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-package-threadState\"><span class=\"toc-text\">5. 线程状态  (package: threadState)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">5.1 如何停止线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-Sleep-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E-%E4%BC%91%E7%9C%A0\"><span class=\"toc-text\">5.2 Sleep 线程阻塞(休眠)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-3-Yield%EF%BC%8C%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9\"><span class=\"toc-text\">5.3 Yield，线程礼让</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-4-join%E7%BA%BF%E7%A8%8B%E5%BC%BA%E5%88%B6%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">5.4 join线程强制执行</span></a></li></ol></li></ol></li></ol>","author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"探索LCU","uid":"d963b9f41994dba4a0ae074a338ebfb7","slug":"2023-07-11-探索LCU","date":"2023-07-11T04:00:00.000Z","updated":"2023-11-11T06:01:35.703Z","comments":true,"path":"api/articles/2023-07-11-探索LCU.json","keywords":"Kangwei Zhu's Blog","cover":[],"text":"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手项目依赖 xml&lt;!--JSON转Map依赖--&gt; &lt;dependenc...","permalink":"/post/2023-07-11-探索LCU","photos":[],"count_time":{"symbolsCount":"9.8k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}},"next_post":{"title":"Spring笔记","uid":"9fe79a5e2d58fcbcba8e87cdea7a0f13","slug":"Spring笔记","date":"2023-02-12T14:34:49.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/Spring笔记.json","keywords":"Kangwei Zhu's Blog","cover":"/img/rice.jpg","text":"Spring复习笔记 Spring是开源的免费框架 轻量级、非入侵式的 IOC控制反转， AOP面向切面编程 是重点 支持事务，对框架·整合的指出 也是重点 总...","permalink":"/post/Spring笔记","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":1,"path":"api/categories/后端开发.json"}],"tags":[{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}}}