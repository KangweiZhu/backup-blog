{"title":"Spring笔记","uid":"9fe79a5e2d58fcbcba8e87cdea7a0f13","slug":"Spring笔记","date":"2023-02-12T14:34:49.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/Spring笔记.json","keywords":"Kangwei Zhu's Blog","cover":"/img/rice.jpg","content":"<h1 id=\"Spring复习笔记\"><a href=\"#Spring复习笔记\" class=\"headerlink\" title=\"Spring复习笔记\"></a>Spring复习笔记</h1><blockquote>\n<p>Spring是开源的免费框架</p>\n<p><strong>轻量级、非入侵式的</strong></p>\n<p><strong>IOC控制反转， AOP面向切面</strong>编程 \t\t\t\t\t是重点</p>\n<p>支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点</p>\n</blockquote>\n<p>总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。</p>\n<h2 id=\"LC1-任何项目，首先先导这两个maven\"><a href=\"#LC1-任何项目，首先先导这两个maven\" class=\"headerlink\" title=\"LC1. 任何项目，首先先导这两个maven\"></a>LC1. 任何项目，首先先导这两个maven</h2><pre><code>1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\n</code></pre>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092051417.png\" alt=\"image-20230417092051417\"></p>\n<h2 id=\"LC2-Spring简介\"><a href=\"#LC2-Spring简介\" class=\"headerlink\" title=\"LC2. Spring简介\"></a>LC2. Spring简介</h2><blockquote>\n<ul>\n<li><p>Springboot快速开发的脚手架。基于springboot可以快速开发单个微服务.</p>\n</li>\n<li><p>Springcloud是基于springboot实现的。</p>\n</li>\n</ul>\n</blockquote>\n<p>Spring起到了承上启下的作用。</p>\n<p>弊端： 发展了太久，违背了原来的理念。</p>\n<blockquote>\n<h2 id=\"LC3-Spring-IOC\"><a href=\"#LC3-Spring-IOC\" class=\"headerlink\" title=\"LC3. Spring IOC\"></a>LC3. Spring IOC</h2></blockquote>\n<p>以前写业务</p>\n<ul>\n<li><p>UserDao接口</p>\n</li>\n<li><p>UserDaoImpl实现类(会有多个)</p>\n</li>\n<li><p>UserService 业务接口</p>\n</li>\n<li><p>UserServiceImpl业务实现类(会有多个)</p>\n</li>\n<li><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417104203040.png\" alt=\"image-20230417104203040\"></p>\n</li>\n</ul>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092414541.png\" alt=\"image-20230417092414541\"></p>\n<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。</p>\n<p>改进1：<img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417092618282.png\" alt=\"image-20230417092618282\"></p>\n<p>这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。</p>\n<p>也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。<strong>系统的耦合性降低</strong>。</p>\n<h2 id=\"LC4-IOC本质\"><a href=\"#LC4-IOC本质\" class=\"headerlink\" title=\"LC4: IOC本质\"></a>LC4: IOC本质</h2><p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417101934817.png\" alt=\"image-20230417101934817\"></p>\n<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。</p>\n<p><strong>控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。</strong></p>\n<blockquote>\n<p><strong>大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可</strong></p>\n</blockquote>\n<h2 id=\"LC5-Bean-Definition-Inheritance-Bean标签的理解\"><a href=\"#LC5-Bean-Definition-Inheritance-Bean标签的理解\" class=\"headerlink\" title=\"LC5: Bean Definition Inheritance (Bean标签的理解)\"></a>LC5: Bean Definition Inheritance (Bean标签的理解)</h2><blockquote>\n<p>“Bean definition can contain a lot of configuration information, including <strong>constructor arguments</strong>, <strong>property values</strong>, and <strong>container-specific information</strong>, such as the <strong>initialization method</strong>, a static factory method name, and so on. “</p>\n</blockquote>\n<p>需要掌握的代码</p>\n<pre><code class=\"java\">ApplicationContext applicationConext = new ClassPathXmlApplicationContext(&quot;BeanName.xml&quot;);\n</code></pre>\n<h2 id=\"LC6-Spring对象的创建\"><a href=\"#LC6-Spring对象的创建\" class=\"headerlink\" title=\"LC6. Spring对象的创建\"></a>LC6. Spring对象的创建</h2><ol>\n<li>Spring容器默认使用无参构造创建对象</li>\n<li>假如需要使用有参构造创建对象， 三种方式 <constructor-arg><ol>\n<li>下标 index</li>\n<li>参数类型 type   -&gt; 不建议使用，多个同类型的参数，会乱。</li>\n<li>直接通过参数名 name.<ul>\n<li>也可以用ref 对象的方法。和通过参数名类似。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。</strong></p>\n<blockquote>\n<p>面试： BeanFactory相关。</p>\n<p>BeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了</p>\n</blockquote>\n<h3 id=\"1-BeanPostProcessor-是什么？\"><a href=\"#1-BeanPostProcessor-是什么？\" class=\"headerlink\" title=\"1.BeanPostProcessor 是什么？\"></a>1.BeanPostProcessor 是什么？</h3><blockquote>\n<p>“The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom <code>BeanPostProcessor</code> implementations.”</p>\n</blockquote>\n<p>首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。</p>\n<h2 id=\"LC7-Spring配置详解\"><a href=\"#LC7-Spring配置详解\" class=\"headerlink\" title=\"LC7. Spring配置详解\"></a>LC7. Spring配置详解</h2><h3 id=\"1-别名\"><a href=\"#1-别名\" class=\"headerlink\" title=\"1. 别名\"></a>1. 别名</h3><p><bean> 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。</p>\n<p>使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。</p>\n<h3 id=\"2-Import\"><a href=\"#2-Import\" class=\"headerlink\" title=\"2. Import\"></a>2. Import</h3><p>将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下</p>\n<pre><code class=\"xml\">&lt;import resource=&quot;beans1.xml&quot;&gt;\n&lt;import resource=&quot;beans2.xml&quot;&gt;    \n&lt;import resource=&quot;beans3.xml&quot;&gt;    \n</code></pre>\n<h2 id=\"LC8-依赖注入\"><a href=\"#LC8-依赖注入\" class=\"headerlink\" title=\"LC8. 依赖注入\"></a>LC8. 依赖注入</h2><h3 id=\"1-构造器注入\"><a href=\"#1-构造器注入\" class=\"headerlink\" title=\"1. 构造器注入\"></a>1. 构造器注入</h3><p>​\t前面讲过了</p>\n<pre><code class=\"xml\">&lt;constructor-arg&gt;\n</code></pre>\n<h3 id=\"2-Set方式注入\"><a href=\"#2-Set方式注入\" class=\"headerlink\" title=\"2. Set方式注入\"></a>2. Set方式注入</h3><blockquote>\n<p>各种数据类型的注入</p>\n<p><img src=\"C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165807121.png![image-20230417165836555](C:\\Users\\18795\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230417165836555.png\" alt=\"image-20230417165807121\"></p>\n</blockquote>\n<h3 id=\"3-拓展方式注入\"><a href=\"#3-拓展方式注入\" class=\"headerlink\" title=\"3. 拓展方式注入\"></a>3. 拓展方式注入</h3><p>命名空间注入：</p>\n<p>比如 p命名空间，直接能够注入property</p>\n<pre><code>&lt;beans id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; p:name=&quot;xxx&quot; p:age=&quot;11&quot;;\n</code></pre>\n<p>以及  c命名空间，其实就是constructor-arg</p>\n<h2 id=\"LC9-Bean的作用域\"><a href=\"#LC9-Bean的作用域\" class=\"headerlink\" title=\"LC9. Bean的作用域\"></a>LC9. Bean的作用域</h2><ol>\n<li>单例模式（默认）</li>\n<li>原型模式</li>\n</ol>\n<h2 id=\"LC10-Bean的自动装配\"><a href=\"#LC10-Bean的自动装配\" class=\"headerlink\" title=\"LC10. Bean的自动装配\"></a>LC10. Bean的自动装配</h2><blockquote>\n<ol>\n<li><strong>如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错</strong></li>\n<li><strong>而byType相反。你bean id想怎么写就怎么写。</strong> 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.</li>\n</ol>\n</blockquote>\n<p>Spring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。</p>\n<p>可以直接去Spring官网复制黏贴代码就可以。节约时间。</p>\n<p>链接： <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config</a></p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p>复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。</p>\n<p>补充:</p>\n<pre><code>&lt;context:annotation-config/&gt; 隐式的注册了以下的PostProcessors\n\n    ConfigurationClassPostProcessor\n\n    AutowiredAnnotationBeanPostProcessor\n\n    CommonAnnotationBeanPostProcessor\n\n    PersistenceAnnotationBeanPostProcessor\n\n    EventListenerMethodProcessor\n\n</code></pre>\n<h3 id=\"1-Autowired可以用在哪里\"><a href=\"#1-Autowired可以用在哪里\" class=\"headerlink\" title=\"1. Autowired可以用在哪里\"></a>1. Autowired可以用在哪里</h3><ul>\n<li><p>构造器上</p>\n<ul>\n<li><p>注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。</p>\n<pre><code>As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>传统的set方法上</p>\n</li>\n</ul>\n<pre><code class=\"java\">public class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n<ul>\n<li><p>带参的方法上</p>\n<pre><code>public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(MovieCatalog movieCatalog,\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>成员变量和构造方法上</p>\n<pre><code class=\"java\">public class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n</code></pre>\n</li>\n<li><p>如果想让Spring为相同类型的多个bean的话，可以使用数组、集合</p>\n<pre><code>public class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n\n    // ...\n&#125;\n\npublic class MovieRecommender &#123;\n\n    private Set&lt;MovieCatalog&gt; movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n</code></pre>\n</li>\n</ul>\n<h3 id=\"2-Autowire失败条件\"><a href=\"#2-Autowire失败条件\" class=\"headerlink\" title=\"2. Autowire失败条件\"></a>2. Autowire失败条件</h3><blockquote>\n<p>utowiring fails when no matching candidate beans are available for a given injection point.</p>\n</blockquote>\n<h3 id=\"3-Autowiresd-required-false-意思\"><a href=\"#3-Autowiresd-required-false-意思\" class=\"headerlink\" title=\"3. @Autowiresd(required&#x3D; false) 意思\"></a>3. @Autowiresd(required&#x3D; false) 意思</h3><pre><code>In other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.\n</code></pre>\n<p>其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。</p>\n<h3 id=\"4-什么是Qualifier\"><a href=\"#4-什么是Qualifier\" class=\"headerlink\" title=\"4. 什么是Qualifier\"></a>4. 什么是Qualifier</h3><blockquote>\n<p>多个同类型的bean实现autowire的时候使用</p>\n<pre><code class=\"xml\">@AutoWired\n@Qualifier(value=xxx1)\nprivate Dog dog;\n\n\n\n\n&lt;xml ....&gt;\n\n&lt;bean id=&#39;xxx1&#39; class=&quot;dog&quot;&gt;\n&lt;bean id=&quot;xxx&quot;, class = &quot;dog&quot;&gt;\n</code></pre>\n</blockquote>\n<h3 id=\"5-Resource注解\"><a href=\"#5-Resource注解\" class=\"headerlink\" title=\"5. Resource注解\"></a>5. Resource注解</h3><blockquote>\n<p>Javax.annotation.resource</p>\n<p>Ioc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。</p>\n</blockquote>\n<p>引申问题： Resource和Autowire的区别？</p>\n<h2 id=\"LC11-注解开发\"><a href=\"#LC11-注解开发\" class=\"headerlink\" title=\"LC11 注解开发\"></a>LC11 注解开发</h2><p>关键字：@ component</p>\n<p>在spring4之后，需要导入aop包，来开启注解开发。</p>\n<pre><code>spring-aop\n</code></pre>\n<p>流程：</p>\n<ol>\n<li><pre><code class=\"xml\"> &lt;context:annotation-config&gt; \n \n</code></pre>\n</li>\n<li><pre><code class=\"xml\"> &lt;context:component-scan base-package=&quot;com.example.xxx&quot;&gt;\n &lt;!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效--&gt;\n</code></pre>\n</li>\n</ol>\n<p>@component 挂在类上，代表这个类被spring管理了</p>\n<p>@Value挂在变量上面，代表这个变量的值</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\nprivate String name;\n</code></pre>\n<ul>\n<li><p>也可以挂在set方法上。同理</p>\n<pre><code class=\"java\">@Value(&quot;anicaa&quot;)\npublic void setName(String name)&#123;\n    this.name = name;\n&#125;\n</code></pre>\n</li>\n</ul>\n<p>@Scope，就是决定单例，多例的注解。同样挂在类上。</p>\n<pre><code class=\"java\">@Scope(&quot;prototype&quot;)\n@Scope(&quot;singleton&quot;)\n</code></pre>\n<h3 id=\"components注解的衍生\"><a href=\"#components注解的衍生\" class=\"headerlink\" title=\"@components注解的衍生\"></a>@components注解的衍生</h3><blockquote>\n<p>在web开发中，我们会按照model-view-controller三层架构来分层。</p>\n<ol>\n<li>dao层</li>\n<li>service层</li>\n<li>controller层</li>\n</ol>\n<p><strong>每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。</strong></p>\n</blockquote>\n<h2 id=\"LC12-使用纯Java配置Spring\"><a href=\"#LC12-使用纯Java配置Spring\" class=\"headerlink\" title=\"LC12. 使用纯Java配置Spring\"></a>LC12. 使用纯Java配置Spring</h2><blockquote>\n<p>旨在离开xml配置，只使用java就能完成配置。</p>\n</blockquote>\n<pre><code class=\"java\">//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig &#123;\n\n    @Bean\n    public User getUser()&#123;\n        return new User();\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n    @Value(&quot;anicaa&quot;)\n    private String name;\n\n    public String getName()&#123;\n        return this.name;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(&quot;getUser&quot;);\n        System.out.println(user.getName());\n    &#125;\n&#125;\n</code></pre>\n<ul>\n<li><p>挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.</p>\n</li>\n<li><p>@ComponentScan(“com.exmaple.xxx”). 挂在config类头上，就是扫描。</p>\n</li>\n<li><p>@Import() 导入别的config类.</p>\n</li>\n</ul>\n<h2 id=\"LC13-AOP\"><a href=\"#LC13-AOP\" class=\"headerlink\" title=\"LC13. AOP\"></a>LC13. AOP</h2><blockquote>\n<p>Spring中比较重要的模式： 代理模式 和 工厂模式</p>\n</blockquote>\n<h3 id=\"设计模式-代理模式（AOP底层）\"><a href=\"#设计模式-代理模式（AOP底层）\" class=\"headerlink\" title=\"设计模式-代理模式（AOP底层）\"></a>设计模式-代理模式（AOP底层）</h3><h4 id=\"1-静态代理\"><a href=\"#1-静态代理\" class=\"headerlink\" title=\"1. 静态代理\"></a>1. 静态代理</h4><blockquote>\n<p>静态代理的<strong>静态</strong>，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例</p>\n</blockquote>\n<ol>\n<li>User Service接口</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>UserServiceImpl 实现类</li>\n</ol>\n<pre><code class=\"java\">package com.example.test;\n\npublic class UserServiceImpl implements UserService&#123;\n\n\n    @Override\n    public void add() &#123;\n        System.out.println(&quot;添加了&quot;);\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        System.out.println(&quot;删除了&quot;);\n    &#125;\n\n    @Override\n    public void query() &#123;\n        System.out.println(&quot;查询了&quot;);\n    &#125;\n\n    @Override\n    public void update() &#123;\n        System.out.println(&quot;更新了&quot;);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>UserServiceProxy 静态代理类。</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService &#123;\n    private UserServiceImpl userService;\n\n    public UserServiceProxy()&#123;\n\n    &#125;\n\n    public UserServiceProxy(UserServiceImpl userService)&#123;\n        this.userService = userService;\n    &#125;\n\n    @Override\n    public void add() &#123;\n        log(&quot;add&quot;);\n        userService.add();\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        log(&quot;delete&quot;);\n        userService.delete();\n    &#125;\n\n    @Override\n    public void query() &#123;\n        log(&quot;query&quot;);\n        userService.query();\n    &#125;\n\n    @Override\n    public void update() &#123;\n        log(&quot;update&quot;);\n        userService.update();\n    &#125;\n\n    public void log(String str)&#123;\n        System.out.println(&quot;call &quot; + str);\n    &#125;\n&#125;\n</code></pre>\n<p>4.Client 类. 调用了代理，执行接口的放法。</p>\n<pre><code>package com.example.test;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    &#125;\n&#125;\n</code></pre>\n<p>在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。</p>\n<h4 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2. 动态代理\"></a>2. 动态代理</h4><blockquote>\n<p>而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。</p>\n<p>在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。</p>\n<p>原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。</p>\n<p>现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler</p>\n<pre><code class=\"java\">setTarget(Object target)\n</code></pre>\n<p>就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类<strong>所对应的接口</strong>，并把这个接口返回给我们。<br>之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。</p>\n</blockquote>\n<ol>\n<li>InvocationHandler</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"2\">\n<li>Client</li>\n</ol>\n<pre><code>package com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"LC14-Spring-AOP\"><a href=\"#LC14-Spring-AOP\" class=\"headerlink\" title=\"LC14. Spring AOP\"></a>LC14. Spring AOP</h2>","text":"Spring复习笔记 Spring是开源的免费框架 轻量级、非入侵式的 IOC控制反转， AOP面向切面编程 是重点 支持事务，对框架·整合的指出 也是重点 总...","permalink":"/post/Spring笔记","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"后端开发","slug":"后端开发","count":1,"path":"api/categories/后端开发.json"}],"tags":[{"name":"Spring","slug":"Spring","count":2,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0\"><span class=\"toc-text\">Spring复习笔记</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC1-%E4%BB%BB%E4%BD%95%E9%A1%B9%E7%9B%AE%EF%BC%8C%E9%A6%96%E5%85%88%E5%85%88%E5%AF%BC%E8%BF%99%E4%B8%A4%E4%B8%AAmaven\"><span class=\"toc-text\">LC1. 任何项目，首先先导这两个maven</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC2-Spring%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">LC2. Spring简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC3-Spring-IOC\"><span class=\"toc-text\">LC3. Spring IOC</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC4-IOC%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">LC4: IOC本质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC5-Bean-Definition-Inheritance-Bean%E6%A0%87%E7%AD%BE%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">LC5: Bean Definition Inheritance (Bean标签的理解)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC6-Spring%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">LC6. Spring对象的创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-BeanPostProcessor-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">1.BeanPostProcessor 是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC7-Spring%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">LC7. Spring配置详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%AB%E5%90%8D\"><span class=\"toc-text\">1. 别名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Import\"><span class=\"toc-text\">2. Import</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC8-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">LC8. 依赖注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">1. 构造器注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">2. Set方式注入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%8B%93%E5%B1%95%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">3. 拓展方式注入</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC9-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">LC9. Bean的作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC10-Bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D\"><span class=\"toc-text\">LC10. Bean的自动装配</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Autowired%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C\"><span class=\"toc-text\">1. Autowired可以用在哪里</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Autowire%E5%A4%B1%E8%B4%A5%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">2. Autowire失败条件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Autowiresd-required-false-%E6%84%8F%E6%80%9D\"><span class=\"toc-text\">3. @Autowiresd(required&#x3D; false) 意思</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%80%E4%B9%88%E6%98%AFQualifier\"><span class=\"toc-text\">4. 什么是Qualifier</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Resource%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">5. Resource注解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC11-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">LC11 注解开发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#components%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A1%8D%E7%94%9F\"><span class=\"toc-text\">@components注解的衍生</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC12-%E4%BD%BF%E7%94%A8%E7%BA%AFJava%E9%85%8D%E7%BD%AESpring\"><span class=\"toc-text\">LC12. 使用纯Java配置Spring</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC13-AOP\"><span class=\"toc-text\">LC13. AOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88AOP%E5%BA%95%E5%B1%82%EF%BC%89\"><span class=\"toc-text\">设计模式-代理模式（AOP底层）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">1. 静态代理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">2. 动态代理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LC14-Spring-AOP\"><span class=\"toc-text\">LC14. Spring AOP</span></a></li></ol></li></ol>","author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"多线程笔记","uid":"a8cb7e5b0948656e80258acbb14ae2c8","slug":"多线程","date":"2023-03-12T10:02:04.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/多线程.json","keywords":"Kangwei Zhu's Blog","cover":"/img/cake.jpg","text":"Thread的三种创建方式1. 继承Thread类 重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()...","permalink":"/post/多线程","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Java基础","slug":"Java基础","count":3,"path":"api/categories/Java基础.json"}],"tags":[{"name":"Java多线程","slug":"Java多线程","count":1,"path":"api/tags/Java多线程.json"}],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}},"next_post":{"title":"接口测试","uid":"c5b4816193947aa93e977c106cb13634","slug":"接口自动化","date":"2023-02-12T14:34:49.000Z","updated":"2023-11-08T23:11:26.282Z","comments":true,"path":"api/articles/接口自动化.json","keywords":"Kangwei Zhu's Blog","cover":"/img/rice.jpg","text":"1. 回顾1.1 URLURL： 统一资源定位符 格式： 协议:&#x2F;&#x2F;hostname:port&#x2F;path?参数&#x3D;值&am...","permalink":"/post/接口自动化","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"软件测试","slug":"软件测试","count":4,"path":"api/categories/软件测试.json"}],"tags":[{"name":"软件测试","slug":"软件测试","count":2,"path":"api/tags/软件测试.json"}],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}}}}