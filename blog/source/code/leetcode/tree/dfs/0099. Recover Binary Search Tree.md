这道题目前应该是有两种做法，我目前就交了一种看上去比较复杂的方法。
首先先说一下，还有一个方法是：同样做in-order遍历，将每个节点提到list里，然后对值做排序，最后按照排序的结果重新对所有节点一次赋值。

但是，不管是那种方法，用到的原理都是一样的，即：in-order traverse时，所有的节点大小，都是**单调递增**的。
所以这题只要会in-order traverse就非常简单，用不着gpt了。

不过，有一个小细节
```java
      if (first == null && current.val < previous.val) {
          first = previous;
      }
      if (first != null && current.val < previous.val) {
          second = current;
      }
```
为什么first = current, second = previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，
```
      1
     / 
    3   
     \
      2 
```
first一定是问题的根源，所以锁死3。 走到2的时候发现了 2 < 3 这个问题，所以second记录到2。 但是2不是最终的问题所在，他只是**临时存在的问题**，因为回到1了之后，我们会发现 3 > 1。 也就是说， 1才是最后一个发现的问题。 所以将 **根源** 和 **最终的问题** 进行替换`。也就是变成这样：
```
      3
     / 
    1   
     \
      2 
```
---
如果有点抽象，还是不懂的话，我们可以把第一个测试用例改成这样：
```
      4
     / 
    3   
     \
      2 
```
这时候，3 是 **第一次发现问题的根节点， 也就是根源**，锁死。
2 < 3， 2是**临时存在的问题（也是第一次发现的问题，后续可能还有多个）**， second记录到2。 
然后回到4， 发现 3 < 4 是正常的，所以此时， `最终的问题`就是2。那么同样的， 也是将将 **根源** 和 **最终的问题** 进行替换`。也就是变成
```
      4
     / 
    2   
     \
      3 
```